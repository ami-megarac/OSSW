--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist
@@ -0,0 +1,29 @@
+bits/mcontext.h
+bits/stat16.h
+fpu.h
+machine/pal.h
+net/ethernet.h
+net/if_arp.h
+net/if_ether.h
+net/if_dl.h
+net/route.h
+nfs/nfs.h
+regdef.h
+sa_len.c
+stat16conv.c
+statfsconv.c
+sys/acl.h
+sys/extattr.h
+sys/io.h
+sys/jail.h
+sys/linker.h
+sys/mount.h
+sys/perm.h
+sys/rfork.h
+sys/rtprio.h
+sys/syslimits.h
+sys/timex.h
+sys/vm86.h
+sys_lseek.S
+sysarch.h
+ucontext_i.h
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies
@@ -0,0 +1,11 @@
+# The kernel include files come from the 'kernel-include' add-on.
+# This is actually added by configure.in.
+#/usr/src/sys/
+
+# One of two possible utmp file formats.
+# This is actually added by configure.in.
+#unix/bsd/bsd4.4/kfreebsd/utmp-xyz
+
+# The gnu subdirectory exists for things common to Linux-based, Hurd-based
+# and kFreeBSD-based GNU systems.
+gnu
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile
@@ -0,0 +1,135 @@
+# Use bash, not /bin/sh, for executing scripts, because the native
+# FreeBSD /bin/sh does not interpret the  IFS="<tab>" read ...  command
+# in localedata/tst-fmon.sh correctly.
+SHELL = bash
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ kenv.h \
+ sys/mount.h \
+ sys/kd.h \
+ sys/rfork.h
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_headers += \
+ bits/mcontext.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),csu)
+# For <errno.h>.
+sysdep_routines += errno-loc
+endif
+
+ifeq ($(subdir),assert)
+CFLAGS-assert.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+CFLAGS-assert-perr.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+endif
+
+ifeq ($(subdir),io)
+# For <unistd.h>.
+sysdep_routines += sys_access sys_faccessat sys_fchownat sys_fexecve sys_getcwd sys_linkat sys_lseek sys_freebsd6_lseek sys_readlinkat sys_symlinkat sys_unlinkat
+# For <fcntl.h>.
+sysdep_routines += sys_open sys_openat open_2
+# For <sys/stat.h>.
+sysdep_routines += sys_fchmodat sys_fstat sys_fstatat sys_lstat sys_mkdirat sys_mkfifoat sys_mknod sys_mknodat sys_nfstat sys_nlstat sys_nstat sys_stat lchflags
+# For <sys/statfs.h>.
+sysdep_routines += fstatfs64 statfs64 sys_fstatfs sys_statfs
+# For <stdio.h>
+sysdep_routines += sys_renameat
+# For <sys/times.h>.
+sysdep_routines += sys_futimesat
+# Other.
+sysdep_routines += lchmod
+endif
+
+ifeq ($(subdir),dirent)
+# For <dirent.h>.
+sysdep_routines += sys_getdents sys_getdirentries getdirentries getdirentries64
+endif
+
+ifeq ($(subdir),misc)
+# For <kenv.h>.
+sysdep_routines += kenv
+# For <sched.h>.
+sysdep_routines += clone start_thread
+# For <unistd.h>.
+sysdep_routines += sys_ftruncate sys_freebsd6_ftruncate sys_truncate sys_freebsd6_truncate getosreldate
+# For <sys/acl.h>.
+sysdep_routines += acl_aclcheck_fd acl_aclcheck_file acl_delete_fd acl_delete_file acl_get_fd acl_get_file acl_set_fd acl_set_file
+# For <sys/extattr.h>.
+sysdep_routines += extattrctl extattr_delete_file extattr_get_file extattr_set_file
+# For <sys/jail.h>.
+sysdep_routines += jail jail_attach jail_remove jail_get jail_set
+# For <sys/ktrace.h>.
+sysdep_routines += ktrace utrace
+# For <sys/linker.h>.
+sysdep_routines += kldfind kldfirstmod kldload kldnext kldstat kldsym kldunload kldunloadf
+# For <sys/mman.h>.
+sysdep_routines += minherit sys_mmap sys_freebsd6_mmap sys_munmap
+# For <sys/mount.h>.
+sysdep_routines += fhopen sys_fhstat sys_fhstatfs fhstat fhstat64 fhstatfs fhstatfs64 getfh getfsstat getfsstat64 sys_getfsstat getmntinfo getmntinfo64 mount nmount unmount
+# For <sys/rfork.h>.
+sysdep_routines += rfork
+# For <sys/rtprio.h>.
+sysdep_routines += rtprio
+# For <sys/socket.h>.
+sysdep_routines += bsd_sendfile
+# For <sys/stat.h>.
+sysdep_routines += devname
+# For <sys/sysctl.h>.
+sysdep_routines += sysctl sysctlbyname sysctlnametomib
+# For <sys/uio.h>.
+sysdep_routines += sys_readv sys_writev
+# Other.
+sysdep_routines += swapon swapoff sys_aio_cancel sys_aio_error sys_aio_read sys_aio_return sys_aio_suspend sys_aio_waitcomplete sys_aio_write sys_lio_listio issetugid modfind modfnext modnext modstat obreak quotactl rfork sysarch undelete yield
+# for INLINE_SYSCALL
+sysdep_routines += sys_fork sys_execve sys_sigaction sys_close sys_fcntl
+sysdep_routines += sys_clock_getres sys_clock_gettime sys_clock_settime
+sysdep_routines += sys_ktimer_create sys_ktimer_gettime sys_ktimer_settime sys_ktimer_getoverrun sys_ktimer_delete
+sysdep_routines += sys_shm_open sys_shm_unlink sys_pselect sys_semctl
+endif
+
+ifeq ($(subdir),posix)
+# For <unistd.h>.
+sysdep_routines += sys_getlogin sys_pread sys_freebsd6_pread sys_pwrite sys_freebsd6_pwrite sys_setlogin sys_read sys_write
+# for <sched.h>
+sysdep_routines += sys_cpuset_getaffinity sys_cpuset_setaffinity
+endif
+
+ifeq ($(subdir),inet)
+sysdep_headers += net/ethernet.h net/if_ether.h
+endif
+
+ifeq ($(subdir),time)
+# For <sys/timex.h>.
+sysdep_routines += ntp_adjtime ntp_gettime
+endif
+
+ifeq ($(subdir),socket)
+sysdep_routines += sa_len sys_bind sys_connect sys_sendto
+endif
+
+# Linuxthreads dependencies.
+
+ifeq ($(subdir),posix)
+sysdep_headers += bits/initspin.h
+endif
+
+# Don't compile the ctype glue code, since we have a much better <ctype.h>
+# than the old non-GNU C library.
+inhibit-glue = yes
+
+# Special ELF hacks.
+ifeq ($(subdir),elf)
+sysdep-rtld-routines += dl-brk dl-sbrk
+sysdep_routines += sys_umtx
+endif
+
+ifeq ($(subdir),sunrpc)
+sysdep_headers += nfs/nfs.h
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions
@@ -0,0 +1,121 @@
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/kFreeBSD configurations.
+
+  GLIBC_2.2.6 {
+    # c*
+    clone;
+
+    # e*
+    extattrctl; extattr_delete_file; extattr_get_file; extattr_set_file;
+
+    # f*
+    fhopen; fhstat; fhstatfs; futimes;
+
+    # g*
+    getdents; getfh; getfsstat; getfsstat64; getmntinfo; getmntinfo64;
+    getresgid; getresuid;
+
+    # i*
+    issetugid;
+
+    # j*
+    jail;
+
+    # k*
+    kldfind; kldfirstmod; kldload; kldnext; kldstat; kldsym; kldunload; kldunloadf;
+    ktrace;
+
+    # l*
+    lchmod; lutimes;
+
+    # m*
+    minherit; modfind; modfnext; modnext; modstat; mount;
+
+    # n*
+    nmount; ntp_adjtime; ntp_gettime;
+
+    # q*
+    quotactl;
+
+    # r*
+    rfork; rtprio;
+
+    # s*
+    sendfile; setresgid; setresuid; swapoff; swapon; sysarch; sysctl; sysctlbyname;
+
+    # u*
+    undelete; unmount; utrace;
+
+    # see <sys/acl.h>.
+    __acl_aclcheck_fd; __acl_aclcheck_file; __acl_delete_fd; __acl_delete_file;
+    __acl_get_fd; __acl_get_file; __acl_set_fd; __acl_set_file;
+
+    # see <errno.h>.
+    __errno_location;
+
+    # see <sys/sysctl.h>.
+    __sysctl;
+
+    # Questionable system calls. These functions may be removed at any moment.
+    __syscall_aio_cancel; __syscall_aio_error; __syscall_aio_read;
+    __syscall_aio_return; __syscall_aio_suspend; __syscall_aio_waitcomplete;
+    __syscall_aio_write; __syscall_lio_listio;
+    __syscall_obreak;
+    __syscall_yield;
+  }
+  GLIBC_2.3 {
+    #errlist-compat     87
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.3.4 {
+    # f*
+    fhstat64; fhstatfs64;
+    kqueue; kevent;
+
+    #errlist-compat     93
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # functions used in inline functions or macros
+    __libc_sa_len;
+  }
+  GLIBC_2.10 {
+    devname;
+    devname_r;
+    kenv;
+    sysctlnametomib;
+  }
+  GLIBC_2.11 {
+    lchflags;
+    #errlist-compat 94
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.13 {
+    jail_attach;
+    jail_remove;
+    jail_get;
+    jail_set;
+  }
+  GLIBC_PRIVATE {
+    # needed by libpthread.
+    __clone; __libc_fork; __libc_sigaction; __kernel_getosreldate;
+    # needed by libpthread as INLINE_SYSCALL:
+    __syscall_fork;
+    __syscall_open; __syscall_close;
+    __syscall_read; __syscall_write;
+    __syscall_wait4; __syscall_fcntl;
+    # needed by librt as INLINE_SYSCALL:
+    __syscall_clock_getres; __syscall_clock_gettime; __syscall_clock_settime;
+    __syscall_ktimer_create; __syscall_ktimer_gettime; __syscall_ktimer_settime; __syscall_ktimer_getoverrun; __syscall_ktimer_delete;
+    __syscall_shm_open; __syscall_shm_unlink;
+    # misc fixes for FreeBSD:
+    __syscall_freebsd6_lseek; __syscall_freebsd6_pread; __syscall_freebsd6_pwrite;
+    __syscall_lseek; __syscall_pread; __syscall_pwrite;
+    __syscall_connect; __syscall_sendto;
+    __syscall_cpuset_getaffinity ; __syscall_cpuset_setaffinity;
+     # global variable used in brk()
+    _end;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/_G_config.h
@@ -0,0 +1,100 @@
+/* This file is needed by libio to define various configuration parameters.
+   These are always the same in the GNU C library.  */
+
+#ifndef _G_config_h
+#define _G_config_h 1
+
+/* Define types for libio in terms of the standard internal type names.  */
+
+#include <bits/types.h>
+#define __need_size_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wchar_t
+#endif
+#define __need_NULL
+#include <stddef.h>
+#define __need_mbstate_t
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# define __need_wint_t
+#endif
+#include <wchar.h>
+#define _G_size_t	size_t
+typedef struct
+{
+  __off_t __pos;
+  __mbstate_t __state;
+} _G_fpos_t;
+typedef struct
+{
+  __off64_t __pos;
+  __mbstate_t __state;
+} _G_fpos64_t;
+#define _G_ssize_t	__ssize_t
+#define _G_off_t	__off_t
+#define _G_off64_t	__off64_t
+#define	_G_pid_t	__pid_t
+#define	_G_uid_t	__uid_t
+#define _G_wchar_t	wchar_t
+#define _G_wint_t	wint_t
+#define _G_stat64	stat64
+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
+# include <gconv.h>
+typedef union
+{
+  struct __gconv_info __cd;
+  struct
+  {
+    struct __gconv_info __cd;
+    struct __gconv_step_data __data;
+  } __combined;
+} _G_iconv_t;
+#endif
+
+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
+
+#define _G_HAVE_BOOL 1
+
+
+/* These library features are always available in the GNU C library.  */
+#define _G_HAVE_ATEXIT 1
+#define _G_HAVE_SYS_CDEFS 1
+#define _G_HAVE_SYS_WAIT 1
+#define _G_NEED_STDARG_H 1
+#define _G_va_list __gnuc_va_list
+
+#define _G_HAVE_PRINTF_FP 1
+#define _G_HAVE_MMAP 1
+#define _G_HAVE_LONG_DOUBLE_IO 1
+#define _G_HAVE_IO_FILE_OPEN 1
+#define _G_HAVE_IO_GETLINE_INFO 1
+
+#define _G_IO_IO_FILE_VERSION 0x20001
+
+#define _G_OPEN64	__open64
+#define _G_LSEEK64	__lseek64
+#define _G_MMAP64	__mmap64
+#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)
+
+/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
+#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)
+
+#define _G_BUFSIZ 8192
+
+/* These are the vtbl details for ELF.  */
+#define _G_NAMES_HAVE_UNDERSCORE 0
+#define _G_VTABLE_LABEL_HAS_LENGTH 1
+#define _G_USING_THUNKS	1
+#define _G_VTABLE_LABEL_PREFIX "__vt_"
+#define _G_VTABLE_LABEL_PREFIX_ID __vt_
+
+
+#if defined __cplusplus || defined __STDC__
+# define _G_ARGS(ARGLIST) ARGLIST
+#else
+# define _G_ARGS(ARGLIST) ()
+#endif
+
+#endif	/* _G_config.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/a.out.h
@@ -0,0 +1,140 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#define __GNU_EXEC_MACROS__
+
+struct exec
+{
+  unsigned long a_info;	/* Use macros N_MAGIC, etc for access.  */
+  unsigned int a_text;	/* Length of text, in bytes.  */
+  unsigned int a_data;	/* Length of data, in bytes.  */
+  unsigned int a_bss;	/* Length of uninitialized data area for file, in bytes.  */
+  unsigned int a_syms;	/* Length of symbol table data in file, in bytes.  */
+  unsigned int a_entry;	/* Start address.  */
+  unsigned int a_trsize;/* Length of relocation info for text, in bytes.  */
+  unsigned int a_drsize;/* Length of relocation info for data, in bytes.  */
+};
+
+enum machine_type
+{
+  M_OLDSUN2 = 0,
+  M_68010 = 1,
+  M_68020 = 2,
+  M_SPARC = 3,
+  M_386 = 100,
+  M_MIPS1 = 151,
+  M_MIPS2 = 152
+};
+
+#define N_MAGIC(exec)	((exec).a_info & 0xffff)
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec)	(((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+  ((exec).a_info = ((magic) & 0xffff)					\
+   | (((int)(type) & 0xff) << 16)					\
+   | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+  ((exec).a_info = ((exec).a_info & 0xffff0000) | ((magic) & 0xffff))
+#define N_SET_MACHTYPE(exec, machtype) \
+  ((exec).a_info =							\
+   ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+#define N_SET_FLAGS(exec, flags) \
+  ((exec).a_info =							\
+   ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+/* This indicates a demand-paged executable with the header in the text. 
+   The first page is unmapped to help trap NULL pointer references.  */
+#define QMAGIC 0314
+/* Code indicating core file.  */
+#define CMAGIC 0421
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+#define N_BADMAG(x) \
+  (N_MAGIC(x) != OMAGIC	&& N_MAGIC(x) != NMAGIC				\
+   && N_MAGIC(x) != ZMAGIC && N_MAGIC(x) != QMAGIC)
+#define _N_HDROFF(x)	(1024 - sizeof (struct exec))
+#define N_TXTOFF(x) \
+  (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) :	\
+   (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))
+#define N_DATOFF(x)	(N_TXTOFF(x) + (x).a_text)
+#define N_TRELOFF(x)	(N_DATOFF(x) + (x).a_data)
+#define N_DRELOFF(x)	(N_TRELOFF(x) + N_TRSIZE(x))
+#define N_SYMOFF(x)	(N_DRELOFF(x) + N_DRSIZE(x))
+#define N_STROFF(x)	(N_SYMOFF(x) + N_SYMSIZE(x))
+
+/* Address of text segment in memory after it is loaded.  */
+#define N_TXTADDR(x)	(N_MAGIC(x) == QMAGIC ? 4096 : 0)
+
+/* Address of data segment in memory after it is loaded.  */
+#define SEGMENT_SIZE	1024
+
+#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#define N_DATADDR(x) \
+  (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x))				\
+   : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
+#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist
+{
+  union 
+  {
+  char *n_name;
+  union
+    {
+      char *n_name;
+      struct nlist *n_next;
+      long n_strx;
+    } n_un;
+  } __attribute__ ((__transparent_union__)); 
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#define N_UNDF	0
+#define N_ABS	2
+#define N_TEXT	4
+#define N_DATA	6
+#define N_BSS	8
+#define N_FN	15
+#define N_EXT	1
+#define N_TYPE	036
+#define N_STAB	0340
+#define N_INDR	0xa
+#define	N_SETA	0x14	/* Absolute set element symbol.  */
+#define	N_SETT	0x16	/* Text set element symbol.  */
+#define	N_SETD	0x18	/* Data set element symbol.  */
+#define	N_SETB	0x1A	/* Bss set element symbol.  */
+#define N_SETV	0x1C	/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  int r_address;
+  unsigned int r_symbolnum:24;
+  unsigned int r_pcrel:1;
+  unsigned int r_length:2;
+  unsigned int r_extern:1;
+  unsigned int r_pad:4;
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#endif /* __A_OUT_GNU_H__ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/access.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <sysdep.h>
+
+/*
+   The FreeBSD kernel do not test file access correctly when the 
+   process' real user ID is superuser. In particular, they always return
+   zero when testing execute permissions without regard to whether the 
+   file is executable.
+
+   While this behaviour conforms to POSIX.1-2008, it is explicitely 
+   discouraged. This wrapper implements the recommended behaviour.
+ */
+
+extern int __syscall_access (const char *path, int mode);
+libc_hidden_proto (__syscall_access)
+
+int
+__access (const char *path, int mode)
+{
+  struct stat64 stats;
+
+  if ((__getuid() != 0) || !(mode & X_OK))
+    return __syscall_access (path, mode);
+
+  /* Althought the super-user can read and write any file, 
+     the file-system might be i.e. read-only. Do the check. */
+     
+  if (__syscall_access (path, mode))
+    return -1;
+    
+  if (stat64 (path, &stats))
+    return -1;
+
+  /* The super-user can execute any file that anyone can execute. */
+  if (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))
+    return 0;
+
+  __set_errno (EACCES);
+  return -1;
+}
+
+weak_alias (__access, access)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bind.c
@@ -0,0 +1,60 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour. */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern int __syscall_bind (int fd, __CONST_SOCKADDR_ARG addr,
+			   socklen_t addrlen) __THROW;
+libc_hidden_proto (__syscall_bind)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if ((new_addrlen != 0) && (new_addrlen < addrlen))
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, addrlen);
+}
+
+weak_alias (__bind, bind)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h
@@ -0,0 +1,52 @@
+/* Directory entry structure `struct dirent'.  FreeBSD version.
+   Copyright (C) 1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+#endif
+
+#define d_fileno        d_ino   /* Backwards compatibility.  */
+
+#define _DIRENT_HAVE_D_RECLEN 1
+#define _DIRENT_HAVE_D_NAMLEN 1
+#define _DIRENT_HAVE_D_TYPE 1
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/elf.h
@@ -0,0 +1,37 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 1995-2003,2004,2005,2006,2007,2008,2009,2010
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_ELF_H
+#define _BITS_ELF_H
+
+__BEGIN_DECLS
+
+#define	AT_EXECPATH	15	/* Path to the executable. */
+#define	AT_CANARY	16	/* Canary for SSP. */
+#define	AT_CANARYLEN	17	/* Length of the canary. */
+#define	AT_OSRELDATE	18	/* OSRELDATE. */
+#define	AT_NCPUS	19	/* Number of CPUs. */
+#define	AT_PAGESIZES	20	/* Pagesizes. */
+#define	AT_PAGESIZESLEN	21	/* Number of pagesizes. */
+#define	AT_STACKPROT	23	/* Initial stack protection. */
+
+__END_DECLS
+
+#endif	/* elf.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/errno.h
@@ -0,0 +1,192 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)errno.h	8.5 (Berkeley) 1/21/94
+ * $FreeBSD$
+ */
+
+#ifdef _ERRNO_H
+
+# undef EDOM
+# undef EILSEQ
+# undef ERANGE
+
+#define	EPERM		1		/* Operation not permitted */
+#define	ENOENT		2		/* No such file or directory */
+#define	ESRCH		3		/* No such process */
+#define	EINTR		4		/* Interrupted system call */
+#define	EIO		5		/* Input/output error */
+#define	ENXIO		6		/* Device not configured */
+#define	E2BIG		7		/* Argument list too long */
+#define	ENOEXEC		8		/* Exec format error */
+#define	EBADF		9		/* Bad file descriptor */
+#define	ECHILD		10		/* No child processes */
+#define	EDEADLK		11		/* Resource deadlock avoided */
+					/* 11 was EAGAIN */
+#define	ENOMEM		12		/* Cannot allocate memory */
+#define	EACCES		13		/* Permission denied */
+#define	EFAULT		14		/* Bad address */
+#define	ENOTBLK		15		/* Block device required */
+#define	EBUSY		16		/* Device busy */
+#define	EEXIST		17		/* File exists */
+#define	EXDEV		18		/* Cross-device link */
+#define	ENODEV		19		/* Operation not supported by device */
+#define	ENOTDIR		20		/* Not a directory */
+#define	EISDIR		21		/* Is a directory */
+#define	EINVAL		22		/* Invalid argument */
+#define	ENFILE		23		/* Too many open files in system */
+#define	EMFILE		24		/* Too many open files */
+#define	ENOTTY		25		/* Inappropriate ioctl for device */
+#define	ETXTBSY		26		/* Text file busy */
+#define	EFBIG		27		/* File too large */
+#define	ENOSPC		28		/* No space left on device */
+#define	ESPIPE		29		/* Illegal seek */
+#define	EROFS		30		/* Read-only filesystem */
+#define	EMLINK		31		/* Too many links */
+#define	EPIPE		32		/* Broken pipe */
+
+/* math software */
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+
+/* non-blocking and interrupt i/o */
+#define	EAGAIN		35		/* Resource temporarily unavailable */
+#define	EWOULDBLOCK	EAGAIN		/* Operation would block */
+#define	EINPROGRESS	36		/* Operation now in progress */
+#define	EALREADY	37		/* Operation already in progress */
+
+/* ipc/network software -- argument errors */
+#define	ENOTSOCK	38		/* Socket operation on non-socket */
+#define	EDESTADDRREQ	39		/* Destination address required */
+#define	EMSGSIZE	40		/* Message too long */
+#define	EPROTOTYPE	41		/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	42		/* Protocol not available */
+#define	EPROTONOSUPPORT	43		/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	44		/* Socket type not supported */
+#define	EOPNOTSUPP	45		/* Operation not supported */
+#define	ENOTSUP		EOPNOTSUPP	/* Operation not supported */
+#define	EPFNOSUPPORT	46		/* Protocol family not supported */
+#define	EAFNOSUPPORT	47		/* Address family not supported by protocol family */
+#define	EADDRINUSE	48		/* Address already in use */
+#define	EADDRNOTAVAIL	49		/* Can't assign requested address */
+
+/* ipc/network software -- operational errors */
+#define	ENETDOWN	50		/* Network is down */
+#define	ENETUNREACH	51		/* Network is unreachable */
+#define	ENETRESET	52		/* Network dropped connection on reset */
+#define	ECONNABORTED	53		/* Software caused connection abort */
+#define	ECONNRESET	54		/* Connection reset by peer */
+#define	ENOBUFS		55		/* No buffer space available */
+#define	EISCONN		56		/* Socket is already connected */
+#define	ENOTCONN	57		/* Socket is not connected */
+#define	ESHUTDOWN	58		/* Can't send after socket shutdown */
+#define	ETOOMANYREFS	59		/* Too many references: can't splice */
+#define	ETIMEDOUT	60		/* Operation timed out */
+#define	ECONNREFUSED	61		/* Connection refused */
+
+#define	ELOOP		62		/* Too many levels of symbolic links */
+#define	ENAMETOOLONG	63		/* File name too long */
+
+/* should be rearranged */
+#define	EHOSTDOWN	64		/* Host is down */
+#define	EHOSTUNREACH	65		/* No route to host */
+#define	ENOTEMPTY	66		/* Directory not empty */
+
+/* quotas & mush */
+#define	EPROCLIM	67		/* Too many processes */
+#define	EUSERS		68		/* Too many users */
+#define	EDQUOT		69		/* Disc quota exceeded */
+
+/* Network File System */
+#define	ESTALE		70		/* Stale NFS file handle */
+#define	EREMOTE		71		/* Too many levels of remote in path */
+#define	EBADRPC		72		/* RPC struct is bad */
+#define	ERPCMISMATCH	73		/* RPC version wrong */
+#define	EPROGUNAVAIL	74		/* RPC prog. not avail */
+#define	EPROGMISMATCH	75		/* Program version wrong */
+#define	EPROCUNAVAIL	76		/* Bad procedure for program */
+
+#define	ENOLCK		77		/* No locks available */
+#define	ENOSYS		78		/* Function not implemented */
+
+#define	EFTYPE		79		/* Inappropriate file type or format */
+#define	EAUTH		80		/* Authentication error */
+#define	ENEEDAUTH	81		/* Need authenticator */
+#define	EIDRM		82		/* Identifier removed */
+#define	ENOMSG		83		/* No message of desired type */
+#define	EOVERFLOW	84		/* Value too large to be stored in data type */
+#define	ECANCELED	85		/* Operation canceled */
+#define	EILSEQ		86		/* Illegal byte sequence */
+#define	ENOATTR		87		/* Attribute not found */
+
+#define	EDOOFUS		88		/* Programming error */
+
+#define	EBADMSG		89		/* Bad message */
+#define	EMULTIHOP	90		/* Multihop attempted */
+#define	ENOLINK		91		/* Link has been severed */
+#define	EPROTO		92		/* Protocol error */
+
+#define	ENOTCAPABLE	93		/* Capabilities insufficient */
+
+#define	ELAST		93		/* Must be equal largest errno */
+
+#ifdef _KERNEL
+/* pseudo-errors returned inside kernel to modify return to process */
+#define	ERESTART	(-1)		/* restart syscall */
+#define	EJUSTRETURN	(-2)		/* don't modify regs, just return */
+#define	ENOIOCTL	(-3)		/* ioctl not handled by this layer */
+#define	EDIRIOCTL	(-4)		/* do direct ioctl in GEOM */
+#endif
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+#define	EILSEQ		86		/* Illegal byte sequence */
+
+#endif /* !_ERRNO_H && __need_Emath */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h
@@ -0,0 +1,186 @@
+/* O_*, F_*, FD_* bit values for FreeBSD.
+   Copyright (C) 1991-1992, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+#include <bits/wordsize.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		  01000	/* not fcntl */
+#define O_EXCL		  04000	/* not fcntl */
+#define O_NOCTTY	0100000	/* not fcntl */
+#define O_TRUNC		  02000	/* not fcntl */
+#define O_APPEND	    010
+#define O_NONBLOCK	     04
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		   0200
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		   0100
+
+#ifdef __USE_GNU
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+enum { O_DIRECTORY = 0 };	/* Must be a directory.	 */
+enum { O_NOATIME = 0};          /* Do not set atime.  */
+# define O_NOFOLLOW	   0400	/* Do not follow links.	 */
+#endif
+
+#ifdef __USE_BSD
+#define O_SHLOCK	    020 /* Open with shared file lock.  */
+#define O_EXLOCK	    040 /* Open with shared exclusive lock.  */
+#endif
+
+/* For now FreeBSD has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#if _POSIX_C_SOURCE >= 200809L
+#define O_TTY_INIT	0x00080000	/* Restore default termios attributes */
+/* Defining O_CLOEXEC would break kfreebsd 8.1, see #635192 */
+/* #define O_CLOEXEC	0x00100000 */
+#endif
+
+/* Since 'off_t' is 64-bit, O_LARGEFILE is a no-op.  */
+#define O_LARGEFILE	0
+
+#ifdef __USE_BSD
+/* Bits in the file status flags returned by F_GETFL.
+   These are all the O_* flags, plus FREAD and FWRITE, which are
+   independent bits set by which of O_RDONLY, O_WRONLY, and O_RDWR, was
+   given to `open'.  */
+#define FREAD		1
+#define	FWRITE		2
+#endif
+
+#ifdef __USE_ATFILE
+# define AT_FDCWD		-100	/* Special value used to indicate
+					   the *at functions should use the
+					   current working directory. */
+# define AT_EACCESS		0x100	/* Test access permitted for
+					   effective IDs, not real IDs.  */
+# define AT_SYMLINK_NOFOLLOW	0x200	/* Do not follow symbolic links.  */
+# define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic links.  */
+# define AT_REMOVEDIR		0x800	/* Remove directory instead of
+					   unlinking file.  */
+#endif
+
+/*
+ * We are out of bits in f_flag (which is a short).  However,
+ * the flag bits not set in FMASK are only meaningful in the
+ * initial open syscall.  Those bits can thus be given a
+ * different meaning for fcntl(2).
+ */
+#ifdef __USE_BSD
+/*
+ * Set by shm_open(3) to get automatic MAP_ASYNC behavior
+ * for POSIX shared memory objects (which are otherwise
+ * implemented as plain files).
+ */
+#define FPOSIXSHM	O_NOFOLLOW
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#define F_GETLK		7	/* Get record locking info.  */
+#define F_SETLK		8	/* Set record locking info (non-blocking).  */
+#define F_SETLKW	9	/* Set record locking info (blocking).	*/
+/* Not necessary, we always have 64-bit offsets.  */
+#define F_GETLK64	7	/* Get record locking info.  */
+#define F_SETLK64	8	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	9	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_UNIX98
+# define F_SETOWN	5	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	6	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		1	/* Read lock.  */
+#define F_WRLCK		3	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+struct flock
+  {
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    int	__l_sysid;	/* remote system id or zero for local */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    int	__l_sysid;	/* remote system id or zero for local */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+
+#define FCREAT		O_CREAT
+#define FEXCL		O_EXCL
+#define FTRUNC		O_TRUNC
+#define FNOCTTY		O_NOCTTY
+#define FSYNC		O_SYNC
+#endif /* Use BSD.  */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h
@@ -0,0 +1,308 @@
+/* Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* FreeBSD version.  */
+
+#ifndef _NETINET_IN_H
+# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
+#endif
+
+
+/* Link numbers.  */
+#define	IMPLINK_IP		155
+#define	IMPLINK_LOWEXPER	156
+#define	IMPLINK_HIGHEXPER	158
+
+#define IPPROTO_DIVERT          258             /* divert pseudo-protocol */
+
+/* To select the IP level.  */
+#define SOL_IP	0
+
+/*
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ */
+#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
+#define	IP_HDRINCL		2    /* int; header is included with data */
+#define	IP_TOS			3    /* int; IP type of service and preced. */
+#define	IP_TTL			4    /* int; IP time to live */
+#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
+#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
+#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
+#define	IP_SENDSRCADDR		IP_RECVDSTADDR /* cmsg_type to set src addr */
+#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
+#define	IP_MULTICAST_IF		9    /* struct in_addr *or* struct ip_mreqn;
+				      * set/get IP multicast i/f  */
+#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
+#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
+#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
+#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
+#define	IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
+#define	IP_RSVP_ON		15   /* enable RSVP in kernel */
+#define	IP_RSVP_OFF		16   /* disable RSVP in kernel */
+#define	IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
+#define	IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
+#define	IP_PORTRANGE		19   /* int; range to choose for unspec port */
+#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
+/* for IPSEC */
+#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
+#define	IP_FAITH		22   /* bool; accept FAITH'ed connections */
+
+#define	IP_ONESBCAST		23   /* bool: send all-ones broadcast */
+#define	IP_NONLOCALOK		24   /* bool: allow bind to spoof non-local addresses;
+					requires kernel compile option IP_NONLOCALBIND */
+
+#define	IP_FW_TABLE_ADD		40   /* add entry */
+#define	IP_FW_TABLE_DEL		41   /* delete entry */
+#define	IP_FW_TABLE_FLUSH	42   /* flush table */
+#define	IP_FW_TABLE_GETSIZE	43   /* get table size */
+#define	IP_FW_TABLE_LIST	44   /* list table contents */
+
+#define	IP_FW_ADD		50   /* add a firewall rule to chain */
+#define	IP_FW_DEL		51   /* delete a firewall rule from chain */
+#define	IP_FW_FLUSH		52   /* flush firewall rule chain */
+#define	IP_FW_ZERO		53   /* clear single/all firewall counter(s) */
+#define	IP_FW_GET		54   /* get entire firewall rule chain */
+#define	IP_FW_RESETLOG		55   /* reset logging counters */
+
+#define IP_FW_NAT_CFG           56   /* add/config a nat rule */
+#define IP_FW_NAT_DEL           57   /* delete a nat rule */
+#define IP_FW_NAT_GET_CONFIG    58   /* get configuration of a nat rule */
+#define IP_FW_NAT_GET_LOG       59   /* get log of a nat rule */
+
+#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
+#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
+#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
+#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */
+
+#define	IP_RECVTTL		65   /* bool; receive IP TTL w/dgram */
+#define	IP_MINTTL		66   /* minimum TTL for packet or drop */
+#define	IP_DONTFRAG		67   /* don't fragment packet */
+
+/* IPv4 Source Filter Multicast API [RFC3678] */
+#define	IP_ADD_SOURCE_MEMBERSHIP	70   /* join a source-specific group */
+#define	IP_DROP_SOURCE_MEMBERSHIP	71   /* drop a single source */
+#define	IP_BLOCK_SOURCE			72   /* block a source */
+#define	IP_UNBLOCK_SOURCE		73   /* unblock a source */
+
+/* The following option is private; do not use it from user applications. */
+#define	IP_MSFILTER			74   /* set/get filter list */
+
+/* Protocol Independent Multicast API [RFC3678] */
+#define	MCAST_JOIN_GROUP		80   /* join an any-source group */
+#define	MCAST_LEAVE_GROUP		81   /* leave all sources for group */
+#define	MCAST_JOIN_SOURCE_GROUP		82   /* join a source-specific group */
+#define	MCAST_LEAVE_SOURCE_GROUP	83   /* leave a single source */
+#define	MCAST_BLOCK_SOURCE		84   /* block a source */
+#define	MCAST_UNBLOCK_SOURCE		85   /* unblock a source */
+
+/*
+ * Defaults and limits for options
+ */
+#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
+#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
+
+/*
+ * The imo_membership vector for each socket is now dynamically allocated at
+ * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
+ * according to a power-of-two increment.
+ */
+#define	IP_MIN_MEMBERSHIPS	31
+#define	IP_MAX_MEMBERSHIPS	4095
+#define	IP_MAX_SOURCE_FILTER	1024	/* # of filters per socket, per group */
+
+/*
+ * Filter modes; also used to represent per-socket filter mode internally.
+ */
+ 
+#define MCAST_UNDEFINED 0       /* fmode: not yet defined */
+#define	MCAST_INCLUDE	1	/* fmode: include these source(s) */
+#define	MCAST_EXCLUDE	2	/* fmode: exclude these source(s) */
+
+/*
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IP_PORTRANGE_DEFAULT	0	/* default range */
+#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
+#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define	IPCTL_FORWARDING	1	/* act as router */
+#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
+#define	IPCTL_DEFTTL		3	/* default TTL */
+#ifdef notyet
+#define	IPCTL_DEFMTU		4	/* default MTU */
+#endif
+#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
+#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
+#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
+#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
+#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
+#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
+#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
+#define	IPCTL_STATS		12	/* ipstat structure */
+#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
+#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
+#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
+#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
+#define	IPCTL_MAXID		17
+
+/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
+   The `ip_dst' field is used for the first-hop gateway when using a
+   source route (this gets put into the header proper).  */
+struct ip_opts
+  {
+    struct in_addr ip_dst;	/* First hop; zero without source route.  */
+    char ip_opts[40];		/* Actually variable in size.  */
+  };
+
+/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
+#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
+#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f  */
+#define IPV6_MULTICAST_HOPS	10 /* int; set/get IP6 multicast hops */
+#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
+#define IPV6_JOIN_GROUP		12 /* ip6_mreq; join a group membership */
+#define IPV6_LEAVE_GROUP	13 /* ip6_mreq; leave a group membership */
+#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
+#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
+
+#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
+#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
+
+#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
+#define IPV6_FAITH		29 /* bool; accept FAITH'ed connections */
+
+#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
+#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
+#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
+#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
+#define IPV6_FW_GET		34 /* get entire firewall rule chain */
+#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */
+
+#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
+#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
+#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
+#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
+#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */
+
+#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
+#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */
+#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
+				      4 bytes int; MTU notification (cmsg) */
+
+#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
+#define IPV6_HOPLIMIT		47 /* int; send hop limit */
+#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
+#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
+#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
+#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */
+
+#define IPV6_RECVTCLASS		57 /* bool; recv traffic class values */
+
+#define IPV6_AUTOFLOWLABEL	59 /* bool; attach flowlabel automagically */
+
+#define IPV6_TCLASS		61 /* int; send traffic class value */
+#define IPV6_DONTFRAG		62 /* bool; disable IPv6 fragmentation */
+
+#define IPV6_PREFER_TEMPADDR	63 /* int; prefer temporary addresses as
+                                    * the source address.
+				    */
+
+/* Obsolete synonyms for the above.  */
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
+
+/* Socket level values for IPv6.  */
+#define SOL_IPV6	41
+#define SOL_ICMPV6	58
+
+/*
+ * Defaults and limits for options
+ */
+#define IPV6_DEFAULT_MULTICAST_HOPS 1   /* normally limit m'casts to 1 hop */
+#define IPV6_DEFAULT_MULTICAST_LOOP 1   /* normally hear sends if a member */
+
+/*
+ * Argument for IPV6_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define IPV6_PORTRANGE_DEFAULT  0       /* default range */
+#define IPV6_PORTRANGE_HIGH     1       /* "high" - request firewall bypass */
+#define IPV6_PORTRANGE_LOW      2       /* "low" - vouchsafe security */
+
+/* Routing header options for IPv6.  */
+#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
+#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
+
+#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define IPV6CTL_FORWARDING	1	/* act as router */
+#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
+#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
+#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
+#define IPV6CTL_STATS		6	/* stats */
+#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
+#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
+#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
+#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
+#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
+#define IPV6CTL_ACCEPT_RTADV	12
+#define IPV6CTL_KEEPFAITH	13
+#define IPV6CTL_LOG_INTERVAL	14
+#define IPV6CTL_HDRNESTLIMIT	15
+#define IPV6CTL_DAD_COUNT	16
+#define IPV6CTL_AUTO_FLOWLABEL	17
+#define IPV6CTL_DEFMCASTHLIM	18
+#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
+#define IPV6CTL_KAME_VERSION	20
+#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
+#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
+#define IPV6CTL_V6ONLY		24
+#define IPV6CTL_RTEXPIRE	25	/* cloned route expiration time */
+#define IPV6CTL_RTMINEXPIRE	26	/* min value for expiration time */
+#define IPV6CTL_RTMAXCACHE	27	/* trigger level for dynamic expire */
+
+#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
+#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
+#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
+#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
+#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
+#define IPV6CTL_PREFER_TEMPADDR	37	/* prefer temporary addr as src */
+#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
+#define IPV6CTL_USE_DEFAULTZONE	39	/* use default scope zone */
+
+#define IPV6CTL_MAXFRAGS	41	/* max fragments */
+#define IPV6CTL_MCAST_PMTU	44	/* enable pMTU discovery for multicast? */
+
+/* New entries should be added here from current IPV6CTL_MAXID value. */
+/* to define items, should talk with KAME guys first, for *BSD compatibility */
+/* 42-44 is already used in KAME */
+#define IPV6CTL_STEALTH		45
+#define	ICMPV6CTL_ND6_ONLINKNSRFC4861	47
+#define IPV6CTL_MAXID		48
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h
@@ -0,0 +1,37 @@
+/* Structure types for pre-termios terminal ioctls.  FreeBSD version.
+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Many systems that have TIOCGWINSZ define TIOCGSIZE for source
+   compatibility with Sun; they define `struct ttysize' to have identical
+   layout as `struct winsize' and #define TIOCGSIZE to be TIOCGWINSZ
+   (likewise TIOCSSIZE and TIOCSWINSZ).  */
+/* struct ttysize is in FreeBSD originally defined in <sys/ioctl.h>,
+   which is replaced by GLIBC version -> define here */
+struct ttysize
+{
+  unsigned short int ts_lines;
+  unsigned short int ts_cols;
+  unsigned short int ts_xxx;
+  unsigned short int ts_yyy;
+};
+#define	_IOT_ttysize	_IOT_winsize
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h
@@ -0,0 +1,50 @@
+/*-
+ * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#ifndef	_IOCTLS_H_
+#define	_IOCTLS_H_
+
+#include <sys/ioccom.h>
+
+#include <sys/ttycom.h>
+
+/*
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#define	TIOCGSIZE	TIOCGWINSZ
+#define	TIOCSSIZE	TIOCSWINSZ
+
+#include <sys/filio.h>
+
+#include <sys/sockio.h>
+
+#endif /* !_IOCTLS_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* create key if key does not exist */
+#define IPC_EXCL	02000		/* fail if key exists */
+#define IPC_NOWAIT	04000		/* return error on wait */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* remove identifier */
+#define IPC_SET		1		/* set `ipc_perm' options */
+#define IPC_STAT	2		/* get `ipc_perm' options */
+
+/* Special key values.  */
+#define IPC_PRIVATE	((key_t) 0)	/* private key */
+
+#ifdef __USE_BSD
+/* Common mode bits.  */
+# define IPC_R		0400		/* read permission, same as S_IRUSR */
+# define IPC_W		0200		/* write permission, same as S_IWUSR */
+# define IPC_M		0x1000		/* control permission */
+#endif
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __uint16_t /* yuck! */ cuid;	/* creator's user ID */
+    __uint16_t /* yuck! */ cgid;	/* creator's group ID */
+    __uint16_t /* yuck! */ uid;		/* owner's user ID */
+    __uint16_t /* yuck! */ gid;		/* owner's group ID */
+    __mode_t mode;			/* read/write permission */
+    __uint16_t __seq;
+    __key_t __key;
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h
@@ -0,0 +1,25 @@
+/* Minimum guaranteed maximum values for system limits.  kFreeBSD version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/param.h>
+
+/* BSD userland provides MAXHOSTNAMELEN via <sys/param.h>.  GNU
+   userland provides HOST_NAME_MAX via <limits.h>.  This makes
+   both worlds happy.  */
+#define HOST_NAME_MAX MAXHOSTNAMELEN
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h
@@ -0,0 +1,130 @@
+/* Definitions for POSIX memory map interface.  FreeBSD version.
+   Copyright (C) 1994-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+#include <features.h>
+#include <stddef.h>
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define	PROT_NONE	 0x00	/* No access.  */
+#define	PROT_READ	 0x01	/* Pages can be read.  */
+#define	PROT_WRITE	 0x02	/* Pages can be written.  */
+#define	PROT_EXEC	 0x04	/* Pages can be executed.  */
+
+/* Flags contain mapping type, sharing type and options.  */
+
+/* Mapping type (must choose one and only one of these).  */
+#ifdef __USE_BSD
+# define MAP_FILE	 0x0000	/* Mapped from a file or device.  */
+# define MAP_ANON	 0x1000	/* Allocated from anonymous virtual memory.  */
+# define MAP_TYPE	 0x1000	/* Mask for type field.  */
+# ifdef __USE_MISC
+#  define MAP_ANONYMOUS  MAP_ANON /* Linux name. */
+# endif
+#endif
+
+/* Sharing types (must choose one and only one of these).  */
+#define	MAP_SHARED	 0x0001	/* Share changes.  */
+#define	MAP_PRIVATE	 0x0002	/* Changes private; copy pages on write.  */
+#ifdef __USE_BSD
+# define MAP_COPY MAP_PRIVATE	/* Virtual copy of region at mapping time.  */
+#endif
+
+/* Other flags.  */
+#define	MAP_FIXED	 0x0010	/* Map address must be exactly as requested. */
+#ifdef __USE_BSD
+#define MAP_RENAME	 0x0020 /* Sun: rename private pages to file */
+#define MAP_NORESERVE	 0x0040 /* Sun: don't reserve needed swap area */
+#define MAP_RESERVED0080 0x0080	/* previously misimplemented MAP_INHERIT */
+#define MAP_RESERVED0100 0x0100	/* previously unimplemented MAP_NOEXTEND */
+# define MAP_HASSEMPHORE 0x0200	/* Region may contain semaphores.  */
+# define MAP_STACK	 0x0400	/* Region grows down, like a stack.  */
+# define MAP_NOSYNC	 0x0800	/* Try to avoid flushing to the disk.  */
+# define MAP_NOCORE	0x20000	/* Don't include these pages in a core dump.  */
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_FREE	 5	/* Don't need these pages, they contain junk. */
+# define MADV_NOSYNC	 6	/* Try to avoid flushing to the disk.  */
+# define MADV_AUTOSYNC	 7	/* Use the default flushing strategy.  */
+# define MADV_NOCORE	 8	/* Don't include these pages in a core dump.  */
+# define MADV_CORE	 9	/* Include pages in a core dump (default).  */
+# define MADV_PROTECT	10	/* protect process from pageout kill */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		0		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall' (can be OR'd together).  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for 'minherit'.  */
+#ifdef __USE_BSD
+# define INHERIT_SHARE	0
+# define INHERIT_COPY	1
+# define INHERIT_NONE	2
+#endif
+
+
+/*
+ * Return bits from mincore
+ */
+#ifdef __USE_MISC
+#define	MINCORE_INCORE	 	 0x1 /* Page is incore */
+#define	MINCORE_REFERENCED	 0x2 /* Page has been referenced by us */
+#define	MINCORE_MODIFIED	 0x4 /* Page has been modified by us */
+#define	MINCORE_REFERENCED_OTHER 0x8 /* Page has been referenced */
+#define	MINCORE_MODIFIED_OTHER	0x10 /* Page has been modified */
+#endif /* Use MISC */
+
+#ifdef __USE_BSD
+
+__BEGIN_DECLS
+
+extern int minherit (void *__addr, size_t __len, int __inherit);
+
+__END_DECLS
+
+#endif /* Use BSD */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h
@@ -0,0 +1,69 @@
+/* Copyright (C) 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+#error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct __msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  void *__msg_first;
+  void *__msg_last;
+  msglen_t __msg_cbytes;	/* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  __time_t msg_stime;		/* time of last msgsnd command */
+  long __unused1;
+  __time_t msg_rtime;		/* time of last msgrcv command */
+  long __unused2;
+  __time_t msg_ctime;		/* time of last change */
+  long __unused3;
+  long __unused4[4];
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgmax;
+    int msgmni;
+    int msgmnb;
+    int msgtql;
+    int msgssz;
+    int msgseg;
+  };
+
+#endif /* __USE_MISC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 1997, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x0001		/* There is data to read.  */
+#define POLLPRI		0x0002		/* There is urgent data to read.  */
+#define POLLOUT		0x0004		/* Writing now will not block.  */
+
+#ifdef __USE_XOPEN
+/* These values are defined in XPG4.2.  */
+# define POLLRDNORM	0x0040		/* Normal data may be read.  */
+# define POLLRDBAND	0x0080		/* Priority data may be read.  */
+# define POLLWRNORM	POLLOUT		/* Writing now will not block.  */
+# define POLLWRBAND	0x0100		/* Priority data may be written.  */
+#endif
+
+#ifdef __USE_BSD
+/* General FreeBSD extension (currently only supported for sockets): */
+# define POLLINIGNEOF	0x2000		/* like POLLIN, except ignore EOF */
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR		0x0008		/* Error condition.  */
+#define POLLHUP		0x0010		/* Hung up.  */
+#define POLLNVAL	0x0020		/* Invalid polling request.  */
+
+#ifdef __USE_BSD
+
+# define POLLSTANDARD	(POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\
+			POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)
+
+/*
+ * Request that poll() wait forever.
+ * XXX in SYSV, this is defined in stropts.h, which is not included
+ * by poll.h.
+ */
+#define INFTIM		(-1)
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h
@@ -0,0 +1,90 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	1
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	1
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	1
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	1
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	1
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	1
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* X/Open realtime support is available.  */
+#define _XOPEN_REALTIME	1
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* The LFS interface is available, except for the asynchronous I/O.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX timers are available.  */
+#define _POSIX_TIMERS 1
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200912L
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h
@@ -0,0 +1,211 @@
+/* Bit values & structures for resource limits.  FreeBSD version.
+   Copyright (C) 1994, 1996-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <sys/_types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.
+
+   These are the values for FreeBSD.  Earlier BSD systems have a subset of
+   these kinds of resource limit.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define	RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 6,
+#define	RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 7,
+#define	RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 8,
+#define	RLIMIT_NOFILE RLIMIT_NOFILE
+
+  /* Maximum size of all socket buffers.  */
+  __RLIMIT_SBSIZE = 9,
+#define RLIMIT_SBSIZE __RLIMIT_SBSIZE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 10,
+#define RLIMIT_AS RLIMIT_AS
+
+  __RLIMIT_NLIMITS = 11,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#define RLIM_INFINITY 0x7fffffffffffffffLL
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+
+/* Type for resource quantity measurement.  */
+typedef __rlim_t rlim_t;
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+struct orlimit {
+	__int32_t	rlim_cur;	/* current (soft) limit */
+	__int32_t	rlim_max;	/* maximum value for rlim_cur */
+};
+
+struct loadavg {
+	__fixpt_t	ldavg[3];
+	long		fscale;
+};
+
+#define	CP_USER		0
+#define	CP_NICE		1
+#define	CP_SYS		2
+#define	CP_INTR		3
+#define	CP_IDLE		4
+#define	CPUSTATES	5
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h
@@ -0,0 +1,183 @@
+/* Definitions of constants and data structure for POSIX 1003.1b-1993
+   scheduling interface.
+   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __need_schedparam
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+
+/* Scheduling algorithms.  */
+#define SCHED_OTHER	2
+#define SCHED_FIFO	1
+#define SCHED_RR	3
+
+
+#ifdef __USE_MISC
+/* Cloning flags.  */
+# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
+# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
+# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
+# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
+# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
+# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				     wake it up on mm_release.  */
+# define CLONE_SYSVSEM 0x00040000 /* share system V SEM_UNDO semantics */
+#endif
+
+/* The official definition.  */
+struct sched_param
+  {
+    int __sched_priority;
+  };
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+/* Clone current process.  */
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+		  int __flags, void *__arg) __THROW;
+
+/* Unshare the specified resources.  */
+extern int unshare (int __flags) __THROW;
+
+/* Get index of currently used CPU.  */
+extern int sched_getcpu (void) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* need schedparam */
+
+#if !defined __defined_schedparam \
+    && (defined __need_schedparam || defined _SCHED_H)
+# define __defined_schedparam	1
+/* Data structure to describe a process' schedulability.  */
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# undef __need_schedparam
+#endif
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	128
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set_t'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do __builtin_memset (cpusetp, '\0', setsize); while (0)
+# else
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do {									      \
+    size_t __i;								      \
+    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+    __cpu_mask *__bits = (cpusetp)->__bits;				      \
+    for (__i = 0; __i < __imax; ++__i)					      \
+      __bits[__i] = 0;							      \
+  } while (0)
+# endif
+# define __CPU_SET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 |= __CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_CLR_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 &= ~__CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_ISSET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((((__const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]	      \
+	  & __CPUMASK (__cpu))) != 0					      \
+      : 0; }))
+
+# define __CPU_COUNT_S(setsize, cpusetp) \
+  __sched_cpucount (setsize, cpusetp)
+
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
+# else
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__extension__							      \
+   ({ __const __cpu_mask *__arr1 = (cpusetp1)->__bits;				      \
+      __const __cpu_mask *__arr2 = (cpusetp2)->__bits;				      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	if (__bits[__i] != __bits[__i])					      \
+	  break;							      \
+      __i == __imax; }))
+# endif
+
+# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
+  (__extension__							      \
+   ({ cpu_set_t *__dest = (destset);					      \
+      __const __cpu_mask *__arr1 = (srcset1)->__bits;				      \
+      __const __cpu_mask *__arr2 = (srcset2)->__bits;				      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];    \
+      __dest; }))
+
+# define __CPU_ALLOC_SIZE(count) \
+  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
+# define __CPU_ALLOC(count) __sched_cpualloc (count)
+# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)
+
+__BEGIN_DECLS
+
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+  __THROW;
+extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
+extern void __sched_cpufree (cpu_set_t *__set) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h
@@ -0,0 +1,95 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		4		/* get sempid */
+#define GETVAL		5		/* get semval */
+#define GETALL		6		/* get all semval's */
+#define GETNCNT		3		/* get semncnt */
+#define GETZCNT		7		/* get semzcnt */
+#define SETVAL		8		/* set semval */
+#define SETALL		9		/* set all semval's */
+
+#ifdef __USE_BSD
+# define SEM_R		IPC_R		/* read permission for user */
+# define SEM_A		IPC_W		/* alter permission for user */
+#endif
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds
+{
+  struct ipc_perm sem_perm;		/* operation permission struct */
+  void *__sem_base;
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+  __time_t sem_otime;			/* last semop() time */
+  long __unused1;
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  long __unused2;
+  long __unused3[4];
+};
+
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 10
+# define SEM_INFO 11
+
+/*
+ * semaphore info struct
+ */
+struct seminfo {
+        int     semmap,         /* # of entries in semaphore map */
+                semmni,         /* # of semaphore identifiers */
+                semmns,         /* # of semaphores in system */
+                semmnu,         /* # of undo structures in system */
+                semmsl,         /* max # of semaphores per id */
+                semopm,         /* max # of operations per semop call */
+                semume,         /* max # of undo entries per process */
+                semusz,         /* size in bytes of undo structure */
+                semvmx,         /* semaphore maximum value */
+                semaem;         /* adjust on exit max value */
+};
+
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h
@@ -0,0 +1,90 @@
+/* Copyright (C) 1995-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#ifdef __USE_BSD
+# define SHM_R		IPC_R		/* read permission for user */
+# define SHM_W		IPC_W		/* write permission for user */
+#endif
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef unsigned short int shmatt_t;
+
+/* Data structure describing a set of semaphores.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    int shm_segsz;			/* size of segment in bytes */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    __pid_t shm_cpid;			/* pid of creator */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    void *__shm_internal;
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT 	13
+# define SHM_INFO 	14
+
+struct shminfo
+  {
+        int     shmmax,         /* max shared memory segment size (bytes) */
+                shmmin,         /* min shared memory segment size (bytes) */
+                shmmni,         /* max number of shared memory identifiers */
+                shmseg,         /* max shared memory segments per process */
+                shmall;         /* max amount of shared memory (pages) */
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;	/* total allocated shm */
+    unsigned long int shm_rss;	/* total resident shm */
+    unsigned long int shm_swp;	/* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 1991-1992,1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* These definitions match those used by the FreeBSD kernel.  */
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Special flags.  */
+    int sa_flags;
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+  };
+
+/* Bits in `sa_flags'.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK	0x0001	/* Take signal on signal stack.  */
+# define SA_RESTART	0x0002	/* Restart syscall on signal return.  */
+# define SA_RESETHAND	0x0004	/* Reset to SIG_DFL on entry to handler.  */
+# define SA_NODEFER	0x0010	/* Don't automatically block the signal when
+				    its handler is being executed.  */
+# define SA_NOCLDWAIT	0x0020	/* Don't save zombie processes.  */
+# define SA_SIGINFO	0x0040	/* Provide additional info to the handler.  */
+#endif
+#define	SA_NOCLDSTOP	0x0008	/* Don't send SIGCHLD when children stop.  */
+
+#ifdef __USE_MISC
+# define SA_INTERRUPT	0	/* Historical no-op ("not SA_RESTART").  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK	1	/* Block signals.  */
+#define	SIG_UNBLOCK	2	/* Unblock signals.  */
+#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h
@@ -0,0 +1,235 @@
+/* siginfo_t, sigevent and constants.  FreeBSD version.
+   Copyright (C) 1997-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t 1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+    int si_pid;			/* Sending process ID.  */
+    unsigned int si_uid;	/* Real user ID of sending process.  */
+    int si_status;		/* Exit value or signal.  */
+    void *si_addr;		/* Address of faulting instruction.  */
+    union sigval si_value;	/* Signal value.  */
+    long int si_band;		/* Band event for SIGPOLL.  */
+    int __si_spare[7];
+  } siginfo_t;
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCIO = 0x10004,		/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ = 0x10005,		/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER = 0x10003,		/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE = 0x10002,		/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER = 0x10001,		/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x10006,
+# define SI_KERNEL	SI_KERNEL
+  SI_LWP = 0x10007,		/* Sent by thr_kill.  */
+# define SI_LWP		SI_LWP
+  SI_UNDEFINED = 0
+# define SI_UNDEFINED	SI_UNDEFINED
+};
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTOVF = 1,		/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_INTDIV,			/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+/* XXX These are only used by the waitid() function, not by the kernel.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+#include <sys/_types.h>		/* __lwpid_t */
+
+/* Structure to transport application-defined values with signals.  */
+
+typedef struct sigevent
+  {
+    int sigev_notify;
+    int sigev_signo;
+    sigval_t sigev_value;
+    union
+    {
+      __lwpid_t threadid;
+      struct
+      {
+	void (*function) (sigval_t);	/* Function to start.  */
+	void *attributes;		/* Really pthread_attr_t.  */
+      } thread;
+    } un;
+  } sigevent_t;
+
+#define sigev_notify_kqueue	sigev_signo
+#define sigev_notify_function	un.thread.function
+#define sigev_notify_attributes	un.thread.attributes
+#define sigev_notify_thread_id	un.threadid
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 1,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE = 0,		/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  /* Not yet supported by the kernel.  */
+  SIGEV_THREAD = 2,		/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+  SIGEV_KEVENT = 3,
+# define SIGEV_KEVENT	SIGEV_KEVENT
+  SIGEV_THREAD_ID = 4,
+# define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h
@@ -0,0 +1,84 @@
+/* Signal number definitions.  FreeBSD version.
+   Copyright (C) 1991-1993, 1996, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* This file defines the fake signal functions and signal
+   number constants for 4.2 or 4.3 BSD-derived Unix system.  */
+
+/* Fake signal functions.  */
+#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
+#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
+#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
+
+#define	SIG_CATCH ((__sighandler_t) 2) /* FreeBSD specific ? */
+#define	SIG_HOLD  ((__sighandler_t) 3) /* Add signal to hold mask.  */
+
+/* Signals.  */
+#define	SIGHUP		1	/* Hangup (POSIX).  */
+#define	SIGINT		2	/* Interrupt (ANSI).  */
+#define	SIGQUIT		3	/* Quit (POSIX).  */
+#define	SIGILL		4	/* Illegal instruction (ANSI).  */
+#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
+#define	SIGTRAP		5	/* Trace trap (POSIX).  */
+#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
+#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
+#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
+#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
+#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
+#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD).  */
+#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define	SIGALRM		14	/* Alarm clock (POSIX).  */
+#define	SIGTERM		15	/* Termination (ANSI).  */
+#define	SIGURG		16	/* Urgent condition on socket (4.2 BSD).  */
+#define	SIGSTOP		17	/* Stop, unblockable (POSIX).  */
+#define	SIGTSTP		18	/* Keyboard stop (POSIX).  */
+#define	SIGCONT		19	/* Continue (POSIX).  */
+#define	SIGCHLD		20	/* Child status has changed (POSIX).  */
+#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
+#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
+#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
+#define	SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
+#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
+#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
+#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
+#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
+#define SIGINFO		29	/* Information request (4.4 BSD).  */
+#define	SIGUSR1		30	/* User-defined signal 1 (POSIX).  */
+#define	SIGUSR2		31	/* User-defined signal 2 (POSIX).  */
+/* Signals 32 and 33 are reserved for system libraries. */
+
+/* Signal 34 is used (but not reserved) by thread library.
+   See PTHREAD_SIGBASE in kernel-features.h.  */
+
+#define	_NSIG		129	/* Biggest signal number + 1
+				   (including real-time signals).  */
+
+#define SIGRTMIN	(__libc_current_sigrtmin ())
+#define SIGRTMAX	(__libc_current_sigrtmax ())
+
+/* These are the hard limits of the kernel.  These values should not be
+   used directly at user level.  */
+#define __SIGRTMIN	65	/* be in sync with FreeBSD kernel */
+#define __SIGRTMAX	126	/* be in sync with FreeBSD kernel */
+
+#endif	/* <signal.h> included.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h
@@ -0,0 +1,140 @@
+/* __sig_atomic_t, __sigset_t, and related definitions.  FreeBSD version.
+   Copyright (C) 1994-1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SIGSET_H_types
+# define _SIGSET_H_types	1
+
+typedef int __sig_atomic_t;
+
+/* A `sigset_t' has a bit for each signal.  */
+__extension__ typedef struct
+  {
+    __extension__ union
+      {
+        unsigned int __sigbits[4];
+        unsigned int __bits[4];
+      };
+  } __sigset_t;
+
+#endif
+
+
+/* We only want to define these functions if <signal.h> was actually
+   included; otherwise we were included just to define the types.  Since we
+   are namespace-clean, it wouldn't hurt to define extra macros.  But
+   trouble can be caused by functions being defined (e.g., any global
+   register vars declared later will cause compilation errors).  */
+
+#if !defined _SIGSET_H_fns && defined _SIGNAL_H
+# define _SIGSET_H_fns 1
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig)	((unsigned int) 1 << ((sig) - 1) % 32)
+
+/* Return the word index for SIG.  */
+# define __sigword(sig)	(((sig) - 1) >> 5)
+
+# if defined __GNUC__ && __GNUC__ >= 2
+#  define __sigemptyset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = 0; __set->__sigbits[1] = 0;	      \
+		    __set->__sigbits[2] = 0; __set->__sigbits[3] = 0;	      \
+		    0; }))
+#  define __sigfillset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = ~0; __set->__sigbits[1] = ~0;	      \
+		    __set->__sigbits[2] = ~0; __set->__sigbits[3] = ~0;	      \
+		    0; }))
+
+#  ifdef __USE_GNU
+/* The POSIX does not specify for handling the whole signal set in one
+   command.  This is often wanted and so we define three more functions
+   here.  */
+#   define __sigisemptyset(set) \
+  (__extension__ ({ const sigset_t *__set = (set);			      \
+		    __set->__sigbits[0] == 0				      \
+		    && __set->__sigbits[1] == 0				      \
+		    && __set->__sigbits[2] == 0				      \
+		    && __set->__sigbits[3] == 0; }))
+#   define __sigandset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] & __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] & __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] & __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] & __right->__sigbits[3];	      \
+		    0; }))
+#   define __sigorset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] | __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] | __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] | __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] | __right->__sigbits[3];	      \
+		    0; }))
+#  endif
+# endif
+
+/* These functions needn't check for a bogus signal number -- error
+   checking is done in the non __ versions.  */
+
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+
+# ifdef __USE_EXTERN_INLINES
+
+_EXTERN_INLINE int
+__sigismember (__const __sigset_t *__set, int __sig)
+{
+  return (__set->__sigbits[__sigword (__sig)] & __sigmask (__sig) ? 1 : 0);
+}
+
+_EXTERN_INLINE int
+__sigaddset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] |= __sigmask (__sig);
+  return 0;
+}
+
+_EXTERN_INLINE int
+__sigdelset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] &= ~__sigmask (__sig);
+  return 0;
+}
+
+# endif
+
+
+#endif /* ! _SIGSET_H_fns.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h
@@ -0,0 +1,397 @@
+/* System-specific socket constants and types.  FreeBSD version.
+   Copyright (C) 1991-1992,1994-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H	1
+
+#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>		/* XXX Is this allowed?  */
+#include <bits/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+};
+
+/*
+ * Structure used by kernel to pass protocol
+ * information in raw sockets.
+ */
+struct sockproto {
+	unsigned short	sp_family;		/* address family */
+	unsigned short	sp_protocol;		/* protocol */
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
+#define	PF_PUP		4	/* PUP protocols.  */
+#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
+#define	PF_NETBIOS	6	/* SMB protocols.  */
+#define	PF_ISO		7	/* ISO protocols.  */
+#define	PF_OSI		PF_ISO
+#define	PF_ECMA		8	/* ECMA protocols.  */
+#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
+#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
+#define	PF_SNA		11	/* IBM SNA protocol.  */
+#define	PF_DECnet	12	/* DECnet protocols.  */
+#define	PF_DLI		13	/* Direct data link interface.  */
+#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
+#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
+#define	PF_APPLETALK	16	/* Don't use this.  */
+#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
+#define	PF_LINK		18	/* Link layer interface.  */
+#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
+#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
+#define	PF_CNT		21	/* Computer Network Technology.  */
+#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
+#define	PF_IPX		23	/* Novell Internet Protocol.  */
+#define	PF_SIP		24	/* Simple Internet Protocol.  */
+#define PF_PIP		25	/* Help Identify PIP packets.  */
+#define PF_ISDN		26	/* Integrated Services Digital Network.  */
+#define PF_KEY		27	/* Internal key-management function.  */
+#define PF_INET6	28	/* IP version 6.  */
+#define PF_NATM		29	/* Native ATM access.  */
+#define PF_ATM		30	/* ATM.  */
+#define PF_HDRCMPLT	31	/* Used by BPF to not rewrite headers in
+				   interface output routine.  */
+#define PF_NETGRAPH	32	/* Netgraph sockets.  */
+#define	PF_MAX		33
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_IMPLINK	PF_IMPLINK
+#define	AF_PUP		PF_PUP
+#define	AF_CHAOS	PF_CHAOS
+#define	AF_NETBIOS	PF_NETBIOS
+#define	AF_ISO		PF_ISO
+#define	AF_OSI		PF_OSI
+#define	AF_ECMA		PF_ECMA
+#define	AF_DATAKIT	PF_DATAKIT
+#define	AF_CCITT	PF_CCITT
+#define	AF_SNA		PF_SNA
+#define	AF_DECnet	PF_DECnet
+#define	AF_DLI		PF_DLI
+#define	AF_LAT		PF_LAT
+#define	AF_HYLINK	PF_HYLINK
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_LINK		PF_LINK
+#define	pseudo_AF_XTP	PF_XTP
+#define	AF_COIP		PF_COIP
+#define	AF_CNT		PF_CNT
+#define pseudo_AF_RTIP	PF_RTIP
+#define	AF_IPX		PF_IPX
+#define	AF_SIP		PF_SIP
+#define pseudo_AF_PIP	PF_PIP
+#define AF_ISDN		PF_ISDN
+#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation.  */
+#define pseudo_AF_KEY	PF_KEY
+#define AF_INET6	PF_INET6
+#define AF_NATM		PF_NATM
+#define AF_ATM		PF_ATM
+#define pseudo_AF_HDRCMPLT PF_HDRCMPLT
+#define AF_NETGRAPH	PF_NETGRAPH
+#define	AF_MAX		PF_MAX
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128	/* 5 on the original 4.4 BSD.  */
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE MSG_DONTROUTE
+    MSG_EOR		= 0x08,	/* Data completes record.  */
+#define MSG_EOR MSG_EOR
+    MSG_TRUNC		= 0x10,	/* Data discarded before delivery.  */
+#define MSG_TRUNC MSG_TRUNC
+    MSG_CTRUNC		= 0x20,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC MSG_CTRUNC
+    MSG_WAITALL		= 0x40,	/* Wait for full request or error.  */
+#define MSG_WAITALL MSG_WAITALL
+    MSG_DONTWAIT	= 0x80,	/* This message should be nonblocking.  */
+#define MSG_DONTWAIT MSG_DONTWAIT
+    MSG_EOF		= 0x100, /* Data completes connection.  */
+#define MSG_EOF MSG_EOF
+    MSG_NOTIFICATION	= 0x2000,/* SCTP notification */
+#define MSG_NOTIFICATION MSG_NOTIFICATION
+    MSG_NBIO		= 0x4000,/*FIONBIO mode, used by fifofs */
+#define MSG_NBIO MSG_NBIO
+    MSG_COMPAT		= 0x8000,/* Used in sendit().  */
+#define MSG_COMPAT MSG_COMPAT
+    MSG_NOSIGNAL	= 0x20000 /* do not generate SIGPIPE on EOF */
+#define MSG_NOSIGNAL MSG_NOSIGNAL
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags in received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data  __flexarr __attribute__ ((aligned (__alignof__(size_t)))); /* Ancillary data.  */
+#endif
+  };
+
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			   & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof (struct cmsghdr)))
+#endif
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  */
+enum
+  {
+    SCM_RIGHTS = 0x01,		/* Access rights (array of int).  */
+#define SCM_RIGHTS SCM_RIGHTS
+    SCM_TIMESTAMP = 0x02,	/* Timestamp (struct timeval).  */
+#define SCM_TIMESTAMP SCM_TIMESTAMP
+    SCM_CREDS = 0x03		/* Process creds (struct cmsgcred).  */
+#define SCM_CREDS SCM_CREDS
+  };
+
+/* Unfortunately, BSD practice dictates this structure be of fixed size.
+   If there are more than CMGROUP_MAX groups, the list is truncated.
+   (On GNU systems, the `cmcred_euid' field is just the first in the
+   list of effective UIDs.)  */
+#define CMGROUP_MAX	16
+
+/* Structure delivered by SCM_CREDS.  This describes the identity of the
+   sender of the data simultaneously received on the socket.  By BSD
+   convention, this is included only when a sender on a AF_LOCAL socket
+   sends cmsg data of this type and size; the sender's structure is
+   ignored, and the system fills in the various IDs of the sender process.  */
+struct cmsgcred
+  {
+    __pid_t cmcred_pid;
+    __uid_t cmcred_uid;
+    __uid_t cmcred_euid;
+    __gid_t cmcred_gid;
+    short cmcred_ngroups;
+    __gid_t cmcred_groups[CMGROUP_MAX];
+  };
+
+/* Protocol number used to manipulate socket-level options
+   with `getsockopt' and `setsockopt'.  */
+#define	SOL_SOCKET	0xffff
+
+/* Socket-level options for `getsockopt' and `setsockopt'.  */
+enum
+  {
+    SO_DEBUG = 0x0001,		/* Record debugging information.  */
+#define SO_DEBUG SO_DEBUG
+    SO_ACCEPTCONN = 0x0002,	/* Accept connections on socket.  */
+#define SO_ACCEPTCONN SO_ACCEPTCONN
+    SO_REUSEADDR = 0x0004,	/* Allow reuse of local addresses.  */
+#define SO_REUSEADDR SO_REUSEADDR
+    SO_KEEPALIVE = 0x0008,	/* Keep connections alive and send
+				   SIGPIPE when they die.  */
+#define SO_KEEPALIVE SO_KEEPALIVE
+    SO_DONTROUTE = 0x0010,	/* Don't do local routing.  */
+#define SO_DONTROUTE SO_DONTROUTE
+    SO_BROADCAST = 0x0020,	/* Allow transmission of
+				   broadcast messages.  */
+#define SO_BROADCAST SO_BROADCAST
+    SO_USELOOPBACK = 0x0040,	/* Use the software loopback to avoid
+				   hardware use when possible.  */
+#define SO_USELOOPBACK SO_USELOOPBACK
+    SO_LINGER = 0x0080,		/* Block on close of a reliable
+				   socket to transmit pending data.  */
+#define SO_LINGER SO_LINGER
+    SO_OOBINLINE = 0x0100,	/* Receive out-of-band data in-band.  */
+#define SO_OOBINLINE SO_OOBINLINE
+    SO_REUSEPORT = 0x0200,	/* Allow local address and port reuse.  */
+#define SO_REUSEPORT SO_REUSEPORT
+    SO_TIMESTAMP = 0x0400,	/* Timestamp received dgram traffic.  */
+#define SO_TIMESTAMP SO_TIMESTAMP
+    SO_SNDBUF = 0x1001,		/* Send buffer size.  */
+#define SO_SNDBUF SO_SNDBUF
+    SO_RCVBUF = 0x1002,		/* Receive buffer.  */
+#define SO_RCVBUF SO_RCVBUF
+    SO_SNDLOWAT = 0x1003,	/* Send low-water mark.  */
+#define SO_SNDLOWAT SO_SNDLOWAT
+    SO_RCVLOWAT = 0x1004,	/* Receive low-water mark.  */
+#define SO_RCVLOWAT SO_RCVLOWAT
+    SO_SNDTIMEO = 0x1005,	/* Send timeout.  */
+#define SO_SNDTIMEO SO_SNDTIMEO
+    SO_RCVTIMEO = 0x1006,	/* Receive timeout.  */
+#define SO_RCVTIMEO SO_RCVTIMEO
+    SO_ERROR = 0x1007,		/* Get and clear error status.  */
+#define SO_ERROR SO_ERROR
+    SO_STYLE = 0x1008,		/* Get socket connection style.  */
+#define SO_STYLE SO_STYLE
+    SO_TYPE = SO_STYLE		/* Compatible name for SO_STYLE.  */
+#define SO_TYPE SO_TYPE
+  };
+
+/* Socket options. */
+#define LOCAL_PEERCRED          0x001   /* retrieve peer credentials */
+#define LOCAL_CREDS             0x002   /* pass credentials to receiver */
+#define LOCAL_CONNWAIT          0x004   /* connects block until accepted */
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+
+#ifdef __USE_BSD
+
+struct sf_hdtr;
+
+__BEGIN_DECLS
+
+extern int bsd_sendfile (int __in_fd, int __out_sock,
+			 __off_t __in_offset, size_t __nbytes,
+			 struct sf_hdtr *__hdtr, __off_t *__sockbytes,
+			 int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* Use BSD */
+
+#endif	/* bits/socket.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h
@@ -0,0 +1,219 @@
+/* Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H   1
+
+/* This structure needs to be defined in accordance with the
+   implementation of __stat, __fstat, and __lstat.  */
+
+#include <bits/types.h>
+
+/* Versions of the 'struct stat' data structure.  */
+#define _STAT_VER_ostat	0	/* 'struct ostat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_stat	1	/* 'struct stat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_nstat	2	/* 'struct nstat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_gstat 3	/* glibc's 'struct stat' without LFS */
+/* By default we use _STAT_VER_gstat, but we support also _STAT_VER_stat */
+#define _STAT_VER	_STAT_VER_gstat
+
+/* Structure describing file characteristics.  */
+struct stat
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.  */
+#else
+    __ino64_t st_ino;		/* File serial number.	*/
+#endif
+
+    __mode_t st_mode;		/* File mode.  */
+    __mode_t __pad_mode;	/* __mode_t is 16 bit, fill to 32 bit to retain previous ABI */
+    __nlink_t st_nlink;		/* Link count.  */
+    __nlink_t __pad_nlink;	/* __nlink_t is 16 bit, fill to 32 bit to retain previous ABI */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#define _STATBUF_ST_BLKSIZE	/* Tell code we have this member.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino64_t st_ino;		/* File serial number.	*/
+
+    __mode_t st_mode;		/* File mode.  */
+    __mode_t __pad_mode;	/* __mode_t is 16 bit, fill to 32 bit to retain previous ABI */
+    __nlink_t st_nlink;		/* Link count.  */
+    __nlink_t __pad_nlink;	/* __nlink_t is 16 bit, fill to 32 bit to retain previous ABI */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+#endif
+
+/* Encoding of the file mode.  These are the standard Unix values,
+   but POSIX.1 does not specify what values should be used.  */
+
+#define __S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define __S_IFDIR	0040000	/* Directory.  */
+#define __S_IFCHR	0020000	/* Character device.  */
+#define __S_IFBLK	0060000	/* Block device.  */
+#define __S_IFREG	0100000	/* Regular file.  */
+#define __S_IFLNK	0120000	/* Symbolic link.  */
+#define __S_IFSOCK	0140000	/* Socket.  */
+#define __S_IFWHT	0160000	/* Whiteout.  */
+#define __S_IFIFO	0010000	/* FIFO.  */
+
+/* POSIX.1b objects.  */
+#define __S_TYPEISMQ(buf) 0
+#define __S_TYPEISSEM(buf) 0
+#define __S_TYPEISSHM(buf) 0
+
+/* Protection bits.  */
+
+#define __S_ISUID	04000	/* Set user ID on execution.  */
+#define __S_ISGID	02000	/* Set group ID on execution.  */
+#define __S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define __S_IREAD	0400	/* Read by owner.  */
+#define __S_IWRITE	0200	/* Write by owner.  */
+#define __S_IEXEC	0100	/* Execute by owner.  */
+
+#ifdef __USE_BSD
+
+/* Definitions of flags stored in file flags word.  */
+
+/* Super-user and owner changeable flags.  */
+# define UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
+# define UF_NODUMP	0x00000001	/* do not dump file */
+# define UF_IMMUTABLE	0x00000002	/* file may not be changed */
+# define UF_APPEND	0x00000004	/* writes to file may only append */
+# define UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
+# define UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
+
+/* Super-user changeable flags.  */
+# define SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
+# define SF_ARCHIVED	0x00010000	/* file is archived */
+# define SF_IMMUTABLE	0x00020000	/* file may not be changed */
+# define SF_APPEND	0x00040000	/* writes to file may only append */
+# define SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
+# define SF_SNAPSHOT	0x00200000	/* snapshot inode */
+
+__BEGIN_DECLS
+
+/* Set file flags for FILE to FLAGS.  */
+extern int chflags (__const char *__file, unsigned long int __flags) __THROW;
+
+/* Set file flags of the file referred to by FD to FLAGS.  */
+extern int fchflags (int __fd, unsigned long int __flags) __THROW;
+
+/* Set file flags for FILE to FLAGS without following symlinks.  */
+extern int lchflags(__const char *__file, int __flags);
+
+/* Get device name in /dev with a device number of dev and a file type
+   matching the one encoded in type.  */
+extern char *devname(__dev_t dev, __mode_t type) __THROW;
+
+/* Store at most BUFLEN characters of the device name in /dev with a 
+   device number of dev and a file type matching the one encoded in type.  */
+extern char *devname_r(__dev_t dev, __mode_t type, char *buf, int buflen) __THROW;
+
+__END_DECLS
+
+#endif /* __USE_BSD */
+
+#endif /* bits/stat.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 2002, 2006, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This structure corresponds to the standard FreeBSD 'struct stat'
+   (i.e. _STAT_VER_stat), and is used by the stat() system call family. */
+
+struct stat16
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino_t st_ino;		/* File serial number.  */
+
+    __uint16_t st_mode;		/* File mode.  */
+    __uint16_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+    struct  timespec st_atimespec;  /* time of last access */
+    struct  timespec st_mtimespec;  /* time of last data modification */
+    struct  timespec st_ctimespec;  /* time of last file status change */
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __uint32_t __unused1;
+
+    __time_t st_birthtime;	/* Time of file creation.  */
+    long int st_birthtimensec;	/* Nanoseconds of file creation.  */
+
+#define _BIRTH_PADSIZE     (16 - sizeof(__time_t) - sizeof (long int))
+    char __birth_padding[_BIRTH_PADSIZE];
+  };
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h
@@ -0,0 +1,91 @@
+/* Definition of `struct statfs', information about a filesystem.
+   Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_STATFS_H
+#define _BITS_STATFS_H	1
+
+#if !defined _SYS_STATFS_H && !defined _SYS_MOUNT_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+struct statfs
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+#endif
+
+#endif /* _BITS_STATFS_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h
@@ -0,0 +1,97 @@
+/* Definition of `struct statvfs', information about a filesystem.
+   Copyright (C) 1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+#if __WORDSIZE == 32
+#define _STATVFSBUF_F_UNUSED
+#endif
+
+struct statvfs
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+    __fsfilcnt_t f_favail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.  */
+enum
+{
+  ST_RDONLY = 1,		/* Mount read-only.  */
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NODEV = 4,			/* Disallow access to device special files.  */
+# define ST_NODEV	ST_NODEV
+  ST_NOEXEC = 8,		/* Disallow program execution.  */
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+  ST_NOATIME = 0x10000000	/* Do not update access times.  */
+# define ST_NOATIME	ST_NOATIME
+#endif	/* Use GNU.  */
+};
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sys_errlist.h
@@ -0,0 +1,33 @@
+/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead."
+#endif
+
+/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */
+
+#ifdef  __USE_BSD
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+#endif
+#ifdef  __USE_GNU
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/syslog-path.h
@@ -0,0 +1,31 @@
+/* <bits/syslog-path.h> -- _PATH_LOG definition
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include this file directly.  Use <sys/syslog.h> instead"
+#endif
+
+#ifndef _BITS_SYSLOG_PATH_H
+#define _BITS_SYSLOG_PATH_H 1
+
+/* On kFreeBSD, named pipes are not allowed in /dev (devfs), so we pick this
+   alternate path. */
+#define _PATH_LOG	"/var/run/log"
+
+#endif /* bits/syslog-path.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h
@@ -0,0 +1,253 @@
+/* termios type and macro definitions.  FreeBSD version.
+   Copyright (C) 1993-1994,1996-1997,1999,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+/* These macros are also defined in some <bits/ioctls.h> files (with
+   numerically identical values), but this serves to shut up cpp's
+   complaining. */
+#ifdef __USE_BSD
+
+# ifdef MDMBUF
+#  undef MDMBUF
+# endif
+# ifdef FLUSHO
+#  undef FLUSHO
+# endif
+# ifdef PENDIN
+#  undef PENDIN
+# endif
+
+#endif /* __USE_BSD */
+
+#ifdef ECHO
+# undef ECHO
+#endif
+#ifdef TOSTOP
+# undef TOSTOP
+#endif
+#ifdef NOFLSH
+# undef NOFLSH
+#endif
+
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 20
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[NCCS];		/* control characters */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */
+#define __ispeed c_ispeed
+#define __ospeed c_ospeed
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
+  };
+
+/* c_cc characters */
+#define VEOF 0
+#define VEOL 1
+#define VEOL2 2
+#define VERASE 3
+#define VWERASE 4
+#define VKILL 5
+#define VREPRINT 6
+#ifdef __USE_BSD
+# define VERASE2 7
+#endif
+#define VINTR 8
+#define VQUIT 9
+#define VSUSP 10
+#ifdef __USE_BSD
+# define VDSUSP 11
+#endif
+#define VSTART 12
+#define VSTOP 13
+#define VLNEXT 14
+#define VDISCARD 15
+#define VMIN 16
+#define VTIME 17
+#ifdef __USE_BSD
+# define VSTATUS 18
+#endif
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IXON	0001000
+#define IXOFF	0002000
+#define IXANY	0004000
+#define IMAXBEL	0020000
+
+/* c_oflag bits */
+#define	OPOST	(1 << 0)	/* Perform output processing.  */
+#define	ONLCR	(1 << 1)	/* Map NL to CR-NL on output.  */
+#if defined __USE_MISC || defined __USE_XOPEN
+# define TAB0   (0 << 2)	/* no tab delay and expansion */
+# define TAB3   (1 << 2)	/* expand tabs to spaces */
+# define TABDLY	TAB3		/* tab delay mask */
+# define OXTABS	TAB3
+# define XTABS	TAB3
+#endif
+#ifdef	__USE_BSD
+# define ONOEOT	(1 << 3)	/* Discard EOT (^D) on output.  */
+#endif
+#define	OCRNL	(1 << 4)	/* map CR to NL on output */
+#define	ONOCR	(1 << 5)	/* no CR output at column 0 */
+#define	ONLRET	(1 << 6)	/* NL performs CR function */
+
+/* c_cflag bit meaning */
+#ifdef	__USE_BSD
+# define CIGNORE	(1 << 0)	/* Ignore these control flags.  */
+#endif
+#define	CSIZE	(CS5|CS6|CS7|CS8)	/* Number of bits per byte (mask).  */
+#define	CS5	(0 << 8)	/* 5 bits per byte.  */
+#define	CS6	(1 << 8)	/* 6 bits per byte.  */
+#define	CS7	(2 << 8)	/* 7 bits per byte.  */
+#define	CS8	(3 << 8)	/* 8 bits per byte.  */
+#define	CSTOPB	(1 << 10)	/* Two stop bits instead of one.  */
+#define	CREAD	(1 << 11)	/* Enable receiver.  */
+#define	PARENB	(1 << 12)	/* Parity enable.  */
+#define	PARODD	(1 << 13)	/* Odd parity instead of even.  */
+#define	HUPCL	(1 << 14)	/* Hang up on last close.  */
+#define	CLOCAL	(1 << 15)	/* Ignore modem status lines.  */
+#ifdef	__USE_BSD
+# define CCTS_OFLOW	(1 << 16)	/* CTS flow control of output.  */
+# define CRTS_IFLOW	(1 << 17)	/* RTS flow control of input.  */
+# define CRTSCTS	(CCTS_OFLOW|CRTS_IFLOW)	/* CTS/RTS flow control.  */
+# define CDTR_IFLOW	(1 << 18)	/* DTR flow control of input.  */
+# define CDSR_OFLOW	(1 << 19)	/* DSR flow control of output.  */
+# define CCAR_OFLOW	(1 << 20)	/* DCD flow control of output.  */
+# define MDMBUF		(1 << 20)	/* Carrier flow control of output.  */
+#endif
+
+/* c_lflag bits */
+#ifdef	__USE_BSD
+# define ECHOKE	(1 << 0)	/* Visual erase for KILL.  */
+#endif
+#define	_ECHOE	(1 << 1)	/* Visual erase for ERASE.  */
+#define	ECHOE	_ECHOE
+#define	_ECHOK	(1 << 2)	/* Echo NL after KILL.  */
+#define	ECHOK	_ECHOK
+#define	_ECHO	(1 << 3)	/* Enable echo.  */
+#define	ECHO	_ECHO
+#define	_ECHONL	(1 << 4)	/* Echo NL even if ECHO is off.  */
+#define	ECHONL	_ECHONL
+#ifdef	__USE_BSD
+# define ECHOPRT	(1 << 5)	/* Hardcopy visual erase.  */
+# define ECHOCTL	(1 << 6)	/* Echo control characters as ^X.  */
+#endif
+#define	_ISIG	(1 << 7)	/* Enable signals.  */
+#define	ISIG	_ISIG
+#define	_ICANON	(1 << 8)	/* Do erase and kill processing.  */
+#define	ICANON	_ICANON
+#ifdef	__USE_BSD
+# define ALTWERASE (1 << 9)	/* Alternate WERASE algorithm.  */
+#endif
+#define	_IEXTEN	(1 << 10)	/* Enable DISCARD and LNEXT.  */
+#define	IEXTEN	_IEXTEN
+#define	_EXTPROC (1 << 11)	/* External processing.  */
+#define EXTPROC	_EXTPROC
+#define	_TOSTOP	(1 << 22)	/* Send SIGTTOU for background output.  */
+#define	TOSTOP	_TOSTOP
+#ifdef	__USE_BSD
+# define FLUSHO	(1 << 23)	/* Output being flushed (state).  */
+# define NOKERNINFO (1 << 25)	/* Disable VSTATUS.  */
+# define PENDIN	(1 << 29)	/* Retype pending input (state).  */
+#endif
+#define	_NOFLSH	(1 << 31)	/* Disable flush after interrupt.  */
+#define	NOFLSH	_NOFLSH
+
+  /* Input and output baud rates.  */
+#define	B0	0		/* Hang up.  */
+#define	B50	50		/* 50 baud.  */
+#define	B75	75		/* 75 baud.  */
+#define	B110	110		/* 110 baud.  */
+#define	B134	134		/* 134.5 baud.  */
+#define	B150	150		/* 150 baud.  */
+#define	B200	200		/* 200 baud.  */
+#define	B300	300		/* 300 baud.  */
+#define	B600	600		/* 600 baud.  */
+#define	B1200	1200		/* 1200 baud.  */
+#define	B1800	1800		/* 1800 baud.  */
+#define	B2400	2400		/* 2400 baud.  */
+#define	B4800	4800		/* 4800 baud.  */
+#define	B9600	9600		/* 9600 baud.  */
+#define	B19200	19200		/* 19200 baud.  */
+#define	B38400	38400		/* 38400 baud.  */
+#define B76800	76800
+#ifdef	__USE_MISC
+# define EXTA	19200
+# define EXTB	38400
+#endif
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define	B57600	57600
+#define	B115200	115200
+#define	B230400	230400
+#define	B460800	460800
+#define	B500000	500000
+#define	B576000	576000
+#define	B921600	921600
+#define	B1000000 1000000
+#define	B1152000 1152000
+#define	B1500000 1500000
+#define	B2000000 2000000
+#define	B2500000 2500000
+#define	B3000000 3000000
+#define	B3500000 3500000
+#define	B4000000 4000000
+#define	__MAX_BAUD B4000000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		1
+#define	TCOON		2
+#define	TCIOFF		3
+#define	TCION		4
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define	TCIOFLUSH	3
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#ifdef	__USE_BSD
+# define TCSASOFT	0x10	/* Flag: Don't alter hardware state.  */
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/time.h
@@ -0,0 +1,98 @@
+/* System-dependent timing definitions.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  1000000l
+
+#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   define CLK_TCK 128
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	2
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	3
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		4
+/* These are BSD specific clocks.  */
+#   ifdef __USE_BSD
+#    define CLOCK_VIRTUAL		1
+#    define CLOCK_PROF			2
+#    define CLOCK_UPTIME    5               /* FreeBSD-specific. */
+#    define CLOCK_UPTIME_PRECISE    7       /* FreeBSD-specific. */
+#    define CLOCK_UPTIME_FAST       8       /* FreeBSD-specific. */
+#    define CLOCK_REALTIME_PRECISE  9       /* FreeBSD-specific. */
+#    define CLOCK_REALTIME_FAST     10      /* FreeBSD-specific. */
+#    define CLOCK_MONOTONIC_PRECISE 11      /* FreeBSD-specific. */
+#    define CLOCK_MONOTONIC_FAST    12      /* FreeBSD-specific. */
+#    define CLOCK_SECOND    13              /* FreeBSD-specific. */
+#   endif
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_RELTIME	0   /* relative timer */
+#   define TIMER_ABSTIME	1   /* absolute timer */
+#  endif
+
+
+/* Getkerninfo clock information structure */
+struct clockinfo
+  {
+    int hz;		/* clock frequency */
+    int tick;		/* micro-seconds per hz tick */
+    int spare;
+    int stathz;		/* statistics clock frequency */
+    int profhz;		/* profiling clock frequency */
+  };
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h
@@ -0,0 +1,91 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003, 2010, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+
+#if defined(__arm__) || defined(__powerpc__)
+#define __CLOCK_T_TYPE		__U32_TYPE
+#elif defined(__i386__)
+/* clock_t is unsigned in FreeBSD/i386, but it's too late to fix that now... */
+#define __CLOCK_T_TYPE		__S32_TYPE
+#else
+#define __CLOCK_T_TYPE		__S32_TYPE
+#endif
+
+/*
+ * This one is a bit tricky.  It needs to match the size
+ * in the sys/${arch}/include/_types.h typedefs.
+ *
+ * However, for i386 and amd64 we started with __SLONGWORD_TYPE
+ * and we need to maintain ABI.  Even if size is the same, using
+ * a different type may affect C++ ABI (this distinction is
+ * necessary to implement function overload), so it must stay
+ * with __SLONGWORD_TYPE.
+ */
+#if defined(__i386__) || defined(__amd64__)
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#elif defined(__powerpc__) && !defined(__LP64__)
+#define __TIME_T_TYPE		__S32_TYPE
+#else
+#define __TIME_T_TYPE		__S64_TYPE
+#endif
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__SQUAD_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		union { int __val[2]; int val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UIO_H && !defined _FCNTL_H
+# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
+#endif
+
+#ifndef _BITS_UIO_H
+#define _BITS_UIO_H     1
+
+#include <sys/types.h>
+
+
+/* `struct iovec' -- Structure describing a section of memory.  */
+
+struct iovec
+{
+  /* Starting address.  */
+  __ptr_t iov_base;
+  /* Length in bytes.  */
+  size_t iov_len;
+};
+
+/* Maximum number of 'struct iovec's that can be passed to a readv() or
+   writev() system call.  For larger arrays of 'struct iovec', the libc
+   uses a single read() or write() call to guarantee atomicity.  */
+#define UIO_MAXIOV	1024
+
+#ifdef __USE_BSD
+enum    uio_rw { UIO_READ, UIO_WRITE };
+
+/* Segment flag values. */
+enum uio_seg {
+        UIO_USERSPACE,          /* from user data space */
+        UIO_SYSSPACE,           /* from system space */
+        UIO_NOCOPY              /* don't copy, already in object */
+};
+#endif
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h
@@ -0,0 +1,27 @@
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* Length of the entries in 'struct utsname' is 32.  */
+#define _UTSNAME_LENGTH 32
+
+/* But the version entry is longer.  */
+#define _UTSNAME_VERSION_LENGTH 256
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h
@@ -0,0 +1,37 @@
+/* Definitions of flag bits for `waitpid' et al.
+   Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Bits in the third argument to `waitpid'.  */
+#define	WNOHANG		1	/* Don't block waiting.  */
+#define	WUNTRACED	2	/* Report status of stopped children.  */
+
+/* Bits in the fourth argument to `waitid'.  */
+#define	WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
+#define	WCONTINUED	4	/* Report continued child.  */
+#define	WNOWAIT		8	/* Poll only. Don't delete the proc entry. */
+
+#define __WCLONE	0x80000000	/* Wait for cloned process.  */
+#ifdef __USE_BSD
+# define WLINUXCLONE	__WCLONE	/* FreeBSD name for __WCLONE.  */
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitstatus.h
@@ -0,0 +1,105 @@
+/* Definitions of status bits for `wait' et al.
+   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
+#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
+
+/* If WIFSIGNALED(STATUS), the terminating signal.  */
+#define	__WTERMSIG(status)	((status) & 0x7f)
+
+/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
+#define	__WSTOPSIG(status)	__WEXITSTATUS(status)
+
+/* Nonzero if STATUS indicates normal termination.  */
+#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)
+
+/* Nonzero if STATUS indicates termination by a signal.  */
+#define __WIFSIGNALED(status) \
+  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)
+
+/* Nonzero if STATUS indicates the child is stopped.  */
+#define	__WIFSTOPPED(status)	(((status) & 0x7f) == 0x7f)
+
+/* Nonzero if STATUS indicates the child continued after a stop.  We only
+   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
+#ifdef WCONTINUED
+# define __WIFCONTINUED(status)	((status) == __W_CONTINUED)
+#endif
+
+/* Nonzero if STATUS indicates the child dumped core.  */
+#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)
+
+/* Macros for constructing status values.  */
+#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
+#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
+
+/* Linux uses 0xffff, BSD uses SIGCONT */
+#define __W_CONTINUED		0x13
+#define	__WCOREFLAG		0x80
+
+
+#ifdef	__USE_BSD
+
+# include <endian.h>
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_termsig:7; /* Terminating signal.  */
+	unsigned int __w_coredump:1; /* Set if dumped core.  */
+	unsigned int __w_retcode:8; /* Return code if exited normally.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_retcode:8;
+	unsigned int __w_coredump:1;
+	unsigned int __w_termsig:7;
+# endif				/* Big endian.  */
+      } __wait_terminated;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+# endif				/* Big endian.  */
+      } __wait_stopped;
+  };
+
+# define w_termsig	__wait_terminated.__w_termsig
+# define w_coredump	__wait_terminated.__w_coredump
+# define w_retcode	__wait_terminated.__w_retcode
+# define w_stopsig	__wait_stopped.__w_stopsig
+# define w_stopval	__wait_stopped.__w_stopval
+
+#endif	/* Use BSD.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+extern int __syscall_obreak (void *addr);
+libc_hidden_proto (__syscall_obreak)
+
+extern void _end;
+
+/* sbrk.c expects this.  */
+void *__curbrk = &_end;
+
+/* Set the end of the process's data space to ADDR.
+   Return 0 if successful, -1 if not.  */
+int
+__brk (addr)
+     void *addr;
+{
+  if (addr < &_end)
+    return 0;
+
+  if (INLINE_SYSCALL (obreak, 1, addr) == -1)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  __curbrk = addr;
+  return 0;
+}
+weak_alias (__brk, brk)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_fds.c
@@ -0,0 +1 @@
+void __libc_check_standard_fds (void) {;}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_native.c
@@ -0,0 +1,42 @@
+/* Determine whether interfaces use native transport.  Dummy version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <sys/ioctl.h>
+
+#include <not-cancel.h>
+
+
+void
+__check_native (uint32_t a1_index, int *a1_native,
+		uint32_t a2_index, int *a2_native)
+{
+
+#warning __check_native() not yet implemented
+  return;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_pf.c
@@ -0,0 +1 @@
+#include <inet/check_pf.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_getres.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+int __syscall_clock_getres(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_getres)
+
+# define SYSDEP_GETRES \
+	case CLOCK_REALTIME:		\
+	case CLOCK_MONOTONIC:		\
+	case CLOCK_REALTIME_FAST:	\
+	case CLOCK_REALTIME_PRECISE:	\
+	case CLOCK_MONOTONIC_FAST:	\
+	case CLOCK_MONOTONIC_PRECISE:	\
+	case CLOCK_UPTIME:		\
+	case CLOCK_UPTIME_FAST:		\
+	case CLOCK_UPTIME_PRECISE:	\
+	case CLOCK_VIRTUAL:		\
+	case CLOCK_SECOND:		\
+    retval = INLINE_SYSCALL (clock_getres, 2, clock_id, res);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/posix/clock_getres.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_gettime.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+# define SYSDEP_GETTIME \
+	case CLOCK_REALTIME:		\
+	case CLOCK_MONOTONIC:		\
+	case CLOCK_REALTIME_FAST:	\
+	case CLOCK_REALTIME_PRECISE:	\
+	case CLOCK_MONOTONIC_FAST:	\
+	case CLOCK_MONOTONIC_PRECISE:	\
+	case CLOCK_UPTIME:		\
+	case CLOCK_UPTIME_FAST:		\
+	case CLOCK_UPTIME_PRECISE:	\
+	case CLOCK_VIRTUAL:		\
+	case CLOCK_SECOND:		\
+    retval = INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#include <sysdeps/unix/clock_gettime.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_settime.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_settime(clockid_t clock_id, const struct timespec *tp);
+libc_hidden_proto (__syscall_clock_settime)
+
+# define SYSDEP_SETTIME \
+  case CLOCK_REALTIME:							      \
+    retval = INLINE_SYSCALL (clock_settime, 2, clock_id, tp);		      \
+    break
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/unix/clock_settime.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c
@@ -0,0 +1,122 @@
+/* Create a thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __clone __no_broken_clone_decl
+#include <sched.h>
+#include <sys/rfork.h>
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>
+#include <getosreldate.h>
+#undef __clone
+
+/* __start_thread (flags, child_stack, fn, arg)
+   is roughly equivalent to
+
+     int retval = __rfork (flags);
+     if (retval == 0)
+       {
+         // Here we are in the child thread.
+         %stackpointer = child_stack;
+         _exit (fn (arg));
+       }
+     return retval;
+
+   but it cannot be done in portable C because it must access fn and arg
+   after having replaced the stack pointer.  */
+
+extern int __start_thread (int flags, void *child_stack,
+			   int (*fn) (void *), void *arg);
+
+int __clone (int (*fn) (void *), void *child_stack, int flags, void *arg)
+{
+  int rfork_flags = RFPROC;
+
+  if (fn == NULL || child_stack == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* This implementation of clone() does not support all Linux flags.  */
+  if (flags & ~(CSIGNAL | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
+		| CLONE_VFORK | CLONE_SYSVSEM))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if ((flags & CSIGNAL) != SIGCHLD)
+  {
+    if (__kernel_getosreldate() >= 802510)
+                /* we slightly cheat here, */
+                /* the 9.x snapshot prior to r223966 does not support it too */
+    {
+      if ((flags & CSIGNAL) & ~RFTSIGMASK)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+        rfork_flags |= (RFTSIGZMB | RFTSIGFLAGS(flags & CSIGNAL));
+    }
+    else
+    {
+      if ((flags & CSIGNAL) & ~RFTHPNMASK)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      if ((flags & CSIGNAL) == 0)
+        rfork_flags |= (RFLINUXTHPN | ((SIGCHLD) <<  RFTHPNSHIFT));
+      else
+        rfork_flags |= (RFLINUXTHPN | ((flags & CSIGNAL) <<  RFTHPNSHIFT));
+    }
+  } 
+  if (flags & CLONE_VM)
+    rfork_flags |= RFMEM;
+
+  if (flags & CLONE_FS)
+    /* Sharing the filesystem related info (umask, cwd, root dir)
+       is not supported by rfork.  Ignore this; let's hope programs
+       will set their umask and cwd before spawning threads.  */
+    ;
+
+  if (flags & CLONE_SYSVSEM)
+    /* Ignore this; it has been introduced into linuxthreads in post 2.4 glibc */
+    ;
+
+  if (!(flags & CLONE_FILES))
+    rfork_flags |= RFFDG;
+
+  if (flags & CLONE_SIGHAND)
+    {
+      rfork_flags |= RFSIGSHARE;
+      /* Also set the undocumented flag RFTHREAD.  It has the effect that when
+	 the thread leader exits, all threads belonging to it are killed.  */
+      rfork_flags |= RFTHREAD;
+    }
+
+  if (flags & CLONE_VFORK)
+    rfork_flags |= RFPPWAIT;
+
+  return __start_thread (rfork_flags, child_stack, fn, arg);
+}
+
+weak_alias (__clone, clone)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure
@@ -0,0 +1,353 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+case "$machine" in
+  x86_64*)
+	echo "Adding extra sysnames for kfreebsd/x86_64/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf $sysnames"
+    ;;
+  mips*)
+	echo "Adding extra sysnames for kfreebsd/mips/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/elf $sysnames"
+    ;;
+esac
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+      SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
+echo "$as_me:$LINENO: checking installed kFreeBSD kernel header files" >&5
+echo $ECHO_N "checking installed kFreeBSD kernel header files... $ECHO_C" >&6
+if test "${libc_cv_kfreebsd600+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version <  (6 *100000+ 0 *1000+ 0) /* 6.0.0 */
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
+  libc_cv_kfreebsd600='TOO OLD!'
+else
+  libc_cv_kfreebsd600='6.0.0 or later'
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $libc_cv_kfreebsd600" >&5
+echo "${ECHO_T}$libc_cv_kfreebsd600" >&6
+if test "$libc_cv_kfreebsd600" != '6.0.0 or later'; then
+  { { echo "$as_me:$LINENO: error: GNU libc requires kernel header files from
+kFreeBSD 6.0.0 or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD 6.0.0 or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers." >&5
+echo "$as_me: error: GNU libc requires kernel header files from
+kFreeBSD 6.0.0 or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD 6.0.0 or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# Check whether --enable-compatible-utmp or --disable-compatible-utmp was given.
+if test "${enable_compatible_utmp+set}" = set; then
+  enableval="$enable_compatible_utmp"
+  enable_utmp_compat=$enableval
+else
+  enable_utmp_compat=no
+fi;
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=6.0.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=6.0.0
+    ;;
+  *)
+    arch_minimum_kernel=6.0.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+
+  if test $user_version -lt $arch_version; then
+    { echo "$as_me:$LINENO: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&5
+echo "$as_me: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&2;}
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '6.0.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  echo "$as_me:$LINENO: checking for kernel header at least $minimum_kernel" >&5
+echo $ECHO_N "checking for kernel header at least $minimum_kernel... $ECHO_C" >&6
+  hdrnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 100000 + \2 * 1000 + \3)/'`;
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 65536 + \2 * 256 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $hdrnum
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then
+  libc_minimum_kernel='too old!'
+else
+  libc_minimum_kernel=ok
+fi
+rm -f conftest*
+
+  echo "$as_me:$LINENO: result: $libc_minimum_kernel" >&5
+echo "${ECHO_T}$libc_minimum_kernel" >&6
+  if test "$libc_minimum_kernel" = ok; then
+    cat >>confdefs.h <<_ACEOF
+#define __KFREEBSD_KERNEL_VERSION $decnum
+_ACEOF
+
+    cat >>confdefs.h <<_ACEOF
+#define __ABI_TAG_VERSION $abinum
+_ACEOF
+
+  else
+    { { echo "$as_me:$LINENO: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&5
+echo "$as_me: error: *** The available kernel headers are older than the requested
+*** compatible kernel version" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the LinuxThreads or (may be later) NPTL add-on should be available.
+case $add_ons in
+  # Only one of the add-ons should be available.
+  *linuxthreads*nptl*|*nptl*linuxthreads*)
+    echo "\
+*** LinuxThreads and NPTL add-ons are both available.  Only one must be used."
+    exit 1
+    ;;
+  # It is available.  Good.
+  *linuxthreads*)
+    linuxthreads_missing=
+    ;;
+  *nptl*)
+    linuxthreads_missing=
+    ;;
+  *)
+    linuxthreads_missing=yes
+    ;;
+esac
+
+if test "$linuxthreads_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`linuxthreads' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`linuxthreads'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=../ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  echo "$as_me:$LINENO: checking for symlinks in ${ac_prefix}/include" >&5
+echo $ECHO_N "checking for symlinks in ${ac_prefix}/include... $ECHO_C" >&6
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    { { echo "$as_me:$LINENO: error: $ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." >&5
+echo "$as_me: error: $ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." >&2;}
+   { (exit 1); exit 1; }; }
+  else
+    echo "$as_me:$LINENO: result: ok" >&5
+echo "${ECHO_T}ok" >&6
+  fi
+fi
+
+# We support internal syscalls.
+# It is advertised as inlined syscalls availability ...
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_INLINED_SYSCALLS 1
+_ACEOF
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in
@@ -0,0 +1,277 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+case "$machine" in
+  x86_64*)
+	echo "Adding extra sysnames for kfreebsd/x86_64/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf $sysnames"
+    ;;
+  mips*)
+	echo "Adding extra sysnames for kfreebsd/mips/elf"
+	sysnames="ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/elf $sysnames"
+    ;;
+esac
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+  dnl We don't have to use -nostdinc.  We just want one more directory
+  dnl to be used.
+  SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+define([LIBC_KFREEBSD_VERSION],[6.0.0])dnl
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+define([libc_cv_kfreebsdVER], [libc_cv_kfreebsd]patsubst(LIBC_KFREEBSD_VERSION,[\.]))dnl
+AC_CACHE_CHECK(installed kFreeBSD kernel header files, libc_cv_kfreebsdVER, [dnl
+AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version < ]dnl
+patsubst(LIBC_KFREEBSD_VERSION,[^\([^.]*\)\.\([^.]*\)\.\([^.]*\)$],dnl
+[ (\1 *100000+ \2 *1000+ \3) /* \1.\2.\3 */])[
+eat flaming death
+#endif],
+	     libc_cv_kfreebsdVER='TOO OLD!',
+	     libc_cv_kfreebsdVER='LIBC_KFREEBSD_VERSION or later')])
+if test "$libc_cv_kfreebsdVER" != 'LIBC_KFREEBSD_VERSION or later'; then
+  AC_MSG_ERROR([GNU libc requires kernel header files from
+kFreeBSD LIBC_KFREEBSD_VERSION or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD LIBC_KFREEBSD_VERSION or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers.])
+fi
+
+AC_ARG_ENABLE(compatible-utmp, dnl
+[  --disable-compatible-utmp  use a struct utmp which is the same as struct
+                          utmpx, as on kFreeBSD, but incompatible with FreeBSD],
+              enable_utmp_compat=$enableval, enable_utmp_compat=no)
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=6.0.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=6.0.0
+    ;;
+  *)
+    arch_minimum_kernel=6.0.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+  changequote(,)
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  changequote([,])
+  if test $user_version -lt $arch_version; then
+    AC_MSG_WARN([minimum kernel version reset to $arch_minimum_kernel])
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '6.0.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  AC_MSG_CHECKING(for kernel header at least $minimum_kernel)
+changequote(,)dnl
+  hdrnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 100000 + \2 * 1000 + \3)/'`;
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 65536 + \2 * 256 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+changequote([,])dnl
+  AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $hdrnum
+eat flaming death
+#endif], libc_minimum_kernel='too old!', libc_minimum_kernel=ok)
+  AC_MSG_RESULT($libc_minimum_kernel)
+  if test "$libc_minimum_kernel" = ok; then
+    AC_DEFINE_UNQUOTED(__KFREEBSD_KERNEL_VERSION, $decnum)
+    AC_DEFINE_UNQUOTED(__ABI_TAG_VERSION, $abinum)
+  else
+    AC_MSG_ERROR([*** The available kernel headers are older than the requested
+*** compatible kernel version])
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the LinuxThreads or (may be later) NPTL add-on should be available.
+case $add_ons in
+  # Only one of the add-ons should be available.
+  *linuxthreads*nptl*|*nptl*linuxthreads*)
+    echo "\
+*** LinuxThreads and NPTL add-ons are both available.  Only one must be used."
+    exit 1
+    ;;
+  # It is available.  Good.
+  *linuxthreads*)
+    linuxthreads_missing=
+    ;;
+  *nptl*)
+    linuxthreads_missing=
+    ;;
+  *)
+    linuxthreads_missing=yes
+    ;;
+esac
+
+if test "$linuxthreads_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`linuxthreads' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`linuxthreads'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+changequote(,)
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=../ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+changequote([,])
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  AC_MSG_CHECKING([for symlinks in ${ac_prefix}/include])
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    AC_MSG_ERROR([$ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way.])
+  else
+    AC_MSG_RESULT(ok)
+  fi
+fi
+
+# We support internal syscalls.
+# It is advertised as inlined syscalls availability ...
+AC_DEFINE(HAVE_INLINED_SYSCALLS)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/connect.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern int __syscall_connect (int fd, __CONST_SOCKADDR_ARG addr,
+			      socklen_t addrlen);
+libc_hidden_proto (__syscall_connect)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if ((new_addrlen != 0) && (new_addrlen < addrlen))
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (connect, 3, fd, addr.__sockaddr__, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (connect, 3, fd, addr.__sockaddr__, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_connect, __connect_internal)
+weak_alias (__libc_connect, __connect)
+weak_alias (__libc_connect, connect)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/devname.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+#include <stdio.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+
+char *
+__devname_r(__dev_t dev, __mode_t type, char *buf, int len)
+{
+	int i;
+	size_t j;
+	const char *r;
+
+	if ((type & S_IFMT) == S_IFCHR) {
+		j = len;
+		i = __sysctlbyname("kern.devname", buf, &j, &dev, sizeof (dev));
+		if (i == 0)
+		    return (buf);
+	}
+
+	/* Finally just format it */
+	if (dev == NODEV)
+		r = "#NODEV";
+	else 
+		r = "#%c:%d:0x%x";
+	__snprintf(buf, len, r,
+	    (type & S_IFMT) == S_IFCHR ? 'C' : 'B', major(dev), minor(dev));
+	return (buf);
+}
+
+
+char *
+__devname(__dev_t dev, __mode_t type)
+{
+	static char buf[SPECNAMELEN + 1];
+
+	return(__devname_r(dev, type, buf, sizeof(buf)));
+}
+weak_alias (__devname_r, devname_r)
+weak_alias (__devname, devname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-execstack.c
@@ -0,0 +1,58 @@
+/* Stack executability handling for GNU dynamic linker.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <libintl.h>
+#include <stdbool.h>
+#include <stackinfo.h>
+#include <caller.h>
+
+
+extern int __stack_prot attribute_relro attribute_hidden;
+
+
+int
+internal_function
+_dl_make_stack_executable (void **stack_endp)
+{
+  /* This gives us the highest/lowest page that needs to be changed.  */
+  uintptr_t page = ((uintptr_t) *stack_endp
+		    & -(intptr_t) GLRO(dl_pagesize));
+
+  /* Challenge the caller.  */
+  if (__builtin_expect (__check_caller (RETURN_ADDRESS (0),
+					allow_ldso|allow_libpthread) != 0, 0)
+      || __builtin_expect (*stack_endp != __libc_stack_end, 0))
+    return EPERM;
+
+  if (__builtin_expect (__mprotect ((void *) page, GLRO(dl_pagesize),
+				    __stack_prot) != 0, 0))
+    return errno;
+
+  /* Clear the address.  */
+  *stack_endp = NULL;
+
+  /* Remember that we changed the permission.  */
+  GL(dl_stack_flags) |= PF_X;
+
+  return 0;
+}
+rtld_hidden_def (_dl_make_stack_executable)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-origin.c
@@ -0,0 +1,123 @@
+/* Find path of executable.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <ldsodefs.h>
+#include <sysdep.h>
+
+#include <dl-dst.h>
+
+const char *_self_program_name_from_auxv attribute_hidden;
+
+static int
+_dl_self_name(char *buf, int buflen)
+{
+  int len, wdlen;
+
+  /* try /proc/self/exe symlink. */  
+  len = __readlink("/proc/self/exe", buf, buflen);
+
+  if (len > 0 && buf[0] == '/')
+    return len;
+
+  if (!_self_program_name_from_auxv)
+    return -1;
+
+  len = strlen(_self_program_name_from_auxv);
+  if (len > 0 && _self_program_name_from_auxv[0] == '/')
+  {
+    /* absolute file name */
+    if (len < buflen)
+    {
+      strcpy(buf, _self_program_name_from_auxv);
+      return len;
+    }
+    memcpy(buf, _self_program_name_from_auxv, buflen);
+    buf[buflen - 1] = 0;
+    return buflen - 1;
+  };
+  
+  /* relative file name, do our best */
+  if (NULL == __getcwd(buf, buflen))
+    return -1;
+  
+  wdlen = strlen(buf);
+  buf[wdlen] = '/';
+  if ((wdlen + len + 1) < buflen)
+  {
+    strcpy(buf + wdlen + 1, _self_program_name_from_auxv);
+    return wdlen + len + 1;
+  }
+  memcpy(buf + wdlen + 1, _self_program_name_from_auxv, buflen - wdlen - 1);  
+  buf[buflen - 1] = 0;
+  return buflen - 1;  
+}
+
+
+
+const char *
+_dl_get_origin (void)
+{
+  char linkval[2*PATH_MAX];
+  char *result;
+  int len;
+
+  len = _dl_self_name(linkval, sizeof(linkval));
+
+  if (len > 0)
+    {
+      /* We can use this value.  */
+      while (len > 1 && linkval[len - 1] != '/')
+	--len;
+      result = (char *) malloc (len + 1);
+      if (result == NULL)
+	result = (char *) -1;
+      else if (len == 1)
+	memcpy (result, "/", 2);
+      else
+	*((char *) __mempcpy (result, linkval, len - 1)) = '\0';
+    }
+  else
+    {
+      result = (char *) -1;
+      /* We use the environment variable LD_ORIGIN_PATH.  If it is set make
+	 a copy and strip out trailing slashes.  */
+      if (GLRO(dl_origin_path) != NULL)
+	{
+	  size_t len = strlen (GLRO(dl_origin_path));
+	  result = (char *) malloc (len + 1);
+	  if (result == NULL)
+	    result = (char *) -1;
+	  else
+	    {
+	      char *cp = __mempcpy (result, GLRO(dl_origin_path), len);
+	      while (cp > result + 1 && cp[-1] == '/')
+		--cp;
+	      *cp = '\0';
+	    }
+	}
+    }
+
+  return result;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-osinfo.h
@@ -0,0 +1,98 @@
+/* Operating system specific code  for generic dynamic loader functions.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <fcntl.h>
+#include <sys/sysctl.h>
+#include <sys/utsname.h>
+#include <kernel-features.h>
+
+#ifndef MIN
+# define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifdef SHARED
+/* This is the function used in the dynamic linker to print the fatal error
+   message.  */
+static inline void
+__attribute__ ((__noreturn__))
+dl_fatal (const char *str)
+{
+  _dl_dprintf (2, str);
+  _exit (1);
+}
+#endif
+
+#define DL_SYSDEP_OSCHECK(FATAL)					      \
+  do {									      \
+    /* Test whether the kernel is new enough.  This test is only performed    \
+       if the library is not compiled to run on all kernels.  */	      \
+									      \
+    int version = _dl_discover_osversion ();				      \
+    if (__builtin_expect (version >= 0, 1))				      \
+      {									      \
+	if (__builtin_expect (GLRO(dl_osversion) == 0, 1)		      \
+	    || GLRO(dl_osversion) > version)				      \
+	  GLRO(dl_osversion) = version;					      \
+									      \
+	/* Now we can test with the required version.  */		      \
+	if (__KFREEBSD_KERNEL_VERSION > 0 && 				      \
+	    version < __KFREEBSD_KERNEL_VERSION)   			      \
+	  /* Not sufficent.  */						      \
+	  FATAL ("FATAL: kernel too old\n");				      \
+      }									      \
+    else if (__KFREEBSD_KERNEL_VERSION > 0)				      \
+      FATAL ("FATAL: cannot determine kernel version\n");		      \
+  } while (0)
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_stack_chk_guard (void *dl_random)
+{
+  uintptr_t ret;
+#ifdef ENABLE_STACKGUARD_RANDOMIZE
+  int fd = __open ("/dev/urandom", O_RDONLY);
+  if (fd >= 0)
+    {
+      ssize_t reslen = __read (fd, &ret, sizeof (ret));
+      __close (fd);
+      if (reslen == (ssize_t) sizeof (ret))
+        return ret;
+    }
+#endif
+  ret = 0;
+  unsigned char *p = (unsigned char *) &ret;
+  p[sizeof (ret) - 1] = 255;
+  p[sizeof (ret) - 2] = '\n';
+  return ret;
+}
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_pointer_guard (void *dl_random, uintptr_t stack_chk_guard)
+{
+  uintptr_t ret;
+
+  ret = stack_chk_guard;
+# ifndef HP_TIMING_NONAVAIL
+  hp_timing_t now;
+  HP_TIMING_NOW (now);
+  ret ^= now;
+# endif
+  return ret;
+}
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-support.c
@@ -0,0 +1,44 @@
+/* Dynamic linker system dependencies for GNU/kFreeBSD.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define _dl_aux_init _dl_aux_init_ignored_code
+#include <elf/dl-support.c>
+#include <bits/elf.h>
+#undef _dl_aux_init
+
+#ifdef HAVE_AUX_VECTOR
+void
+internal_function
+_dl_aux_init (ElfW(auxv_t) *av)
+{
+  for (; av->a_type != AT_NULL; ++av)
+    switch (av->a_type)
+      {
+      case AT_PAGESZ:
+	GLRO(dl_pagesize) = av->a_un.a_val;
+	break;
+      case AT_PHDR:
+	GL(dl_phdr) = (void *) av->a_un.a_val;
+	break;
+      case AT_PHNUM:
+	GL(dl_phnum) = av->a_un.a_val;
+	break;
+      }
+}
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-sysdep.c
@@ -0,0 +1,253 @@
+/* Dynamic linker system dependencies for GNU/kFreeBSD.
+   Copyright (C) 1995-1998,2000-2008,2009,2010,2011
+        Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* For SHARED, use the generic dynamic linker system interface code. */
+/* otherwise the code is in dl-support.c */
+
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <ldsodefs.h>
+#include <kernel-features.h>
+
+#ifdef SHARED
+# define _dl_sysdep_start _dl_sysdep_start_ignored_code
+# define _dl_show_auxv _dl_show_auxv_ignored_code
+# include <elf/dl-sysdep.c>
+# include <bits/elf.h>
+# undef _dl_sysdep_start
+# undef _dl_show_auxv
+
+extern const char *_self_program_name_from_auxv attribute_hidden;
+
+ElfW(Addr)
+_dl_sysdep_start (void **start_argptr,
+		  void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,
+				   ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))
+{
+  const ElfW(Phdr) *phdr = NULL;
+  ElfW(Word) phnum = 0;
+  ElfW(Addr) user_entry;
+  ElfW(auxv_t) *av;
+  uid_t uid = 0;
+  gid_t gid = 0;
+#ifdef NEED_DL_SYSINFO
+  uintptr_t new_sysinfo = 0;
+#endif
+
+  __libc_stack_end = DL_STACK_END (start_argptr);
+  DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, INTUSE(_dl_argv), _environ,
+			  _dl_auxv);
+
+  user_entry = (ElfW(Addr)) ENTRY_POINT;
+  GLRO(dl_platform) = NULL; /* Default to nothing known about the platform.  */
+
+  for (av = _dl_auxv; av->a_type != AT_NULL; av++)
+    switch (av->a_type)
+      {
+      case AT_PHDR:
+	phdr = (void *) av->a_un.a_val;
+	break;
+      case AT_PHNUM:
+	phnum = av->a_un.a_val;
+	break;
+      case AT_PAGESZ:
+	GLRO(dl_pagesize) = av->a_un.a_val;
+	break;
+      case AT_ENTRY:
+	user_entry = av->a_un.a_val;
+	break;
+      case AT_EXECPATH:
+	_self_program_name_from_auxv = (char *) av->a_un.a_val;
+	break;
+#ifdef NEED_DL_BASE_ADDR
+      case AT_BASE:
+	_dl_base_addr = av->a_un.a_val;
+	break;
+#endif
+      }
+
+    {
+      /* Fill in the values we have not gotten from the kernel through the
+	 auxiliary vector.  */
+#  undef SEE
+#  define SEE(UID, var, uid) \
+   var ^= __get##uid ()
+      SEE (UID, uid, uid);
+      SEE (EUID, uid, euid);
+      SEE (GID, gid, gid);
+      SEE (EGID, gid, egid);
+
+      /* If one of the two pairs of IDs does not match this is a setuid
+	 or setgid run.  */
+      INTUSE(__libc_enable_secure) = uid | gid;
+    }
+
+#ifndef HAVE_AUX_PAGESIZE
+  if (GLRO(dl_pagesize) == 0)
+    GLRO(dl_pagesize) = __getpagesize ();
+#endif
+
+#if defined NEED_DL_SYSINFO
+  /* Only set the sysinfo value if we also have the vsyscall DSO.  */
+  if (GLRO(dl_sysinfo_dso) != 0 && new_sysinfo)
+    GLRO(dl_sysinfo) = new_sysinfo;
+#endif
+
+#ifdef DL_SYSDEP_INIT
+  DL_SYSDEP_INIT;
+#endif
+
+#ifdef DL_PLATFORM_INIT
+  DL_PLATFORM_INIT;
+#endif
+
+  /* Determine the length of the platform name.  */
+  if (GLRO(dl_platform) != NULL)
+    GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
+
+  if (__sbrk (0) == _end)
+    /* The dynamic linker was run as a program, and so the initial break
+       starts just after our bss, at &_end.  The malloc in dl-minimal.c
+       will consume the rest of this page, so tell the kernel to move the
+       break up that far.  When the user program examines its break, it
+       will see this new value and not clobber our data.  */
+    __sbrk (GLRO(dl_pagesize)
+	    - ((_end - (char *) 0) & (GLRO(dl_pagesize) - 1)));
+
+  /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
+     allocated.  If necessary we are doing it ourself.  If it is not
+     possible we stop the program.  */
+  if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
+    __libc_check_standard_fds ();
+
+  (*dl_main) (phdr, phnum, &user_entry, _dl_auxv);
+  return user_entry;
+}
+
+void
+internal_function
+_dl_show_auxv (void)
+{
+  char buf[64];
+  ElfW(auxv_t) *av;
+
+  /* Terminate string.  */
+  buf[63] = '\0';
+
+  /* The following code assumes that the AT_* values are encoded
+     starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values
+     close by (otherwise the array will be too large).  In case we have
+     to support a platform where these requirements are not fulfilled
+     some alternative implementation has to be used.  */
+  for (av = _dl_auxv; av->a_type != AT_NULL; ++av)
+    {
+      static const struct
+      {
+	const char label[17];
+	enum { unknown = 0, dec, hex, str, ignore } form : 8;
+      } auxvars[] =
+	{
+	  [AT_EXECFD - 2] =		{ "EXECFD:       ", dec },
+	  [AT_PHDR - 2] =		{ "PHDR:         0x", hex },
+	  [AT_PHENT - 2] =		{ "PHENT:        ", dec },
+	  [AT_PHNUM - 2] =		{ "PHNUM:        ", dec },
+	  [AT_PAGESZ - 2] =		{ "PAGESZ:       ", dec },
+	  [AT_BASE - 2] =		{ "BASE:         0x", hex },
+	  [AT_FLAGS - 2] =		{ "FLAGS:        0x", hex },
+	  [AT_ENTRY - 2] =		{ "ENTRY:        0x", hex },
+#ifndef __powerpc__
+	  /* For some odd reason these are not in sys/powerpc/include/elf.h.  */
+	  [AT_NOTELF - 2] =		{ "NOTELF:       ", hex },
+	  [AT_UID - 2] =		{ "UID:          ", dec },
+	  [AT_EUID - 2] =		{ "EUID:         ", dec },
+	  [AT_GID - 2] =		{ "GID:          ", dec },
+	  [AT_EGID - 2] =		{ "EGID:         ", dec },
+#endif
+	  [AT_EXECPATH - 2] =		{ "EXECPATH:     ", str },
+	  [AT_CANARY - 2] =		{ "CANARY:       0x", hex },
+	  [AT_CANARYLEN - 2] =		{ "CANARYLEN:    ", dec },
+	  [AT_OSRELDATE - 2] =		{ "OSRELDATE:    ", dec },
+	  [AT_NCPUS - 2] =		{ "NCPUS:        ", dec },
+	  [AT_PAGESIZES - 2] =		{ "PAGESIZES:    0x", hex },
+	  [AT_PAGESIZESLEN - 2] =	{ "PAGESIZESLEN: ", dec },
+	  [AT_STACKPROT - 2] =		{ "STACKPROT:    0x", hex },
+	};
+      unsigned int idx = (unsigned int) (av->a_type - 2);
+
+      if ((unsigned int) av->a_type < 2u || auxvars[idx].form == ignore)
+	continue;
+
+      assert (AT_NULL == 0);
+      assert (AT_IGNORE == 1);
+
+      if (idx < sizeof (auxvars) / sizeof (auxvars[0])
+	  && auxvars[idx].form != unknown)
+	{
+	  const char *val = (char *) av->a_un.a_val;
+
+	  if (__builtin_expect (auxvars[idx].form, dec) == dec)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 10, 0);
+	  else if (__builtin_expect (auxvars[idx].form, hex) == hex)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 16, 0);
+
+	  _dl_printf ("AT_%s%s\n", auxvars[idx].label, val);
+
+	  continue;
+	}
+
+      /* Unknown value: print a generic line.  */
+      char buf2[17];
+      buf2[sizeof (buf2) - 1] = '\0';
+      const char *val2 = _itoa ((unsigned long int) av->a_un.a_val,
+				buf2 + sizeof buf2 - 1, 16, 0);
+      const char *val =  _itoa ((unsigned long int) av->a_type,
+				buf + sizeof buf - 1, 16, 0);
+      _dl_printf ("AT_??? (0x%s): 0x%s\n", val, val2);
+    }
+}
+#endif
+
+int
+attribute_hidden
+_dl_discover_osversion (void)
+{
+  int request[2] = { CTL_KERN, KERN_OSRELDATE };
+  size_t len;
+  int version;
+
+  len = sizeof(version);
+  if (__sysctl (request, 2, &version, &len, NULL, 0) < 0)
+    return -1;
+    
+/*
+ *   scheme is:  <major><two digit minor>Rxx
+ *		'R' is 0 if release branch or x.0-CURRENT before RELENG_*_0
+ *		is created, otherwise 1.
+ */
+
+  /* Convert to the GLIBC versioning system */
+  return ((version / 100000) << 16)		/* major */
+	 | (((version % 100000) / 1000) << 8)   /* minor 	0 -  99 */
+	 | ((version % 200));			/* subrelease 	0 - 199 */
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-sysdep.h
@@ -0,0 +1,26 @@
+/* System-specific settings for dynamic linker code.  Linux version.
+   Copyright (C) 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+/* Get version of the OS.  */
+extern int _dl_discover_osversion (void) attribute_hidden;
+# define HAVE_DL_DISCOVER_OSVERSION	1
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/faccessat.c
@@ -0,0 +1,198 @@
+/* Test for access to file, relative to open directory.  Linux version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <sysdep.h>
+
+extern int __syscall_faccessat (int fd, const char *path, int mode, int flag);
+libc_hidden_proto (__syscall_faccessat)
+
+/*
+   The FreeBSD kernel do not test file access correctly when the 
+   process' real user ID is superuser. In particular, they always return
+   zero when testing execute permissions without regard to whether the 
+   file is executable.
+
+   While this behaviour conforms to POSIX.1-2008, it is explicitely 
+   discouraged. This wrapper implements the recommended behaviour.
+ */
+
+int
+faccessat (fd, file, mode, flag)
+     int fd;
+     const char *file;
+     int mode;
+     int flag;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (faccessat, 4, fd, file, mode, flag);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+      {
+        if ((result == 0) && (mode & X_OK))
+        {
+          uid_t uid = (flag & AT_EACCESS) ? __geteuid () : __getuid ();
+          if (uid == 0)
+          {
+            struct stat64 stats;
+            if (fstatat64 (fd, file, &stats, flag & AT_SYMLINK_NOFOLLOW))
+              return -1;
+            if ((stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0)
+            {
+              __set_errno (EACCES);
+              return -1;
+	    }
+          }
+	}
+	return result;
+      }	
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if ((!(flag & AT_EACCESS) || !__libc_enable_secure)
+      && !(flag & AT_SYMLINK_NOFOLLOW))
+    {
+      /* If we are not set-uid or set-gid, access does the same.  */
+      if (fd != AT_FDCWD && file[0] != '/')
+	{
+	  int mib[4];
+	  size_t kf_len = 0;
+	  char *kf_buf, *kf_bufp;
+	  size_t filelen;
+
+	  if (fd < 0)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+
+	  filelen = strlen (file);
+	  if (__builtin_expect (filelen == 0, 0))
+	    {
+	      __set_errno (ENOENT);
+	      return -1;
+	    }
+
+	  mib[0] = CTL_KERN;
+	  mib[1] = KERN_PROC;
+	  mib[2] = KERN_PROC_FILEDESC;
+	  mib[3] = __getpid ();
+
+	  if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	    {
+	      __set_errno (ENOSYS);
+	      return -1;
+	    }
+
+	  kf_buf = alloca (kf_len + filelen);
+	  if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	    {
+	      __set_errno (ENOSYS);
+	      return -1;
+	    }
+
+	  kf_bufp = kf_buf;
+	  while (kf_bufp < kf_buf + kf_len)
+	    {
+	      struct kinfo_file *kf =
+		(struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	      if (kf->kf_fd == fd)
+		{
+		  if (kf->kf_type != KF_TYPE_VNODE ||
+		      kf->kf_vnode_type != KF_VTYPE_VDIR)
+		    {
+		      __set_errno (ENOTDIR);
+		      return -1;
+		    }
+
+		  strcat (kf->kf_path, "/");
+		  strcat (kf->kf_path, file);
+		  file = kf->kf_path;
+		  break;
+		}
+	      kf_bufp += kf->kf_structsize;
+	    }
+
+	  if (kf_bufp >= kf_buf + kf_len)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+	}
+
+      return __access (file, mode);
+    }
+#endif
+
+  struct stat64 stats;
+  if (fstatat64 (fd, file, &stats, flag & AT_SYMLINK_NOFOLLOW))
+    return -1;
+
+  mode &= (X_OK | W_OK | R_OK);	/* Clear any bogus bits. */
+#if R_OK != S_IROTH || W_OK != S_IWOTH || X_OK != S_IXOTH
+# error Oops, portability assumptions incorrect.
+#endif
+
+  if (mode == F_OK)
+    return 0;			/* The file exists. */
+
+  uid_t uid = (flag & AT_EACCESS) ? __geteuid () : __getuid ();
+
+  /* The super-user can read and write any file, and execute any file
+     that anyone can execute. */
+  if (uid == 0 && ((mode & X_OK) == 0
+		   || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
+    return 0;
+
+  int granted = (uid == stats.st_uid
+		 ? (unsigned int) (stats.st_mode & (mode << 6)) >> 6
+		 : (stats.st_gid == ((flag & AT_EACCESS)
+				     ? __getegid () : __getgid ())
+		    || __group_member (stats.st_gid))
+		 ? (unsigned int) (stats.st_mode & (mode << 3)) >> 3
+		 : (stats.st_mode & mode));
+
+  if (granted == mode)
+    return 0;
+
+  __set_errno (EACCES);
+  return -1;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fchmodat.c
@@ -0,0 +1,138 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_fchmodat (int fd, const char *path,
+			       mode_t mode, int flag);
+libc_hidden_proto (__syscall_fchmodat)
+
+/* This is specific to kFreeBSD. */
+extern int __lchmod (__const char *__file, __mode_t __mode);
+
+int
+fchmodat (fd, file, mode, flag)
+     int fd;
+     const char *file;
+     mode_t mode;
+     int flag;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (fchmodat, 4, fd, file, mode, flag);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_SYMLINK_NOFOLLOW)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  if (flag & AT_SYMLINK_NOFOLLOW)
+    return __lchmod(file, mode);
+  else
+    return __chmod(file, mode);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fchownat.c
@@ -0,0 +1,137 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_fchownat (int fd, const char *path, uid_t uid,
+			       gid_t gid, int flag);
+libc_hidden_proto (__syscall_fchownat)
+
+/* Change the owner and group of FILE.  */
+int
+fchownat (fd, file, owner, group, flag)
+     int fd;
+     const char *file;
+     uid_t owner;
+     gid_t group;
+     int flag;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (fchownat, 5, fd, file, owner, group, flag);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_SYMLINK_NOFOLLOW)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  if (flag & AT_SYMLINK_NOFOLLOW)
+    return __lchown(file, owner, group);
+  else
+    return __chown(file, owner, group);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fcntl.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <sysdep-cancel.h>	/* Must come before <fcntl.h>.  */
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sys/syscall.h>
+
+
+#ifndef NO_CANCELLATION
+int
+__fcntl_nocancel (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+}
+#endif
+
+
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (SINGLE_THREAD_P || cmd != F_SETLKW)
+    return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__libc_fcntl)
+
+weak_alias (__libc_fcntl, __fcntl)
+libc_hidden_weak (__fcntl)
+weak_alias (__libc_fcntl, fcntl)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fexecve.c
@@ -0,0 +1,103 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_fexecve (int fd, char *const argv[], char *const envp[]);
+libc_hidden_proto (__syscall_fexecve);
+
+/* Execute the file FD refers to, overlaying the running program image.
+   ARGV and ENVP are passed to the new program, as for `execve'.  */
+int
+fexecve (fd, argv, envp)
+     int fd;
+     char *const argv[];
+     char *const envp[];
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (fexecve, 3, fd, argv, envp);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (fd < 0 || argv == NULL || envp == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  int mib[4];
+  size_t kf_len = 0;
+  char *kf_buf, *kf_bufp;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_FILEDESC;
+  mib[3] = __getpid ();
+
+  if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return -1;
+    }
+
+  kf_buf = alloca (kf_len);
+  if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return -1;
+    }
+
+  kf_bufp = kf_buf;
+  while (kf_bufp < kf_buf + kf_len)
+    {
+      struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+      if (kf->kf_fd == fd)
+	{
+	  if (kf->kf_type == KF_TYPE_VNODE &&
+	      kf->kf_vnode_type == KF_VTYPE_VREG)
+	    return __execve (kf->kf_path, argv, envp);
+	  break;
+	}
+      kf_bufp += kf->kf_structsize;
+    }
+
+  __set_errno (EINVAL);
+  return -1;
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+__fhstat (const fhandle_t *fhp, struct stat *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat'.  */
+  stat16_to_stat (&buf16, buf);
+
+  return 0;
+}
+
+weak_alias (__fhstat, fhstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+fhstat64 (const fhandle_t *fhp, struct stat64 *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat64'.  */
+  stat16_to_stat64 (&buf16, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs (const fhandle_t *fhp, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs64 (const fhandle_t *fhp, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs.c
@@ -0,0 +1,38 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+weak_alias (__fstatfs, fstatfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatfs64, fstatfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+fstatvfs (int fd, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (fstatvfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatvfs64 (int fd, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatvfs64, fstatvfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <errno.h>
+
+extern int __syscall_ftruncate (int __fd, __off_t __length) __THROW;
+libc_hidden_proto (__syscall_ftruncate)
+extern int __syscall_freebsd6_ftruncate (int __fd, int __unused1,
+				__off_t __length) __THROW;
+libc_hidden_proto (__syscall_freebsd6_ftruncate)
+
+int
+__ftruncate (int fd, __off_t length)
+{
+  int result;
+
+  /* First try the new syscall. */
+  result = INLINE_SYSCALL (ftruncate, 2, fd, length);
+
+#ifndef __ASSUME_TRUNCATE_SYSCALL
+  if (result == -1 && errno == ENOSYS)
+    /* New syscall not available, us the old one. */
+    result = INLINE_SYSCALL (freebsd6_ftruncate, 3, fd, 0, length);
+#endif
+
+  return result;
+}
+
+weak_alias (__ftruncate, ftruncate)
+
+/* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
+strong_alias (__ftruncate, __ftruncate64)
+weak_alias (__ftruncate64, ftruncate64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c
@@ -0,0 +1 @@
+/* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/futimesat.c
@@ -0,0 +1,138 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/time.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_futimesat (int fd, const char *path,
+				const struct timeval *times);
+libc_hidden_proto (__syscall_futimesat)
+
+/* Change the access time of FILE relative to FD to TVP[0] and
+   the modification time of FILE to TVP[1].  */
+int
+futimesat (fd, file, tvp)
+     int fd;
+     const char *file;
+     const struct timeval tvp[2];
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result;
+
+      if (file == NULL)
+	return __futimes (fd, tvp);
+
+      result = INLINE_SYSCALL (futimesat, 3, fd, file, tvp);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if ((file == NULL) || (fd != AT_FDCWD && file[0] != '/'))
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      if (file == NULL)
+	kf_buf = alloca (kf_len);
+      else
+	kf_buf = alloca (kf_len + filelen);
+
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+	      if (file != NULL)
+		{
+		  strcat (kf->kf_path, "/");
+		  strcat (kf->kf_path, file);
+		}
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  return __utimes(file, tvp);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c
@@ -0,0 +1,48 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_fstat (fd, CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat)
+
+weak_alias (__fxstat, _fxstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c
@@ -0,0 +1,44 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat64 (int vers, int fd, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstatat.c
@@ -0,0 +1,158 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+extern int __syscall_fstatat (int fd, const char *path,
+			      struct stat16 *buf, int flag);
+libc_hidden_proto (__syscall_fstatat)
+
+/* Get information about the file NAME relative to FD in ST.  */
+int
+__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result;
+
+      if (__builtin_expect (vers == _STAT_VER, 1))
+	{
+	  struct stat16 buf16;
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, CHECK_STRING (file),
+			    __ptrvalue (&buf16), flag);
+	  if (result == 0)
+	    stat16_to_stat (&buf16, st);
+	}
+      else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+	{
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, CHECK_STRING (file),
+			    CHECK_1 ((struct stat16 *) st), flag);
+	}
+      else
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_SYMLINK_NOFOLLOW)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  if (flag & AT_SYMLINK_NOFOLLOW)
+    return __lxstat (vers, file, st);
+  else
+    return __xstat (vers, file, st);
+#endif
+}
+
+libc_hidden_def (__fxstatat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstatat64.c
@@ -0,0 +1,152 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+extern int __syscall_fstatat (int fd, const char *path,
+			      struct stat16 *buf, int flag);
+libc_hidden_proto (__syscall_fstatat)
+
+/* Get information about the file NAME relative to FD in ST.  */
+int
+__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag)
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result;
+
+      if (__builtin_expect (vers == _STAT_VER, 1))
+	{
+	  struct stat16 buf16;
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, CHECK_STRING (file),
+			    __ptrvalue (&buf16), flag);
+	  if (result == 0)
+	    stat16_to_stat64 (&buf16, st);
+	}
+      else
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_SYMLINK_NOFOLLOW)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  if (flag & AT_SYMLINK_NOFOLLOW)
+    return __lxstat64 (vers, file, st);
+  else
+    return __xstat64 (vers, file, st);
+#endif
+}
+
+libc_hidden_def (__fxstatat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c
@@ -0,0 +1,91 @@
+/* Determine current working directory.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <bp-checks.h>
+
+/* The system calls only makes a lookup in the VFS cache, which can easily
+   fail.  Therefore we use the generic version as a fallback.  */
+extern int __syscall_getcwd (char *__unbounded buf, unsigned int size);
+libc_hidden_proto (__syscall_getcwd)
+
+static char *generic_getcwd (char *buf, size_t size) internal_function;
+
+char *
+__getcwd (char *buf, size_t size)
+{
+  char tmpbuf[PATH_MAX];
+
+  if (INLINE_SYSCALL (getcwd, 2, tmpbuf, PATH_MAX) >= 0)
+    {
+      size_t len = strlen (tmpbuf) + 1;
+
+      if (size == 0)
+	{
+	  if (__builtin_expect (buf != NULL, 0))
+	    {
+	      __set_errno (EINVAL);
+	      return NULL;
+	    }
+
+	  buf = (char *) malloc (len);
+	  if (__builtin_expect (buf == NULL, 0))
+	    {
+	      __set_errno (ENOMEM);
+	      return NULL;
+	    }
+	}
+      else
+	{
+	  if (size < len)
+	    {
+	      __set_errno (ERANGE);
+	      return NULL;
+	    }
+
+	  if (buf == NULL)
+	    {
+	      buf = (char *) malloc (size);
+	      if (__builtin_expect (buf == NULL, 0))
+		{
+		  __set_errno (ENOMEM);
+		  return NULL;
+		}
+	    }
+	}
+
+      memcpy (buf, tmpbuf, len);
+      return buf;
+    }
+  return generic_getcwd (buf, size);
+}
+
+weak_alias (__getcwd, getcwd)
+
+/* Get the code for the generic version.  */
+#define GETCWD_RETURN_TYPE	static char * internal_function
+#define __getcwd		generic_getcwd
+#include <sysdeps/posix/getcwd.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c
@@ -0,0 +1,90 @@
+/* Read directory entries, 3 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sysdep.h>
+
+#if 1
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+libc_hidden_proto (__syscall_getdents)
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Returns the number of bytes read; zero when at end of directory; or
+   -1 for errors.  */
+ssize_t
+internal_function
+__getdents (int fd, char *buf, size_t nbytes)
+{
+  return __syscall_getdents (fd, buf, nbytes);
+}
+
+/* Export getdents().  Not an internal_function.  */
+ssize_t
+getdents (int fd, char *buf, size_t nbytes)
+{
+  return __syscall_getdents (fd, buf, nbytes);
+}
+
+#else
+
+/* Use the 4-argument system call.  */
+
+extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
+				    long *basep);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Returns the number of bytes read; zero when at end of directory; or
+   -1 for errors.  */
+ssize_t
+internal_function
+__getdents (int fd, char *buf, size_t nbytes)
+{
+  /* On 64-bit platforms, the system call differs from this function
+     because it takes an 'unsigned int', not a 'size_t'.  */
+  unsigned int nbytes32;
+
+  nbytes32 = nbytes;
+  if (nbytes32 == nbytes)
+    return __syscall_getdirentries (fd, buf, nbytes32, NULL);
+  else
+    {
+      /* NBYTES is too large.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+/* Export getdents().  Not an internal_function.  */
+ssize_t
+getdents (int fd, char *buf, size_t nbytes)
+{
+  return __getdents (fd, buf, nbytes);
+}
+
+#endif
+
+/* Since 'struct dirent64' == 'struct dirent', the functions '__getdents64'
+   and '__getdents' are equal.  */
+strong_alias (__getdents, __getdents64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c
@@ -0,0 +1 @@
+/* We have the function getdirentries64 in file getdirentries64.c.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c
@@ -0,0 +1,100 @@
+/* Read directory entries, 4 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef GETDIRENTRIES
+# define GETDIRENTRIES getdirentries
+# define OFF_T off_t
+#endif
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+#if 1
+
+/* Use the 4-argument system call.  */
+
+extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
+				    long *basep);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  /* On 32-bit platforms, the system call differs from this function because
+     it takes a 'long *', not an 'OFF_T *'.  On 64-bit platforms, the system
+     call differs from this function because it takes an 'unsigned int', not
+     a 'size_t'.  */
+  unsigned int nbytes32;
+
+  nbytes32 = nbytes;
+  if (nbytes32 == nbytes)
+    {
+      long base;
+      int result = __syscall_getdirentries (fd, buf, nbytes32, &base);
+
+      if (result >= 0 && basep != NULL)
+	*basep = base;
+      return result;
+    }
+  else
+    {
+      /* NBYTES is too large.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+#else
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  OFF_T base = 0;
+  ssize_t result;
+
+  if (basep)
+    base = __lseek (fd, (off_t) 0, SEEK_CUR);
+
+  result = __syscall_getdents (fd, buf, nbytes);
+
+  if (basep && result >= 0)
+    *basep = base;
+  return result;
+}
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c
@@ -0,0 +1,5 @@
+/* Since 'struct dirent64' == 'struct dirent', the functions 'getdirentries64'
+   and 'getdirentries' differ only in the type of the BASEP argument.  */
+#define GETDIRENTRIES getdirentries64
+#define OFF_T off64_t
+#include <getdirentries.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+
+/* Put the name of the current domain in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+
+int
+getdomainname (char *name, size_t len)
+{
+  /* Fetch the "kern.domainname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
+  size_t result_len = len;
+
+  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
+    {
+      if (errno == ENOMEM)
+	__set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  if (result_len >= len)
+    {
+      __set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  name[result_len] = '\0';
+  return 0;
+}
+libc_hidden_def (getdomainname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat (struct statfs *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat, getfsstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat64 (struct statfs64 *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs64);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs64 (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat64, getfsstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the current machine's Internet number.  */
+long int
+gethostid (void)
+{
+  /* Fetch sysctl value of "kern.hostid".  */
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return result;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+
+/* Put the name of the current host in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+
+int
+__gethostname (char *name, size_t len)
+{
+  /* Fetch the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+  size_t result_len = len;
+
+  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
+    {
+      if (errno == ENOMEM)
+	__set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  if (result_len >= len)
+    {
+      __set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  name[result_len] = '\0';
+  return 0;
+}
+
+weak_alias (__gethostname, gethostname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c
@@ -0,0 +1,53 @@
+/* Get system load averages.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <sys/sysctl.h>
+
+struct loadavg
+  {
+    unsigned int ldavg[3];
+    long fscale;
+  };
+
+/* Put the 1 minute, 5 minute and 15 minute load averages into the first
+   NELEM elements of LOADAVG.  Return the number written (never more than
+   three, but may be less than NELEM), or -1 if an error occurred.  */
+int
+getloadavg (double loadavg[], int nelem)
+{
+  if (nelem > 3)
+    nelem = 3;
+  if (nelem > 0)
+    {
+      /* Fetch the "vm.loadavg" sysctl value.  */
+      int request[2] = { CTL_VM, VM_LOADAVG };
+      struct loadavg result;
+      size_t result_len = sizeof (result);
+      int i;
+
+      if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+	return -1;
+
+      for (i = 0; i < nelem; i++)
+	loadavg[i] = (double) result.ldavg[i] / (double) result.fscale;
+    }
+  return nelem;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c
@@ -0,0 +1,50 @@
+/* Non-reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+extern char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return the login name of the user, or NULL if it can't be determined.
+   The returned pointer, if not NULL, is good only until the next call.  */
+
+char *
+getlogin (void)
+{
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return NULL;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+  return (__getlogin_cache[0] ? __getlogin_cache : NULL);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c
@@ -0,0 +1,70 @@
+/* Reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Cache the system call's return value.  */
+char *__getlogin_cache;
+/* The kernel never returns more than MAXLOGNAME bytes, therefore we don't
+   need more than that either.  */
+char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return at most NAME_LEN characters of the login name of the user in NAME.
+   If it cannot be determined or some other error occurred, return the error
+   code.  Otherwise return 0.
+   Note that the getlogin_r function in FreeBSD libc returns a 'char *',
+   but SUSV2 wants a return type of 'int'.  */
+
+int
+getlogin_r (char *name, size_t name_len)
+{
+  size_t len;
+
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return -1;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+
+  len = strlen (__getlogin_cache);
+  if (__builtin_expect (len < name_len, 1))
+    {
+      memcpy (name, __getlogin_cache, len + 1);
+      return 0;
+    }
+  else
+    {
+      __set_errno (ERANGE);
+      return -1;
+    }
+}
+libc_hidden_def (getlogin_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c
@@ -0,0 +1,80 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+__getmntinfo (struct statfs **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs *) malloc (count * sizeof (struct statfs));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat (mntbuf, count * sizeof (struct statfs), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
+
+weak_alias (__getmntinfo, getmntinfo)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c
@@ -0,0 +1,78 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs64 *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+getmntinfo64 (struct statfs64 **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat64 (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs64 *) malloc (count * sizeof (struct statfs64));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat64 (mntbuf, count * sizeof (struct statfs64), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getosreldate.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <sys/sysctl.h>
+#include <stdlib.h>
+#include <getosreldate.h>
+
+int
+__kernel_getosreldate(void)
+{
+    static int osreldate;
+
+    int mib[2];
+    size_t size;
+
+    if (osreldate == 0)
+    {
+	mib[0] = CTL_KERN;
+	mib[1] = KERN_OSRELDATE;
+	size = sizeof osreldate;
+	if (__sysctl(mib, 2, &osreldate, &size, NULL, 0) == -1)
+		return (-1);
+    }		
+    return (osreldate);
+}
+
+int
+__getosreldate(void)
+{
+    static int osreldate;
+
+    int mib[2];
+    size_t size;
+    char *temp;
+
+    if (osreldate == 0)
+    {
+	if ((temp = getenv("OSVERSION"))) {
+		osreldate = atoi(temp);
+		return (osreldate);
+	}
+
+	osreldate = __kernel_getosreldate ();
+    }		
+    return (osreldate);
+}
+libc_hidden_def (__kernel_getosreldate)
+libc_hidden_def (__getosreldate)
+weak_alias (__getosreldate, getosreldate)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getosreldate.h
@@ -0,0 +1,4 @@
+int __kernel_getosreldate (void);
+int __getosreldate (void);
+libc_hidden_proto (__kernel_getosreldate)
+libc_hidden_proto (__getosreldate)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the system page size.  */
+int
+__getpagesize (void)
+{
+  static int cached_pagesize /* = 0 */;
+
+  if (cached_pagesize == 0)
+    {
+      /* Fetch sysctl value of "hw.pagesize".  */
+      int request[2] = { CTL_HW, HW_PAGESIZE };
+      size_t result_len = sizeof (cached_pagesize);
+
+      if (__sysctl (request, 2, &cached_pagesize, &result_len, NULL, 0) < 0)
+	return -1;
+    }
+  return cached_pagesize;
+}
+libc_hidden_def (__getpagesize)
+
+weak_alias (__getpagesize, getpagesize)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c
@@ -0,0 +1,92 @@
+/* Copyright (C) 1998-1999, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+
+/* Prefix for master pseudo terminal nodes.  */
+#define _PATH_PTY "/dev/pty"
+
+
+/* Letters indicating a series of pseudo terminals.  */
+#ifndef PTYNAME1
+#define PTYNAME1 "pqrs"
+#endif
+const char __libc_ptyname1[] attribute_hidden = PTYNAME1;
+
+/* Letters indicating the position within a series.  */
+#ifndef PTYNAME2
+#define PTYNAME2 "0123456789abcdefghijklmnopqrstuv";
+#endif
+const char __libc_ptyname2[] attribute_hidden = PTYNAME2;
+
+
+/* Open a master pseudo terminal and return its file descriptor.  */
+int
+__posix_openpt (int oflag)
+{
+  char buf[sizeof (_PATH_PTY) + 2];
+  const char *p, *q;
+  char *s;
+
+  s = __mempcpy (buf, _PATH_PTY, sizeof (_PATH_PTY) - 1);
+  /* s[0] and s[1] will be filled in the loop.  */
+  s[2] = '\0';
+
+  for (p = __libc_ptyname1; *p != '\0'; ++p)
+    {
+      s[0] = *p;
+
+      for (q = __libc_ptyname2; *q != '\0'; ++q)
+	{
+	  int fd;
+
+	  s[1] = *q;
+
+	  fd = __open (buf, oflag);
+	  if (fd >= 0)
+	    {
+	      if (!(oflag & O_NOCTTY))
+		__ioctl (fd, TIOCSCTTY, NULL);
+
+	      return fd;
+	    }
+
+	  if (errno == ENOENT)
+	    return -1;
+	}
+    }
+
+  __set_errno (ENOENT);
+  return -1;
+}
+
+weak_alias (__posix_openpt, posix_openpt)
+
+
+int
+__getpt (void)
+{
+  return __posix_openpt (O_RDWR);
+}
+
+weak_alias (__getpt, getpt)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c
@@ -0,0 +1 @@
+/* 'getrlimit64' is the same as 'getrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c
@@ -0,0 +1,109 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <unistd.h>
+#include <stddef.h>
+
+
+int
+__get_nprocs (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[2] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  return result;
+}
+
+weak_alias (__get_nprocs, get_nprocs)
+
+
+int
+__get_nprocs_conf (void)
+{
+  /* We don't know how to distinguish between configured and active CPUs.  */
+  return __get_nprocs ();
+}
+
+weak_alias (__get_nprocs_conf, get_nprocs_conf)
+
+
+long int
+__get_phys_pages (void)
+{
+  /* Fetch sysctl value of "hw.physmem".  This is a little smaller than
+     the real installed memory size, but so what.  */
+  int request[2] = { CTL_HW, HW_PHYSMEM };
+  unsigned long int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result / __getpagesize();
+}
+
+weak_alias (__get_phys_pages, get_phys_pages)
+
+
+long int
+__get_avphys_pages (void)
+{
+#if 1
+  int result1;
+  int result2;
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_inactive_count".  */
+    size_t result_len = sizeof (result1);
+
+    if (__sysctlbyname ("vm.stats.vm.v_inactive_count", &result1, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_free_count".  */
+    size_t result_len = sizeof (result2);
+
+    if (__sysctlbyname ("vm.stats.vm.v_free_count", &result2, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+
+  return result1 + result2;
+#else
+  /* This does not appear to work.  */
+  /* Fetch v_inactive_count field of sysctl value of "vm.vmmeter".  */
+  int request[2] = { CTL_VM, VM_METER };
+  struct vmmeter result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result.v_inactive_count;
+#endif
+}
+
+weak_alias (__get_avphys_pages, get_avphys_pages)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/getvfsbyname.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Given a filesystem name, determine if it is resident in the kernel,
+ * and if it is resident, return its xvfsconf structure.
+ */
+int
+__getvfsbyname(fsname, vfcp)
+	const char *fsname;
+	struct xvfsconf *vfcp;
+{
+	struct xvfsconf *xvfsp;
+	size_t buflen;
+	int cnt, i;
+
+	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0)
+		return (-1);
+	xvfsp = malloc(buflen);
+	if (xvfsp == NULL)
+		return (-1);
+	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
+		free(xvfsp);
+		return (-1);
+	}
+	cnt = buflen / sizeof(struct xvfsconf);
+	for (i = 0; i < cnt; i++) {
+		if (strcmp(fsname, xvfsp[i].vfc_name) == 0) {
+			memcpy(vfcp, xvfsp + i, sizeof(struct xvfsconf));
+			free(xvfsp);
+			return (0);
+		}
+	}
+	free(xvfsp);
+	__set_errno (ENOENT);
+	return (-1);
+}
+weak_alias (__getvfsbyname, getvfsbyname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <posix/glob.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <sysdeps/gnu/glob64.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/gtty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/gtty.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile
@@ -0,0 +1,23 @@
+ifeq ($(subdir),linuxthreads)
+CFLAGS-pt-initfini.s += -fno-asynchronous-unwind-tables
+endif
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h \
+ sys/vm86.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += i386_get_ioperm i386_set_ioperm iopl
+# For <sys/vm86.h>.
+sysdep_routines += i386_vm86
+# For <machine/sysarch.h>.
+sysdep_routines += i386_get_ldt i386_set_ldt
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions
@@ -0,0 +1,7 @@
+libc {
+  GLIBC_2.2.6 {
+    i386_get_ioperm; i386_set_ioperm; i386_vm86;
+    ioperm; iopl;
+    i386_get_ldt; i386_set_ldt;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/____longjmp_chk.S
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include<__longjmp.S>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h
@@ -0,0 +1,111 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  i386 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/i386/include/ucontext.h,v 1.10 2002/12/02 19:58:55 deischen Exp $
+ */
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h
@@ -0,0 +1,97 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-machine.h
@@ -0,0 +1,145 @@
+/* Machine-dependent ELF dynamic relocation inline functions.
+   FreeBSD i386 specific version of dl_platform_init()
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* For FreeBSD we redefine an initialization function.
+   This is called very early in dl_sysdep_start.  */
+
+#if 0
+Under FreeBSD:
+#define AT_EXECPATH     15      /* Path to the executable. */
+
+Under Linux:
+#define AT_PLATFORM     15      /* String identifying platform.  */
+
+Filled entries from kernel:
+
+        if (args->execfd != -1)
+                AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
+        AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);    
+        AUXARGS_ENTRY(pos, AT_PHENT, args->phent);  
+        AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);  
+        AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
+        AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
+        AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
+        AUXARGS_ENTRY(pos, AT_BASE, args->base);
+        if (imgp->execpathp != 0)
+                AUXARGS_ENTRY(pos, AT_EXECPATH, imgp->execpathp);
+        AUXARGS_ENTRY(pos, AT_NULL, 0);
+                                                                                                                
+#endif
+
+#include_next <dl-machine.h>
+
+#undef  DL_PLATFORM_INIT
+#define DL_PLATFORM_INIT dl_platform_kfreebsd_i386_init ()
+
+#ifndef _DL_MACHINE_KFREEBSD
+#define _DL_MACHINE_KFREEBSD
+
+#define X86_EFLAGS_AC   0x00040000 /* Alignment Check */
+#define X86_EFLAGS_ID   0x00200000 /* CPUID detection flag */
+
+static inline int try_flip_flags(int val)
+{
+    int ret;
+    __asm__(
+	"pushfl\n\t"
+	"pushfl\n\t"
+	"popl %%ecx\n\t"
+	"xorl %%ecx,%%eax\n\t"
+	"pushl %%eax\n\t"
+	"popfl\n\t"
+	"pushfl\n\t"
+	"popl %%eax\n\t"
+	"xorl %%ecx,%%eax\n\t"
+	"popfl\n\t"
+	: "=a" (ret)
+	: "0" (val)
+        : "cx"
+    );
+    return ret;
+}
+
+static inline void cpuid(int op, int *eax, int *edx)
+{
+    __asm__(
+	"push %%ebx\n\t"
+	"cpuid\n\t"
+	"pop %%ebx\n\t"
+	: "=a" (*eax),
+	  "=d" (*edx)
+	: "0" (op)
+	: "cx"
+    );
+}
+
+static inline void __attribute__ ((unused))
+dl_platform_kfreebsd_i386_init (void)
+{
+	/* we don't have reasonable AT_PLATFORM from kernel
+	   try to use cpuid to get one, also guess AT_HWCAP */
+
+	int val, hwcap;
+
+	val = try_flip_flags(X86_EFLAGS_AC | X86_EFLAGS_ID);
+
+	if (!(val & X86_EFLAGS_AC))
+	{
+		/* 386 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[0];
+		GLRO(dl_hwcap) = 0;
+	}
+	else if (!(val & X86_EFLAGS_ID))
+	{
+		/* 486 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		GLRO(dl_hwcap) = 0;
+	}
+	else
+	{
+	    cpuid(0, &val, &hwcap);
+	    if (val == 0)
+	    {
+		/* 486 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		GLRO(dl_hwcap) = 0;
+	    }
+	    else
+	    {
+		cpuid(1, &val, &hwcap);
+		GLRO(dl_hwcap) = hwcap;
+		switch (val & 0xf00)
+		{
+		case 0x400: /* 486 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+		break;
+		case 0x500: /* 586 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[2];
+		break;
+		default:    /* 686 */
+			GLRO(dl_platform) = GLRO(dl_x86_platforms)[3];
+		}
+            }
+	}
+}
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-procinfo.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/dl-procinfo.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/get_clockfreq.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/get_clockfreq.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movl 0(%esp), %ecx	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addl $4, %esp		/* remove stale return address */
+        jmp  *%ecx
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_get_ioperm (unsigned long int from, unsigned long int *num, int *turned_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+
+  if (__sysarch (I386_GET_IOPERM, &args) < 0)
+    return -1;
+
+  *num = args.length;
+  *turned_on = args.enable;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+int
+i386_get_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_GET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_set_ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+  args.length = num;
+  args.enable = turn_on;
+
+  return __sysarch (I386_SET_IOPERM, &args);
+}
+
+strong_alias (i386_set_ioperm, ioperm)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <machine/sysarch.h>
+
+int
+i386_set_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_SET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/vm86.h>
+#include <sysarch.h>
+
+int
+i386_vm86 (int cmd, void *arg)
+{
+  struct i386_vm86_args args;
+
+  args.sub_op = cmd;
+  args.sub_args = arg;
+
+  return __sysarch (I386_VM86, &args);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i486/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i586/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i686/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>	/* open */
+#include <unistd.h>	/* close */
+
+static int __iopl_fd = -1;
+
+int
+iopl (int level)
+  {
+    switch (level)
+      {
+        case 3:
+          if (__iopl_fd != -1)
+            return 0;
+
+          __iopl_fd = __open ("/dev/io", O_RDWR);
+          if (__iopl_fd == -1)
+            {
+              if (errno == EACCES)
+                __set_errno (EPERM);
+              return -1;
+            }
+          return 0;
+
+        case 0:
+          if (__iopl_fd != -1)
+            if (__close (__iopl_fd) == -1)
+              return 1;
+          return 0;
+
+        default:
+          __set_errno (EINVAL);
+          return -1;
+      }
+  }
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldconfig.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/pt-machine.h
@@ -0,0 +1,76 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   ix86 version for FreeBSD.
+   Copyright (C) 1996-2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _FREEBSD_PT_MACHINE_H
+#define _FREEBSD_PT_MACHINE_H   1
+
+/*
+  some parts are common with linux/i386 version
+
+  linux specific parts should be in
+  linuxthreads/sysdeps/unix/sysv/linux/i386/
+  but they are included directly in
+  linuxthreads/sysdeps/i386/
+
+  so include them
+
+ */
+
+#include <linuxthreads/sysdeps/i386/pt-machine.h>
+#include <linuxthreads/sysdeps/i386/useldt.h>
+
+/* hack them */
+
+#ifndef __ASSEMBLER__
+
+#undef INIT_THREAD_SELF
+#undef FREE_THREAD
+
+/* The P4 and above really want some help to prevent overheating.  */
+#define BUSY_WAIT_NOP   __asm__ ("rep; nop")
+
+/* and add few FreeBSD specifics */
+
+#include <sysarch.h>
+
+/* Initialize the thread-unique value. */
+
+#define INIT_THREAD_SELF(descr, nr)		\
+{						\
+  long tmp;					\
+  tmp = (long) descr;				\
+  if (sysarch(I386_SET_GSBASE, &tmp)  != 0)	\
+  {						\
+    abort();					\
+  }						\
+}
+
+#define FREE_THREAD(descr, nr) do { } while (0)
+
+#endif /* __ASSEMBLER__ */
+
+/* We want the OS to assign stack addresses.  */
+#define FLOATING_STACKS 1
+
+/* Maximum size of the stack if the rlimit is unlimited.  */
+#define ARCH_STACK_MAX_SIZE     8*1024*1024
+
+#endif /* _FREEBSD_PT_MACHINE_H  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/sysdep-cancel.h
@@ -0,0 +1,166 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+   Modification for FreeBSD by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include <pt-machine.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    CENABLE								      \
+    movl %eax, %ecx;							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80;								      \
+    PUSHRESULT;							      	      \
+    movl %ecx, %eax; 							      \
+    CDISABLE;							 	      \
+    POPRESULT;							      	      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+/*
+  on FreeBSD some syscalls return result in pair edx+eax,
+  therefore proper way would be
+
+# define PUSHRESULT	pushl %edx; pushl %eax; pushfl
+# define POPRESULT	popfl; popl %eax; popl %edx
+
+  for FreeBSD 5.4 affected syscalls are
+
+	lseek()
+	fork()
+	vfork()
+	rfork()
+	pipe()
+
+   none of them is cancelable, therefore
+*/
+
+# define PUSHRESULT	pushl %eax; cfi_adjust_cfa_offset (4);  pushfl;    cfi_adjust_cfa_offset (4)
+# define POPRESULT	popfl;      cfi_adjust_cfa_offset (-4); popl %eax; cfi_adjust_cfa_offset (-4)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel
+# elif defined IS_IN_librt
+#  ifdef PIC
+#   define CENABLE	pushl %ebx; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (ebx, 0); \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_enable_asynccancel@PLT; \
+			popl %ebx; \
+			cfi_adjust_cfa_offset (-4); \
+			cfi_restore (ebx);
+#   define CDISABLE	pushl %ebx; \
+			cfi_adjust_cfa_offset (4); \
+			cfi_rel_offset (ebx, 0); \
+			call __i686.get_pc_thunk.bx; \
+			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
+			call __librt_disable_asynccancel@PLT; \
+			popl %ebx; \
+			cfi_adjust_cfa_offset (-4); \
+			cfi_restore (ebx);
+#  else
+#   define CENABLE	call __librt_enable_asynccancel;
+#   define CDISABLE	call __librt_disable_asynccancel
+#  endif
+# else
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel
+# endif
+
+#if !defined NOT_IN_libc
+# define __local_multiple_threads __libc_multiple_threads
+#elif defined IS_IN_libpthread
+# define __local_multiple_threads __pthread_multiple_threads
+#else
+# define __local_multiple_threads __librt_multiple_threads
+#endif
+
+# ifndef __ASSEMBLER__
+#  if defined FLOATING_STACKS && USE___THREAD && defined PIC
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
+				   p_header.data.multiple_threads) == 0, 1)
+#  else
+extern int __local_multiple_threads
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+  attribute_hidden;
+#   else
+  ;
+#   endif
+#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+#  endif
+# else
+#  if !defined PIC
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads
+#  elif defined FLOATING_STACKS && USE___THREAD
+#   define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
+#  else
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+#    define __SINGLE_THREAD_CMP cmpl $0, __local_multiple_threads@GOTOFF(%ecx)
+#   else
+#    define __SINGLE_THREAD_CMP \
+  movl __local_multiple_threads@GOT(%ecx), %ecx;\
+  cmpl $0, (%ecx)
+#   endif
+#   if !defined HAVE_HIDDEN || !USE___THREAD
+#    define SINGLE_THREAD_P \
+  SETUP_PIC_REG (cx);				\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   else
+#    define SINGLE_THREAD_P \
+  call __i686.get_pc_thunk.cx;			\
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
+  __SINGLE_THREAD_CMP
+#   endif
+#  endif
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+                                     p_header.data.multiple_threads) == 0, 1)
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/tls.h
@@ -0,0 +1,93 @@
+/* Definition for thread-local data handling.  linuxthreads/i386 version.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <linuxthreads/sysdeps/i386/tls.h>
+
+/* We can support TLS only if the floating-stack support is available.
+   To avoid bothering with the TLS support code at all,
+   use configure --without-tls.
+
+   We need USE_TLS to be consistently defined, for ldsodefs.h conditionals.
+   But some of the code below can cause problems in building libpthread
+*/
+
+#if defined HAVE_TLS_SUPPORT \
+    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+
+# ifndef __ASSEMBLER__
+
+#undef TLS_INIT_TP
+#undef TLS_SETUP_GS_SEGMENT
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched. */
+
+#  define TLS_DO_SET_GSBASE(descr)		\
+({                                      	\
+  long base = (long) descr;             	\
+  int result;                           	\
+  asm volatile (                        	\
+                "pushl %3\n\t"          	\
+                "pushl %2\n\t"          	\
+                "pushl %1\n\t"       		\
+                "int $0x80\n\t"         	\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                : "=a" (result)         	\
+                : "0" (SYS_sysarch),     	\
+                  "i" (I386_SET_GSBASE),       	\
+                  "d" (&base)			\
+                : "memory", "cc" );    		\
+  result;                                       \
+})
+
+#   define TLS_SETUP_GS_SEGMENT(descr, secondcall)                            \
+  (TLS_DO_SET_GSBASE(descr)                                                   \
+   ? "set_thread_area failed when setting up thread-local storage\n" : NULL)
+
+/*   The value of this macro is null if successful, or an error string.  */
+
+#  define TLS_INIT_TP(descr, secondcall)				      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    INIT_SYSINFO;							      \
+    TLS_SETUP_GS_SEGMENT (_descr, secondcall);				      \
+  })
+
+# endif /* __ASSEMBLER__ */
+
+#endif	/* HAVE_TLS_SUPPORT && (FLOATING_STACKS || !IS_IN_libpthread) */
+
+#endif	/* _FREEBSD_TLS_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/linuxthreads/vfork.S
@@ -0,0 +1,69 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+# ifdef SHARED
+	call	__i686.get_pc_thunk.cx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ecx
+	cmpl	$0, __libc_pthread_functions@GOTOFF(%ecx)
+# else
+	.weak	pthread_create
+	movl	$pthread_create, %eax
+	testl	%eax, %eax
+# endif
+	jne	HIDDEN_JUMPTARGET (__fork)
+
+	/* Pop the return PC value into ECX.  */
+	popl	%ecx
+	cfi_adjust_cfa_offset(-4)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %edx == 0, %eax == child pid.  */
+	/* In the child process, %edx == 1, %eax == parent pid.  */
+
+	/* Change %eax to be 0 in the child process.  */
+	decl	%edx
+	andl	%edx, %eax
+
+	/* Jump to the return PC.  */
+	jmp	*%ecx
+
+L(error):
+	/* Push back the return PC.  */
+	pushl	%ecx
+	cfi_adjust_cfa_offset(4)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S
@@ -0,0 +1,113 @@
+/* Create new context.
+   Copyright (C) 2001,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include <ucontext_i.h>
+
+
+ENTRY(__makecontext)
+	movl	4(%esp), %eax
+
+	/* Load the address of the function we are supposed to run.  */
+	movl	8(%esp), %ecx
+
+	/* Compute the address of the stack.  The information comes from
+	   to us_stack element.  */
+	movl	oSS_SP(%eax), %edx
+	movl	%ecx, oEIP(%eax)
+	addl	oSS_SIZE(%eax), %edx
+
+	/* Put the next context on the new stack (from the uc_link
+	   element).  */
+	movl	oLINK(%eax), %ecx
+	movl	%ecx, -4(%edx)
+
+	/* Remember the number of parameters for the exit handler since
+	   it has to remove them.  We store the number in the EBX register
+	   which the function we will call must preserve.  */
+	movl	12(%esp), %ecx
+	movl	%ecx, oEBX(%eax)
+
+	/* Make room on the new stack for the parameters.  */
+	negl	%ecx
+	leal	-8(%edx,%ecx,4), %edx
+	negl	%ecx
+	/* Store the future stack pointer.  */
+	movl	%edx, oESP(%eax)
+
+	/* Copy all the parameters.  */
+	jecxz	2f
+1:	movl	12(%esp,%ecx,4), %eax
+	movl	%eax, (%edx,%ecx,4)
+	decl	%ecx
+	jnz	1b
+2:
+
+	/* If the function we call returns we must continue with the
+	   context which is given in the uc_link element.  To do this
+	   set the return address for the function the user provides
+	   to a little bit of helper code which does the magic (see
+	   below).  */
+#ifdef PIC
+	call	1f
+1:	popl	%ecx
+	addl	$L(exitcode)-1b, %ecx
+	movl	%ecx, (%edx)
+#else
+	movl	$L(exitcode), (%edx)
+#endif
+	/* 'makecontext' returns no value.  */
+	ret
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+L(exitcode):
+	/* This removes the parameters passed to the function given to
+	   'makecontext' from the stack.  EBX contains the number of
+	   parameters (see above).  */
+	leal	(%esp,%ebx,4), %esp
+
+#ifdef	PIC
+	call	1f
+1:	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %ebx
+#endif
+	popl	%eax			/* This is the next context.  */
+	testl	%eax, %eax
+	je	2f			/* If it is zero exit.  */
+
+	pushl	%eax
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+2:	pushl	%eax
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into ECX,
+	   preserve stack frame with argument  */
+	movl 0(%esp), %ecx;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl %edx
+	andl %edx, %eax
+
+	popl %edx
+	cfi_adjust_cfa_offset(-4)
+	jmp  *%ecx
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_eip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_ebp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_esp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S
@@ -0,0 +1,207 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+#define SIG_SETMASK	3
+
+	.text
+ENTRY (__start_thread)
+	/* End FDE now, because in the child the unwind info will be
+	   wrong.  */
+	cfi_endproc
+
+	/* There is a window of a few instructions, right after the rfork
+	   system call, where the handling of a signal would write garbage
+	   into the stack shared by the parent and the child (assuming
+	   RFMEM is set in flags).  To solve this: 1. We block all signals
+	   around the rfork system call and unblock them afterwards in
+	   the parent and in the child (but only after changing the stack
+	   pointer).  2. The child accesses only values passed in registers
+	   and on its own stack.  This way, if the parent is scheduled to
+	   run first, and handles a signal, it will not affect the child;
+	   and if the child runs first, and handles a signal, it will use
+	   the child's stack and not affect the parent.
+	   We need to pass 7 words of info to the child: stack, func, arg,
+	   and the signal mask to restore.  Since we have only 4 call-saved
+	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
+	   stack pointer in a register, and the rest through the child's
+	   stack.  */
+	pushl	%ebp
+	movl	%esp, %ebp
+	subl	$36, %esp
+	movl	%ebx, 32(%esp)
+
+	movl	8(%ebp), %eax	/* flags */
+	testl	$32, %eax	/* flags & RFMEM */
+	jz	L(simple)
+
+	/* Block all signals.  */
+	movl	$-1, %eax
+	movl	%eax, 16(%esp)
+	movl	%eax, 20(%esp)
+	movl	%eax, 24(%esp)
+	movl	%eax, 28(%esp)
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	%eax, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+	jb	L(error)
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$32, %ebx	/* room for func, arg, sigset_t */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+	movl	16(%esp), %eax	/* sigset_t word 0 */
+	movl	20(%esp), %edx	/* sigset_t word 1 */
+	movl	%eax, 16(%ebx)
+	movl	%edx, 20(%ebx)
+	movl	24(%esp), %eax	/* sigset_t word 2 */
+	movl	28(%esp), %edx	/* sigset_t word 3 */
+	movl	%eax, 24(%ebx)
+	movl	%edx, 28(%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error_unmask)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(child)
+
+	/* Save the child pid, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* Return the child pid, currently in %ebx.  */
+	movl	%ebx, %eax
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	ret
+
+L(child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+L(child1):
+	/* Call func (arg).  */
+	call	*%edi
+
+	/* Call _exit.  */
+#ifdef PIC
+	call	L(here)
+L(here):
+	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-L(here)], %ebx
+#endif
+	pushl	%eax
+	call	HIDDEN_JUMPTARGET (_exit)
+
+L(simple):/* Simple case without signal mask handling.  */
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$8, %ebx	/* room for func, arg */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(simple_child)
+
+	/* Return the child pid, currently in %eax.  */
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+L(pseudo_end):
+	ret
+
+L(simple_child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	jmp	L(child1)
+
+L(error_unmask):
+
+	/* Save the error code, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+	movl	%ebx, %eax
+
+L(error):
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	jmp	SYSCALL_ERROR_LABEL
+	cfi_startproc
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h
@@ -0,0 +1,184 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#ifdef _MACHINE_CPUFUNC_H_
+#error "This header must not be used in combination with <machine/cpufunc.h>."
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all kFreeBSD platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however. */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set port input/output permissions.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+extern int i386_set_ioperm (unsigned long int __from, unsigned long int __num,
+			    int __turn_on) __THROW;
+
+/* Retrieve a contiguous range of port input/output permissions.  */
+extern int i386_get_ioperm (unsigned long int __from, unsigned long int *__num,
+			    int *__turned_on) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_VM86_H
+#define _SYS_VM86_H	1
+
+#include <features.h>
+
+/* Possible values for the 'cmd' argument to i386_vm86.  */
+enum
+  {
+    VM86_INIT = 1,
+#define VM86_INIT VM86_INIT
+    VM86_GET_VME = 3
+#define VM86_GET_VME VM86_GET_VME
+  };
+
+/* Argument structure for VM86_INIT.  */
+struct vm86_init_args
+  {
+    int debug;
+    int cpu_type;
+    unsigned char int_map[32];
+  };
+
+/* Argument structure for VM86_GET_VME.  */
+struct vm86_vme_args
+  {
+    int state;
+  };
+
+__BEGIN_DECLS
+
+extern int i386_vm86 (int __cmd, void *__arg);
+
+__END_DECLS
+
+#endif	/* _SYS_VM86_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_fork.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl r1
+	andl r1, r0
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_freebsd6_lseek.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* lseek returns a 64-bit result in %eax, %edx.  This means that in the
+   error case we have to set both %eax and %edx to -1.  */
+
+PSEUDO_NOERRNO(__syscall_freebsd6_lseek, freebsd6_lseek, 4)
+        jnb L(no_error)
+	call SYSCALL_ERROR_LABEL;
+	orl $-1, %edx;
+L(pseudo_end):
+L(no_error):
+	ret
+PSEUDO_END(__syscall_freebsd6_lseek)
+libc_hidden_def (__syscall_freebsd6_lseek)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_lseek.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* lseek returns a 64-bit result in %eax, %edx.  This means that in the
+   error case we have to set both %eax and %edx to -1.  */
+
+PSEUDO_NOERRNO(__syscall_lseek, lseek, 3)
+        jnb L(no_error)
+	call SYSCALL_ERROR_LABEL;
+	orl $-1, %edx;
+L(pseudo_end):
+L(no_error):
+	ret
+PSEUDO_END(__syscall_lseek)
+libc_hidden_def (__syscall_lseek)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h
@@ -0,0 +1,81 @@
+/* Parameters for the architecture specific system call.  i386 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    I386_GET_LDT = 0,
+#define I386_GET_LDT I386_GET_LDT
+    I386_SET_LDT = 1,
+#define I386_SET_LDT I386_SET_LDT
+    I386_GET_IOPERM = 3,
+#define I386_GET_IOPERM I386_GET_IOPERM
+    I386_SET_IOPERM = 4,
+#define I386_SET_IOPERM I386_SET_IOPERM
+    I386_VM86 = 6,
+#define I386_VM86 I386_VM86
+    I386_GET_FSBASE = 7,
+#define I386_GET_FSBASE I386_GET_FSBASE
+    I386_SET_FSBASE = 8,
+#define I386_SET_FSBASE I386_SET_FSBASE
+    I386_GET_GSBASE = 9,
+#define I386_GET_GSBASE I386_GET_GSBASE
+    I386_SET_GSBASE = 10
+#define I386_SET_GSBASE I386_SET_GSBASE
+  };
+
+/* Argument struct for I386_GET_LDT and I386_SET_LDT.  */
+struct i386_ldt_args
+  {
+    int start;
+    union descriptor *descs;
+    int num;
+  };
+
+/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
+struct i386_ioperm_args
+  {
+    unsigned int start;
+    unsigned int length;
+    int enable;
+  };
+
+/* Argument struct for I386_VM86.  */
+struct i386_vm86_args
+  {
+    int sub_op;
+    void *sub_args;
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1993, 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	  .text;
+ENTRY (__syscall)
+	popl %ecx		/* Pop return address into %ecx.  */
+	cfi_adjust_cfa_offset (-4)
+	movl 0(%esp), %eax	/* Load syscall number into %eax. */
+	int $0x80		/* Do the system call.  */
+	pushl %ecx		/* Push back return address.  */
+	cfi_adjust_cfa_offset (4)
+	jb SYSCALL_ERROR_LABEL;	/* Jump to error handler if error.  */
+
+L(pseudo_end):
+	ret			/* Return to caller.  */
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls-internal.h
@@ -0,0 +1,88 @@
+/* generally used "internal syscalls"
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INTERNAL_SYSCALLS_H
+#define KFREEBSD_INTERNAL_SYSCALLS_H
+
+#include <sys/syscall.h>
+
+/* 
+   for now, we do not care whether syscall succeeded,
+   we do not have defined 
+   INTERNAL_SYSCALL_ERROR_P and INTERNAL_SYSCALL_ERRNO
+   we do not store errno at all
+   to be sure, we return void
+*/
+
+#undef INTERNAL_SYSCALL_DECL
+#undef INTERNAL_SYSCALL_NCS
+#undef INTERNAL_SYSCALL
+#undef INTERNAL_SYSCALL_ERROR_P
+#undef INTERNAL_SYSCALL_ERRNO
+
+#define INTERNAL_SYSCALL_DECL(err)		\
+  do { } while (0)
+
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_##name(name, err, nr, ##args)
+     
+     
+#define INTERNAL_SYSCALL_close(name, err, nr, fd) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int result;			\
+  asm volatile (                                \
+                "pushl %2\n\t"                  \
+                "pushl %1\n\t"                  \
+                "int $0x80\n\t"                 \
+                "popl %2\n\t"                   \
+                "popl %2\n\t"                   \
+                : "=a" (result)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "d" (_a1)                   	\
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_writev(name, err, nr, fd, iov, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (iov);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (                                \
+                "pushl %5\n\t"                  \
+                "pushl %4\n\t"                  \
+                "pushl %3\n\t"                  \
+                "pushl %2\n\t"                  \
+                "int $0x80\n\t"                 \
+                "addl $16,%%esp\n\t"		\
+                : "=a" (result),		\
+                  "=d" (_trash)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "ri" (_a1),			\
+                  "ri" (_a2),			\
+                  "ri" (_a3)			\
+              /*   may be even "g" constraint could be used */ \
+              /*   but we have to worry about esp register and esp based address */ \
+                : "memory", "cc" );             \
+  result;                                       \
+})
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   its own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for FreeBSD is identical to the canonical Unix/i386 code.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %eax.  */
+
+	.text
+ENTRY (__syscall_error)
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/i386/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h
@@ -0,0 +1,240 @@
+/* Copyright (C) 1992,1993,1995-2000,2002,2003,2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper, <drepper@gnu.org>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_I386_SYSDEP_H
+#define _FREEBSD_I386_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/i386/sysdep.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
+#include <tls.h>
+
+#if defined __i686 && defined __ASSEMBLER__
+#undef __i686
+#define __i686 __i686
+#endif
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#define ret_NOERRNO ret
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#else
+
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl %eax, rtld_errno@GOTOFF(%ecx);					      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+
+# elif defined _LIBC_REENTRANT
+
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno
+#   else
+#    define SYSCALL_ERROR_ERRNO errno
+#   endif
+#   define SYSCALL_ERROR_HANDLER					      \
+0:SETUP_PIC_REG (cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl SYSCALL_ERROR_ERRNO@GOTNTPOFF(%ecx), %ecx;			      \
+  SYSCALL_ERROR_HANDLER_TLS_STORE (%eax, %ecx);				      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+#   ifndef NO_TLS_DIRECT_SEG_REFS
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  movl src, %gs:(destoff)
+#   else
+#    define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  addl %gs:0, destoff;							      \
+  movl src, (destoff)
+#   endif
+#  else
+#   define SYSCALL_ERROR_HANDLER					      \
+0:pushl %ebx;								      \
+  cfi_adjust_cfa_offset (4);                                                  \
+  cfi_rel_offset (ebx, 0);                                                    \
+  SETUP_PIC_REG (bx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ebx;					      \
+  pushl %eax;								      \
+  cfi_adjust_cfa_offset (4);                                                  \
+  PUSH_ERRNO_LOCATION_RETURN;						      \
+  call BP_SYM (__errno_location)@PLT;					      \
+  POP_ERRNO_LOCATION_RETURN;						      \
+  popl %ecx;								      \
+  cfi_adjust_cfa_offset (-4);                                                 \
+  popl %ebx;								      \
+  cfi_adjust_cfa_offset (-4);                                                 \
+  cfi_restore (ebx);                                                          \
+  movl %ecx, (%eax);							      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+#  endif
+# else
+/* Store (%eax) into errno through the GOT.  */
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl errno@GOT(%ecx), %ecx;						      \
+  movl %eax, (%ecx);							      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+# endif	/* _LIBC_REENTRANT */
+#endif	/* PIC */
+
+/*
+    FreeBSD expects the system call arguments on the stack,
+   syscall number is in %eax.
+   return value is in %eax + %edx
+   error is signaled via cflags.
+   all other data registers are preserved
+
+	syscall number	%eax	     call-clobbered
+
+   The stack layout upon entering the function is:
+
+	20(%esp)	Arg# 5
+	16(%esp)	Arg# 4
+	12(%esp)	Arg# 3
+	 8(%esp)	Arg# 2
+	 4(%esp)	Arg# 1
+	  (%esp)	Return address
+
+   (Of course a function with say 3 arguments does not have entries for
+   arguments 4 and 5.)
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)			      		      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80								      \
+
+#else	/* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+/* Consistency check for position-independent code.  */
+#ifdef __PIC__
+# define check_consistency()						      \
+  ({ int __res;								      \
+     __asm__ __volatile__						      \
+       ("call __i686.get_pc_thunk.cx;"					      \
+	"addl $_GLOBAL_OFFSET_TABLE_, %%ecx;"				      \
+	"subl %%ebx, %%ecx;"						      \
+	"je 1f;"							      \
+	"ud2;"								      \
+	"1:\n"								      \
+	".section .gnu.linkonce.t.__i686.get_pc_thunk.cx,\"ax\",@progbits;"   \
+	".globl __i686.get_pc_thunk.cx;"				      \
+	".hidden __i686.get_pc_thunk.cx;"				      \
+	".type __i686.get_pc_thunk.cx,@function;"			      \
+	"__i686.get_pc_thunk.cx:"					      \
+	"movl (%%esp), %%ecx;"						      \
+	"ret;"								      \
+	".previous"							      \
+	: "=c" (__res));						      \
+     __res; })
+#endif
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if defined NOT_IN_libc && defined IS_IN_rtld
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  Using a global variable
+   is too complicated here since we have no PC-relative addressing mode.  */
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorl %gs:POINTER_GUARD, reg;		      \
+				roll $9, reg
+#  define PTR_DEMANGLE(reg)	rorl $9, reg;				      \
+				xorl %gs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorl %%gs:%c2, %0\n"		      \
+				     "roll $9, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorl $9, %0\n"			      \
+				     "xorl %%gs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _FREEBSD_I386_SYSDEP_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets and other constants needed in the *context() function
+   implementation.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure.  */
+#define oSIGMASK	0
+#define oGS		20
+#define oFS		24
+#define oEDI		36
+#define oESI		40
+#define oEBP		44
+#define oEBX		52
+#define oEDX		56
+#define oECX		60
+#define oEAX		64
+
+#define oEIP		76
+#define oESP		88
+
+#define oLINK		656
+#define oSS_SP		660
+#define oSS_SIZE	664
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S
@@ -0,0 +1,58 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into ECX.  */
+	popl	%ecx
+	cfi_adjust_cfa_offset(-4)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %edx == 0, %eax == child pid.  */
+	/* In the child process, %edx == 1, %eax == parent pid.  */
+
+	/* Change %eax to be 0 in the child process.  */
+	decl	%edx
+	andl	%edx, %eax
+
+	/* Jump to the return PC.  */
+	jmp	*%ecx
+
+L(error):
+	/* Push back the return PC.  */
+	pushl	%ecx
+	cfi_adjust_cfa_offset(4)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c
@@ -0,0 +1,311 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <net/if.h>
+#include <sys/sysctl.h>
+#include <sys/socket.h>
+#include <net/route.h>
+#include <net/if_dl.h>
+#include <alloca.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+
+typedef int (*if_fn) (void *private, unsigned int index, const char *name);
+
+/* Iterate through all present interfaces.
+   Call FN once for every interface, returning immediately if FN returns
+   a nonzero value.  */
+static void
+if_iterate (if_fn fn, void *private)
+{
+  int request[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
+  char *buf;
+  size_t bufsize = 512;
+  char *bufend;
+  char *p;
+
+  /* Call the kernel function sysctl_iflist() in /usr/src/sys/net/rtsock.c.  */
+  for (;;)
+    {
+      buf = alloca (bufsize);
+      if (__sysctl (request, 6, buf, &bufsize, NULL, 0) >= 0)
+	break;
+      if (errno != ENOMEM)
+	return;
+      bufsize *= 2;
+    }
+
+  bufend = buf + bufsize;
+  for (p = buf; p < bufend; )
+    {
+      struct if_msghdr *msg = (struct if_msghdr *) p;
+
+      if (msg->ifm_version != RTM_VERSION)
+	abort ();
+
+      switch (msg->ifm_type)
+	{
+	case RTM_IFINFO:
+	  if (msg->ifm_addrs & RTA_IFP)
+	    {
+	      unsigned int index;
+	      struct sockaddr_dl *sdl;
+	      char namebuf[IFNAMSIZ + 1];
+	      size_t namelen;
+
+	      index = msg->ifm_index;
+	      if (index == 0)
+		abort ();
+
+	      /* FIXME: 'struct if_msghdr' contains a 'struct if_data' which in turns
+	         contains 'unsigned long' values. Their size therefore depends on
+		 the running kernel (32 or 64 bits). This should be fixed in the
+		 compat layer of the kernel. Meanwhile just workaround the bug here/ */
+#if 0
+	      sdl = (struct sockaddr_dl *) (msg + 1);
+#else
+	      sdl = (struct sockaddr_dl *) (p + msg->ifm_msglen - sizeof(struct sockaddr_dl) - 2);
+#endif
+	      namelen = sdl->sdl_nlen;
+	      /* Avoid overflowing namebuf[].  */
+	      if (namelen > IFNAMSIZ)
+		namelen = IFNAMSIZ;
+	      memcpy (namebuf, sdl->sdl_data, namelen);
+	      namebuf[namelen] = '\0';
+
+	      /* Call FN now.  */
+	      if (fn (private, index, namebuf))
+		return;
+	    }
+	  break;
+
+	case RTM_NEWADDR:
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      p += msg->ifm_msglen;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+struct nametoindex_locals
+  {
+    const char *name;
+    unsigned int index;
+  };
+
+static int
+nametoindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nametoindex_locals *l = (struct nametoindex_locals *) private;
+  if (strcmp (name, l->name) == 0)
+    {
+      l->index = index;
+      return 1;
+    }
+  return 0;
+}
+
+/* Return the index of an interface given by name.  */
+unsigned int
+if_nametoindex (const char *ifname)
+{
+  struct nametoindex_locals l;
+
+  l.name = ifname;
+  l.index = 0;
+  if_iterate (nametoindex_aux, &l);
+
+  return l.index;
+}
+libc_hidden_def (if_nametoindex)
+
+/* ------------------------------------------------------------------------- */
+
+struct indextoname_locals
+  {
+    unsigned int index;
+    char *name;
+    char *retval;
+  };
+
+static int
+indextoname_aux (void *private, unsigned int index, const char *name)
+{
+  struct indextoname_locals *l = (struct indextoname_locals *) private;
+  if (index == l->index)
+    {
+      strncpy (l->name, name, IF_NAMESIZE);
+      l->retval = l->name;
+      return 1;
+    }
+  __set_errno (ENXIO);
+  return 0;
+}
+
+/* Return the name of an interface given by name.  */
+char *
+if_indextoname (unsigned int ifindex, char *ifname)
+{
+  struct indextoname_locals l;
+
+  l.index = ifindex;
+  l.name = ifname;
+  l.retval = NULL;
+  if_iterate (indextoname_aux, &l);
+  return l.retval;
+}
+libc_hidden_def (if_indextoname)
+
+/* ------------------------------------------------------------------------- */
+
+struct nameindex_locals
+  {
+    /* Resizable array of 'struct if_nameindex'.  */
+    struct if_nameindex *s_array;
+    size_t s_len;
+    size_t s_allocated;
+    /* Resizable array of char.  */
+    char *c_array;
+    size_t c_len;
+    size_t c_allocated;
+    /* Out-of-memory indicator.  */
+    int oom;
+  };
+
+static void
+add_s (struct nameindex_locals *l, unsigned int index, char *name)
+{
+  if (l->s_len == l->s_allocated)
+    {
+      size_t new_allocated = 2 * l->s_allocated + 1;
+      struct if_nameindex *new_array =
+	(struct if_nameindex *)
+	realloc (l->s_array, new_allocated * sizeof (struct if_nameindex));
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return;
+	}
+      l->s_array = new_array;
+      l->s_allocated = new_allocated;
+    }
+  /* Now l->s_len < l->s_allocated.  */
+  l->s_array[l->s_len].if_index = index;
+  l->s_array[l->s_len].if_name = name;
+  l->s_len++;
+}
+
+static __inline size_t
+add_c (struct nameindex_locals *l, const char *name)
+{
+  size_t n = strlen (name) + 1;
+  size_t result_offset;
+  if (l->c_len + n > l->c_allocated)
+    {
+      size_t new_allocated =
+	(l->c_len + n < 2 * l->c_allocated + 1
+	 ? 2 * l->c_allocated + 1
+	 : l->c_len + n);
+      char *new_array = (char *) realloc (l->c_array, new_allocated);
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return 0;
+	}
+      l->c_array = new_array;
+      l->c_allocated = new_allocated;
+    }
+  /* Now l->c_len + n <= l->c_allocated.  */
+  result_offset = l->c_len;
+  memcpy (l->c_array + l->c_len, name, n);
+  l->c_len += n;
+  return result_offset;
+}
+
+static int
+nameindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nameindex_locals *l = (struct nameindex_locals *) private;
+
+  size_t name_offset = add_c (l, name);
+  if (!l->oom)
+    {
+      add_s (l, index, (char *) NULL + name_offset);
+      if (!l->oom)
+	return 0;
+    }
+  return 1;
+}
+
+/* Return an array of 'struct if_nameindex', one for each present
+   interface.  */
+struct if_nameindex *
+if_nameindex (void)
+{
+  struct nameindex_locals l;
+
+  l.s_array = NULL; l.s_len = 0; l.s_allocated = 0;
+  l.c_array = NULL; l.c_len = 0; l.c_allocated = 0;
+  l.oom = 0;
+  if_iterate (nameindex_aux, &l);
+  if (!l.oom)
+    {
+      /* Convert all offsets to real pointers.  */
+      struct if_nameindex *p;
+      struct if_nameindex *p_end;
+
+      for (p = l.s_array, p_end = p + l.s_len; p < p_end; p++)
+	p->if_name = l.c_array + (p->if_name - (char *) NULL);
+
+      /* Add a terminating entry.  */
+      add_s (&l, 0, NULL);
+    }
+  if (l.oom)
+    {
+      free (l.s_array);
+      free (l.c_array);
+      __set_errno (ENOMEM);
+      return NULL;
+    }
+  return l.s_array;
+}
+libc_hidden_def (if_nameindex)
+
+/* ------------------------------------------------------------------------- */
+
+/* Free an array returned by if_nameindex().  */
+void
+if_freenameindex (struct if_nameindex *ifn)
+{
+  if (ifn != NULL)
+    {
+      /* Free c_array.  */
+      free (ifn[0].if_name);
+      /* Free s_array.  */
+      free (ifn);
+    }
+}
+libc_hidden_def (if_freenameindex)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifaddrs.c
@@ -0,0 +1,362 @@
+/*	$KAME: getifaddrs.c,v 1.9 2001/08/20 02:31:20 itojun Exp $	*/
+
+/*
+ * Copyright (c) 1995, 1999
+ *	Berkeley Software Design, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	BSDI getifaddrs.c,v 2.12 2000/02/23 14:51:59 dab Exp
+ */
+
+#include <sys/cdefs.h>
+
+ /*
+__FBSDID("$FreeBSD: src/lib/libc/net/getifaddrs.c,v 1.6 2002/07/25 08:08:30 ume Exp $");
+ */
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/sysctl.h>
+#include <net/if.h>
+
+#ifdef	NET_RT_IFLIST
+#include <sys/param.h>
+#include <net/route.h>
+#include <sys/sysctl.h>
+#include <net/if_dl.h>
+#else
+#error NET_RT_IFLIST is required
+#endif
+
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if !defined(AF_LINK)
+#define	SA_LEN(sa)	sizeof(struct sockaddr)
+#endif
+
+#if !defined(SA_LEN)
+#define	SA_LEN(sa)	(sa)->sa_len
+#endif
+
+#define	SALIGN	(sizeof(long) - 1)
+#define	SA_RLEN(sa)	((sa)->sa_len ? (((sa)->sa_len + SALIGN) & ~SALIGN) : (SALIGN + 1))
+
+#ifndef	ALIGNBYTES
+/*
+ * On systems with a routing socket, ALIGNBYTES should match the value
+ * that the kernel uses when building the messages.
+ */
+#define	ALIGNBYTES	XXX
+#endif
+#ifndef	ALIGN
+#define	ALIGN(p)	(((u_long)(p) + ALIGNBYTES) &~ ALIGNBYTES)
+#endif
+
+#define	HAVE_IFM_DATA
+#define MAX_SYSCTL_TRY 5
+
+int
+getifaddrs(struct ifaddrs **pif)
+{
+	int icnt = 1;
+	int dcnt = 0;
+	int ncnt = 0;
+#ifdef	NET_RT_IFLIST
+	int ntry = 0;
+	int mib[6];
+	size_t needed;
+	char *buf;
+	char *next;
+	struct ifaddrs *cif = 0;
+	char *p, *p0;
+	struct rt_msghdr *rtm;
+	struct if_msghdr *ifm;
+	struct ifa_msghdr *ifam;
+	struct sockaddr_dl *dl;
+	struct sockaddr *sa;
+	struct ifaddrs *ifa, *ift;
+	u_short idx = 0;
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	int i;
+	size_t len, alen;
+	char *data;
+	char *names;
+
+#ifdef	NET_RT_IFLIST
+	mib[0] = CTL_NET;
+	mib[1] = PF_ROUTE;
+	mib[2] = 0;             /* protocol */
+	mib[3] = 0;             /* wildcard address family */
+	mib[4] = NET_RT_IFLIST;
+	mib[5] = 0;             /* no flags */
+	do {
+		/*
+		 * We'll try to get addresses several times in case that
+		 * the number of addresses is unexpectedly increased during
+		 * the two sysctl calls.  This should rarely happen, but we'll
+		 * try to do our best for applications that assume success of
+		 * this library (which should usually be the case).
+		 * Portability note: since FreeBSD does not add margin of
+		 * memory at the first sysctl, the possibility of failure on
+		 * the second sysctl call is a bit higher.
+		 */
+
+		if (__sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
+			return (-1);
+		if ((buf = malloc(needed)) == NULL)
+			return (-1);
+		if (__sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
+			if (errno != ENOMEM || ++ntry >= MAX_SYSCTL_TRY) {
+				free(buf);
+				return (-1);
+			}
+			free(buf);
+			buf = NULL;
+		}
+	} while (buf == NULL);
+
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				++icnt;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+				dcnt += SA_RLEN((struct sockaddr *)(void*)dl) +
+				    ALIGNBYTES;
+#ifdef	HAVE_IFM_DATA
+				dcnt += sizeof(ifm->ifm_data);
+#endif	/* HAVE_IFM_DATA */
+				ncnt += dl->sdl_nlen + 1;
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+#define	RTA_MASKS	(RTA_NETMASK | RTA_IFA | RTA_BRD)
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			p = (char *)(void *)(ifam + 1);
+			++icnt;
+#ifdef	HAVE_IFAM_DATA
+			dcnt += sizeof(ifam->ifam_data) + ALIGNBYTES;
+#endif	/* HAVE_IFAM_DATA */
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_NETMASK && SA_LEN(sa) == 0)
+					dcnt += alen;
+				else
+					dcnt += len;
+				p += len;
+			}
+			break;
+		}
+	}
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+
+	if (icnt + dcnt + ncnt == 1) {
+		*pif = NULL;
+		free(buf);
+		return (0);
+	}
+	data = malloc(sizeof(struct ifaddrs) * icnt + dcnt + ncnt);
+	if (data == NULL) {
+		free(buf);
+		return(-1);
+	}
+
+	ifa = (struct ifaddrs *)(void *)data;
+	data += sizeof(struct ifaddrs) * icnt;
+	names = data + dcnt;
+
+	memset(ifa, 0, sizeof(struct ifaddrs) * icnt);
+	ift = ifa;
+
+#ifdef	NET_RT_IFLIST
+	idx = 0;
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+
+				cif = ift;
+				ift->ifa_name = names;
+				ift->ifa_flags = (int)ifm->ifm_flags;
+				memcpy(names, dl->sdl_data,
+				    (size_t)dl->sdl_nlen);
+				names[dl->sdl_nlen] = 0;
+				names += dl->sdl_nlen + 1;
+
+				ift->ifa_addr = (struct sockaddr *)(void *)data;
+				memcpy(data, dl,
+				    (size_t)SA_LEN((struct sockaddr *)
+				    (void *)dl));
+				data += SA_RLEN((struct sockaddr *)(void *)dl);
+
+#ifdef	HAVE_IFM_DATA
+				/* ifm_data needs to be aligned */
+				ift->ifa_data = data = (void *)ALIGN(data);
+				memcpy(data, &ifm->ifm_data, sizeof(ifm->ifm_data));
+ 				data += sizeof(ifm->ifm_data);
+#else	/* HAVE_IFM_DATA */
+				ift->ifa_data = NULL;
+#endif	/* HAVE_IFM_DATA */
+
+				ift = (ift->ifa_next = ift + 1);
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			ift->ifa_name = cif->ifa_name;
+			ift->ifa_flags = cif->ifa_flags;
+			ift->ifa_data = NULL;
+			p = (char *)(void *)(ifam + 1);
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				switch (i) {
+				case RTAX_IFA:
+					ift->ifa_addr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_NETMASK:
+					ift->ifa_netmask =
+					    (struct sockaddr *)(void *)data;
+					if (SA_LEN(sa) == 0) {
+						memset(data, 0, alen);
+						data += alen;
+						break;
+					}
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_BRD:
+					ift->ifa_broadaddr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+				}
+				p += len;
+			}
+
+#ifdef	HAVE_IFAM_DATA
+			/* ifam_data needs to be aligned */
+			ift->ifa_data = data = (void *)ALIGN(data);
+			memcpy(data, &ifam->ifam_data, sizeof(ifam->ifam_data));
+			data += sizeof(ifam->ifam_data);
+#endif	/* HAVE_IFAM_DATA */
+
+			ift = (ift->ifa_next = ift + 1);
+			break;
+		}
+	}
+
+	free(buf);
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	if (--ift >= ifa) {
+		ift->ifa_next = NULL;
+		*pif = ifa;
+	} else {
+		*pif = NULL;
+		free(ifa);
+	}
+	return (0);
+}
+libc_hidden_def (getifaddrs)
+
+void
+freeifaddrs(struct ifaddrs *ifp)
+{
+
+	free(ifp);
+}
+libc_hidden_def (freeifaddrs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.c
@@ -0,0 +1,93 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <ifreq.h>
+
+/* The FreeBSD ioctl SIOCGIFCONF returns the list if interfaces as a
+   concatenation of records of different size, each having at least
+   sizeof (struct ifreq) bytes.  */
+
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  int fd = sockfd;
+  struct ifconf ifc;
+  int rq_len;
+  int nifs;
+  char *ifstart;
+  char *ifend;
+  struct ifreq *ifr;
+  /* FreeBSD has many interfaces, many of them are usually down.  */
+# define RQ_IFS	16
+  /* We have to assume all records are of limited size, so that we know
+     when we can stop enlarging the buffer.  */
+# define RQ_MAXSIZE 256
+
+  if (fd < 0)
+    fd = __opensock ();
+  if (fd < 0)
+    {
+      *num_ifs = 0;
+      *ifreqs = NULL;
+      return;
+    }
+
+  ifc.ifc_buf = NULL;
+  rq_len = RQ_IFS * sizeof (struct ifreq) + RQ_MAXSIZE;
+  for (;;)
+    {
+      ifc.ifc_len = rq_len;
+      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
+      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  if (ifc.ifc_buf)
+	    free (ifc.ifc_buf);
+
+	  if (fd != sockfd)
+	    __close (fd);
+	  *num_ifs = 0;
+	  *ifreqs = NULL;
+	  return;
+	}
+      if (ifc.ifc_len + RQ_MAXSIZE <= rq_len)
+	break;
+      rq_len *= 2;
+    }
+
+  nifs = 0;
+  ifstart = (char *) ifc.ifc_buf;
+  ifend = ifstart + ifc.ifc_len;
+  for (ifr = (struct ifreq *) ifstart;
+       (char *) ifr < ifend;
+       ifr = __if_nextreq (ifr))
+    nifs++;
+
+  if (fd != sockfd)
+    __close (fd);
+
+  *num_ifs = nifs;
+  *ifreqs = realloc (ifc.ifc_buf, ifc.ifc_len);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c
@@ -0,0 +1,135 @@
+/* Initialization code run first thing by the ELF startup code.
+   Copyright (C) 1995-2004, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <signal.h>
+#include <fpu_control.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <libc-internal.h>
+
+#include <ldsodefs.h>
+
+extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
+libc_hidden_proto (__syscall_sigaction)
+
+/* Set nonzero if we have to be prepared for more then one libc being
+   used in the process.  Safe assumption if initializer never runs.  */
+int __libc_multiple_libcs attribute_hidden = 1;
+
+/* Remember the command line argument and enviroment contents for
+   later calls of initializers for dynamic libraries.  */
+int __libc_argc attribute_hidden;
+char **__libc_argv attribute_hidden;
+
+
+void
+__libc_init_first (int argc, char **argv, char **envp)
+{
+#ifdef SHARED
+  /* For DSOs we do not need __libc_init_first but instead _init.  */
+}
+
+void
+attribute_hidden
+_init (int argc, char **argv, char **envp)
+{
+#endif
+#ifdef USE_NONOPTION_FLAGS
+  extern void __getopt_clean_environment (char **);
+#endif
+
+  __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
+
+  /* Make sure we don't initialize twice.  */
+  if (!__libc_multiple_libcs)
+    {
+      /* Set the FPU control word to the proper default value if the
+	 kernel would use a different value.  (In a static program we
+	 don't have this information.)  */
+#if 0
+      /* at least on kFreeBSD set it even if SHARED,
+      fixes "make check" failures like math/test-fpucw.out */
+#ifdef SHARED
+      if (__fpu_control != GLRO(dl_fpu_control))
+#endif
+#endif
+	__setfpucw (__fpu_control);
+    }
+
+  /* By default on kFreeBSD when a call to non existing syscall is
+     made, the program is terminated. As we want to be able to detect
+     missing syscalls and provide a fallback code, we ignore the SIGSYS
+     signal. */
+  {
+    struct sigaction act;
+    
+    act.sa_handler = SIG_IGN;
+    __sigemptyset (&act.sa_mask);
+    act.sa_flags = 0;
+    
+    INLINE_SYSCALL (sigaction, 3, SIGSYS, &act, NULL); 
+  }  
+
+  /* Save the command-line arguments.  */
+  __libc_argc = argc;
+  __libc_argv = argv;
+  __environ = envp;
+
+#ifndef SHARED
+  __libc_init_secure ();
+
+  /* First the initialization which normally would be done by the
+     dynamic linker.  */
+  _dl_non_dynamic_init ();
+#endif
+
+#ifdef VDSO_SETUP
+  VDSO_SETUP ();
+#endif
+
+  __init_misc (argc, argv, envp);
+
+#ifdef USE_NONOPTION_FLAGS
+  /* This is a hack to make the special getopt in GNU libc working.  */
+  __getopt_clean_environment (envp);
+#endif
+
+#if defined SHARED && !defined NO_CTORS_DTORS_SECTIONS
+  __libc_global_ctors ();
+#endif
+}
+
+
+/* This function is defined here so that if this file ever gets into
+   ld.so we will get a link error.  Having this file silently included
+   in ld.so causes disaster, because the _init definition above will
+   cause ld.so to gain an init function, which is not a cool thing. */
+
+extern void _dl_start (void) __attribute__ ((noreturn));
+
+void
+_dl_start (void)
+{
+  abort ();
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/kenv.h
@@ -0,0 +1,39 @@
+/*-
+ * Copyright (c) 2002 Maxime Henrion <mux@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/include/kenv.h,v 1.2.8.1 2009/04/15 03:14:26 kensmith Exp $
+ */
+
+#ifndef _KENV_H_
+#define _KENV_H 	1
+
+#include <sys/cdefs.h>
+#include <sys/kenv.h>
+
+__BEGIN_DECLS
+int kenv(int action, const char *name, char *value, int len);
+__END_DECLS
+
+#endif /* !_KENV_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h
@@ -0,0 +1,92 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __KFREEBSD_KERNEL_VERSION
+/* We assume the worst; all kernels should be supported.  */
+# define __KFREEBSD_KERNEL_VERSION	0
+#endif
+
+/* The encoding for __KFREEBSD_KERNEL_VERSION is defined the following
+   way: the major, minor, and subminor all get a byte with the major
+   number being in the highest byte.  This means we can do numeric
+   comparisons.
+
+   In the following we will define certain symbols depending on
+   whether the describes kernel feature is available in the kernel
+   version given by __KFREEBSD_KERNEL_VERSION.  We are not always exactly
+   recording the correct versions in which the features were
+   introduced.  If somebody cares these values can afterwards be
+   corrected.  */
+
+/* 
+   The used encoding corresponds to the following in elf/dl-load.c:
+
+            osversion = (abi_note[5] & 0xff) * 65536
+                        + (abi_note[6] & 0xff) * 256
+                        + (abi_note[7] & 0xff);
+            if (abi_note[4] != __ABI_TAG_OS
+                || (GLRO(dl_osversion) && GLRO(dl_osversion) < osversion))
+            
+   Therefore, the __KFREEBSD_KERNEL_VERSION have different value compared to
+   __FreeBSD_version/__FreeBSD_kernel__version. 
+   The transformation is not just prepend 0x to __FreeBSD_kernel_version.
+
+   For changes see i.e.
+   http://www.freebsd.org/doc/en/books/porters-handbook/freebsd-versions.html
+*/
+
+/* Real-time signals introduced in FreeBSD 7.x.  */
+#if __KFREEBSD_KERNEL_VERSION >= 0x70032
+# define __ASSUME_REALTIME_SIGNALS	1
+#endif
+
+/* Use signals #32, #33, #34 for internal linuxthreads communication */
+#define PTHREAD_SIGBASE 32
+
+/* The `ftruncate' syscall was introduced in kFreeBSD 7.0. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x70032
+# define __ASSUME_TRUNCATE_SYSCALL	1
+#endif
+
+/* The `lseek' syscall was introduced in kFreeBSD 7.0. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x70032
+# define __ASSUME_LSEEK_SYSCALL		1
+#endif
+
+/* The `mmap' syscall was introduced in kFreeBSD 7.0. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x70032
+# define __ASSUME_MMAP_SYSCALL		1
+#endif
+
+/* The `pread' and `pwrite' syscalls were introduced in kFreeBSD 7.0. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x70032
+# define __ASSUME_PREAD_PWRITE_SYSCALLS	1
+#endif
+
+/* The `shm_*' syscalls were introduced in kFreeBSD 8.0 */
+#if __KFREEBSD_KERNEL_VERSION >= 0x8000C
+# define __ASSUME_SHMFCTS		1
+#endif
+
+/* The `*at' syscalls were introduced in kFreeBSD 8.0. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x8001D
+# define __ASSUME_ATFCTS		1
+#endif
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-posix-cpu-timers.h
@@ -0,0 +1,5 @@
+/* Parameters for the FreeBSD kernel ABI for CPU clocks.  */
+
+#define CPUCLOCK_WHICH(clock)   ((clock) & (clockid_t) CPUCLOCK_CLOCK_MASK)
+#define CPUCLOCK_CLOCK_MASK     7
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h
@@ -0,0 +1,58 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* FreeBSD puts some extra information into an auxiliary vector when it
+   execs ELF executables.  Note that it uses AT_* values of 10 and 11
+   to denote something different than AT_NOTELF and AT_UID, but this is
+   not a problem since elf/dl-support.c ignores these AT_* values.  */
+#define HAVE_AUX_VECTOR
+
+/* Used by static binaries to check the auxiliary vector.  */
+extern void _dl_aux_init (ElfW(auxv_t) *av) internal_function;
+
+/* Initialization which is normally done by the dynamic linker.  */
+extern void _dl_non_dynamic_init (void) internal_function;
+
+/* Contrary to most kernels which use ELFOSABI_SYSV aka ELFOSABI_NONE,
+   FreeBSD uses ELFOSABI_FREEBSD for the OSABI field. */
+#define VALID_ELF_HEADER(hdr,exp,size)	(memcmp (hdr, expected2, size) == 0)
+#define VALID_ELF_OSABI(osabi)		(osabi == ELFOSABI_FREEBSD)
+#define VALID_ELF_ABIVERSION(osabi,ver) (ver == 0)
+#define MORE_ELF_HEADER_DATA \
+  static const unsigned char expected2[EI_PAD] =	\
+  {							\
+    [EI_MAG0] = ELFMAG0,				\
+    [EI_MAG1] = ELFMAG1,				\
+    [EI_MAG2] = ELFMAG2,				\
+    [EI_MAG3] = ELFMAG3,				\
+    [EI_CLASS] = ELFW(CLASS),				\
+    [EI_DATA] = byteorder,				\
+    [EI_VERSION] = EV_CURRENT,				\
+    [EI_OSABI] = ELFOSABI_FREEBSD,			\
+    [EI_ABIVERSION] = 0					\
+  }
+
+#endif /* ldsodefs.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linkat.c
@@ -0,0 +1,181 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <stdio.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_linkat (int fd1, const char *path1, int fd2,
+			       const char *path2, int flags);
+libc_hidden_proto (__syscall_linkat)
+
+/* Make a link to FROM named TO but relative paths in TO and FROM are
+   interpreted relative to FROMFD and TOFD respectively.  */
+int
+linkat (fromfd, from, tofd, to, flags)
+     int fromfd;
+     const char *from;
+     int tofd;
+     const char *to;
+     int flags;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (linkat, 5, fromfd, from, tofd, to, flags);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  /* Without kernel support we cannot handle AT_SYMLINK_FOLLOW.  */
+  if (flags != 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if ((fromfd != AT_FDCWD && from[0] != '/')
+      || (tofd != AT_FDCWD && to[0] != '/'))
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t fromlen, tolen;
+
+      if ((fromfd < 0) || (tofd < 0))
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      fromlen = strlen (from);
+      tolen = strlen (to);
+      if (__builtin_expect (fromlen == 0, 0)
+	  || __builtin_expect (tolen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      if (fromfd != AT_FDCWD && from[0] != '/')
+	{
+	  kf_bufp = kf_buf;
+	  while (kf_bufp < kf_buf + kf_len)
+	    {
+	      struct kinfo_file *kf =
+		(struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	      if (kf->kf_fd == fromfd)
+		{
+		  char *buf;
+		  if (kf->kf_type != KF_TYPE_VNODE ||
+		      kf->kf_vnode_type != KF_VTYPE_VDIR)
+		    {
+		      __set_errno (ENOTDIR);
+		      return -1;
+		    }
+
+		  buf = alloca (strlen (kf->kf_path) + fromlen + 2);
+		  strcpy(buf, kf->kf_path);
+		  strcat (buf, "/");
+		  strcat (buf, from);
+		  from = buf;
+		  break;
+		}
+	      kf_bufp += kf->kf_structsize;
+	    }
+
+	  if (kf_bufp >= kf_buf + kf_len)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+	}
+
+      if (tofd != AT_FDCWD && to[0] != '/')
+	{
+	  kf_bufp = kf_buf;
+	  while (kf_bufp < kf_buf + kf_len)
+	    {
+	      struct kinfo_file *kf =
+		(struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	      if (kf->kf_fd == tofd)
+		{
+		  char *buf;
+		  if (kf->kf_type != KF_TYPE_VNODE ||
+		      kf->kf_vnode_type != KF_VTYPE_VDIR)
+		    {
+		      __set_errno (ENOTDIR);
+		      return -1;
+		    }
+
+		  buf = alloca (strlen (kf->kf_path) + tolen + 2);
+		  strcpy(buf, kf->kf_path);
+		  strcat (buf, "/");
+		  strcat (buf, to);
+		  to = buf;
+		  break;
+		}
+	      kf_bufp += kf->kf_structsize;
+	    }
+
+	  if (kf_bufp >= kf_buf + kf_len)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+	}
+    }
+  
+  return __link (from, to);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Implies
@@ -0,0 +1 @@
+pthread
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Makefile
@@ -0,0 +1,8 @@
+ifeq ($(subdir),linuxthreads)
+sysdep_routines += register-atfork unregister-atfork
+libpthread-routines += ptw-sigprocmask ptw-ioctl
+endif
+
+ifeq ($(subdir),rt)
+librt-sysdep_routines += timer_routines
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.3.2 {
+    __register_atfork;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/allocrtsig.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/allocrtsig.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/local_lim.h
@@ -0,0 +1,48 @@
+/* Minimum guaranteed maximum values for system limits.  FreeBSD version.
+   Copyright (C) 1993-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/syslimits.h>
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* This is the value this implementation supports.  */
+#define PTHREAD_THREADS_MAX	1024
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
+
+/* Maximum number of POSIX timers available.  */
+#define TIMER_MAX	256
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/posix_opt.h
@@ -0,0 +1,190 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	200809L
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	200809L
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200809L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200809L
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	200809L
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200809L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200809L
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+/* X/Open realtime support is only partially available.  */
+#define _XOPEN_REALTIME	-1
+
+/* X/Open realtime thread support is only partially available.  */
+#define _XOPEN_REALTIME_THREADS	-1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200809L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS	1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
+
+/* We provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200809L
+
+/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
+#define _POSIX_SEMAPHORES	200809L
+
+/* Real-time signals are not available.  */
+#define _POSIX_REALTIME_SIGNALS	-1
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	200809L
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+/* Support for prioritization is not available.  */
+#define _POSIX_PRIORITIZED_IO	-1
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	1
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
+
+/* CPU-time clocks somewhere supported.  */
+#define _POSIX_CPUTIME	0
+
+/* We support somewhere the clock also in threads.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200809L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200809L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200809L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200809L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	200809L
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200809L
+
+/* POSIX message queues are not available.  */
+#define _POSIX_MESSAGE_PASSING	-1
+
+/* Thread process-shared synchronization is not supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	-1
+
+/* The monotonic clock is available.  */
+#define _POSIX_MONOTONIC_CLOCK	200809L
+
+/* The clock selection interfaces are not available.  */
+#define _POSIX_CLOCK_SELECTION	-1
+
+/* Advisory information interfaces are not available.  */
+#define _POSIX_ADVISORY_INFO	-1
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200809L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200809L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200809L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+/* No support for priority inheritance or protection.  */
+#define _POSIX_THREAD_PRIO_INHERIT	-1
+#define _POSIX_THREAD_PRIO_PROTECT	-1
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/sigthread.h
@@ -0,0 +1,38 @@
+/* Signal handling function for threaded programs.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGTHREAD_H
+#define _BITS_SIGTHREAD_H	1
+
+#if !defined _SIGNAL_H && !defined _PTHREAD_H
+# error "Never include this file directly.  Use <pthread.h> instead"
+#endif
+
+/* Functions for handling signals. */
+
+/* Modify the signal mask for the calling thread.  The arguments have
+   the same meaning as for sigprocmask(2). */
+extern int pthread_sigmask (int __how,
+			    __const __sigset_t *__restrict __newmask,
+			    __sigset_t *__restrict __oldmask) __THROW;
+
+/* Send signal SIGNO to the given thread. */
+extern int pthread_kill (pthread_t __threadid, int __signo) __THROW;
+
+#endif	/* bits/sigthread.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/bits/typesizes.h
@@ -0,0 +1,82 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+
+/*
+ * This one is a bit tricky.  It needs to match the size
+ * in the sys/${arch}/include/_types.h typedefs.
+ *
+ * However, for i386 and amd64 we started with __SLONGWORD_TYPE
+ * and we need to maintain ABI.  Even if size is the same, using
+ * a different type may affect C++ ABI (this distinction is
+ * necessary to implement function overload), so it must stay
+ * with __SLONGWORD_TYPE.
+ */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#else
+#define __TIME_T_TYPE		__S64_TYPE
+#endif
+
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__SQUAD_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		union { int __val[2]; int val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/execve.c
@@ -0,0 +1,2 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/execve.c>
+libc_hidden_proto (__syscall_execve )
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fatal-prepare.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <pthread.h>
+
+/* We have to completely disable cancellation.  assert() must not be a
+   cancellation point but the implementation uses write() etc.  */
+#ifdef SHARED
+# include <pthread-functions.h>
+# define FATAL_PREPARE \
+  {									      \
+    int (*fp) (int, int *);                                                   \
+    fp = __libc_pthread_functions.ptr_pthread_setcancelstate;                 \
+    if (fp != NULL)                                                           \
+      fp (PTHREAD_CANCEL_DISABLE, NULL);                                      \
+  }
+#else
+# pragma weak pthread_setcancelstate
+# define FATAL_PREPARE \
+  {									      \
+    if (pthread_setcancelstate != NULL)					      \
+      pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);		      \
+  }
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/fork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/fork.h
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/fork.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/jmp-unwind.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/jmp-unwind.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/kernel-posix-timers.h
@@ -0,0 +1,126 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/_types.h>
+
+/* The signal used for asynchronous cancelation.  */
+#define SIGCANCEL	(PTHREAD_SIGBASE + 1)
+
+/* Signal needed for the kernel-supported POSIX timer implementation.
+   We can reuse the cancellation signal since we can distinguish
+   cancellation from timer expirations.  */
+#define SIGTIMER	SIGCANCEL
+
+/* Nonzero if the system calls are not available.  */
+extern int __no_posix_timers attribute_hidden;
+
+/* Callback to start helper thread.  */
+extern void __start_helper_thread (void) attribute_hidden;
+
+/* Control variable for helper thread creation.  */
+extern pthread_once_t __helper_once attribute_hidden;
+
+/* TID of the helper thread.  */
+extern __lwpid_t __helper_tid attribute_hidden;
+
+/* List of active SIGEV_THREAD timers.  */
+extern struct timer *__active_timer_sigev_thread attribute_hidden;
+/* Lock for the __active_timer_sigev_thread.  */
+extern pthread_mutex_t __active_timer_sigev_thread_lock attribute_hidden;
+
+
+/* Type of timers in the kernel.  */
+typedef int kernel_timer_t;
+
+
+/* Internal representation of timer.  */
+struct timer
+{
+  /* Notification mechanism.  */
+  int sigev_notify;
+
+  /* Timer ID returned by the kernel.  */
+  kernel_timer_t ktimerid;
+
+  /* All new elements must be added after ktimerid.  And if the thrfunc
+     element is not the third element anymore the memory allocation in
+     timer_create needs to be changed.  */
+
+  /* Parameters for the thread to be started for SIGEV_THREAD.  */
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+  pthread_attr_t attr;
+
+  /* Next element in list of active SIGEV_THREAD timers.  */
+  struct timer *next;
+};
+
+extern struct timer *__all_timers[TIMER_MAX];
+
+static inline struct timer *
+__kfreebsd_timer_alloc ()
+{
+  unsigned int i;
+  struct timer *timer = malloc (sizeof (struct timer));
+
+  /* Find a free slot (and reserve it atomically).  */
+  for (i = 0; i < TIMER_MAX; i++)
+    if (atomic_compare_and_exchange_val_acq (&__all_timers[i],
+					     timer, NULL) == NULL)
+      return timer;
+
+  errno = EAGAIN;
+  return NULL;
+}
+
+static inline struct timer *
+__kfreebsd_timer_id2ptr (timer_t id)
+{
+  void *ret = NULL;
+
+  if (id >= 0 && id < TIMER_MAX)
+    ret = __all_timers[id];
+
+  if (! ret)
+    errno = EINVAL;
+
+  return ret;
+}
+
+static inline timer_t
+__kfreebsd_timer_ptr2id (struct timer *ptr)
+{
+  unsigned int i;
+  for (i = 0; i < TIMER_MAX; i++)
+    if (__all_timers[i] == ptr)
+      return i;
+
+  return -1;
+}
+
+void static inline
+__kfreebsd_timer_free (struct timer *ptr)
+{
+  __all_timers[__kfreebsd_timer_ptr2id (ptr)] = NULL;
+  free (ptr);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/lowlevellock.h
@@ -0,0 +1,47 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <atomic.h>
+
+typedef union
+{
+  volatile void *	uv;	/* in fact struct umtx from <sys/umtx.h> */
+  volatile int		iv;
+  volatile long		lv;
+
+} __rtld_mrlock_t;
+
+#define UMTX_OP_WAIT	2	/*  <sys/umtx.h> */
+#define UMTX_OP_WAKE	3	/*  <sys/umtx.h> */
+
+extern int __syscall__umtx_op(void *, int, long, void*, void*);
+
+static inline void lll_futex_wake(long *umtx, unsigned int nr_wakeup)
+{
+  __syscall__umtx_op(umtx, UMTX_OP_WAKE, nr_wakeup, NULL, NULL);
+}
+
+static inline void lll_futex_wait(long *umtx, unsigned int old_val)
+{
+  __syscall__umtx_op(umtx, UMTX_OP_WAIT, old_val, NULL, NULL);
+}
+
+#endif	/* lowlevellock.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/pt-sigsuspend.S
@@ -0,0 +1,29 @@
+/* Internal sigsuspend system call for LinuxThreads. FreeBSD version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <sysdep.h>
+
+PSEUDO_NOERRNO(__pthread_sigsuspend, sigsuspend, 1)
+	ret_NOERRNO
+PSEUDO_END_NOERRNO(__pthread_sigsuspend)
+
+PSEUDO(__syscall_sigsuspend, sigsuspend, 1)
+	ret
+PSEUDO_END(__syscall_sigsuspend)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/raise.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/raise.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/register-atfork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/register-atfork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/smp.h
@@ -0,0 +1,36 @@
+/* Determine whether the host has multiple processors.  FreeBSD version.
+   Copyright (C) 1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sys/sysctl.h>
+
+/* Test whether the machine has more than one processor.  */
+static inline int
+is_smp_system (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return (result > 1);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_create.c
@@ -0,0 +1,226 @@
+/* Copyright (C) 2003,2004, 2007, 2009, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+#include "kernel-posix-cpu-timers.h"
+
+
+#ifdef SYS_ktimer_create
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_create (clockid_t clock_id, struct sigevent *evp,
+				timer_t *timerid);
+#  define timer_create static compat_timer_create
+#  include <linuxthreads/sysdeps/pthread/timer_create.c>
+#  undef timer_create
+
+/* Nonzero if the system calls are not available.  */
+int __no_posix_timers attribute_hidden;
+# endif
+
+# ifdef timer_create_alias
+#  define timer_create timer_create_alias
+# endif
+
+
+int
+timer_create (clock_id, evp, timerid)
+     clockid_t clock_id;
+     struct sigevent *evp;
+     timer_t *timerid;
+{
+# undef timer_create
+# ifndef __ASSUME_POSIX_TIMERS
+  if  (__no_posix_timers >= 0)
+# endif
+    {
+      /* If the user wants notification via a thread we need to handle
+	 this special.  */
+      if (evp == NULL
+	  || __builtin_expect (evp->sigev_notify != SIGEV_THREAD, 1))
+	{
+	  struct sigevent local_evp;
+
+	  struct timer *newp = __kfreebsd_timer_alloc ();
+
+	  if (newp == NULL)
+	    /* No more memory.  */
+	    return -1;
+
+	  if (evp == NULL)
+	    {
+	      /* The kernel has to pass up the timer ID which is a
+		 userlevel object.  Therefore we cannot leave it up to
+		 the kernel to determine it.  */
+	      local_evp.sigev_notify = SIGEV_SIGNAL;
+	      local_evp.sigev_signo = SIGALRM;
+	      local_evp.sigev_value.sival_ptr = newp;
+
+	      evp = &local_evp;
+	    }
+
+	  kernel_timer_t ktimerid;
+	  int retval = INLINE_SYSCALL (ktimer_create, 3, clock_id, evp,
+				       &ktimerid);
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  if (retval != -1 || errno != ENOSYS)
+# endif
+	    {
+# ifndef __ASSUME_POSIX_TIMERS
+	      __no_posix_timers = 1;
+# endif
+
+	      if (retval != -1)
+		{
+		  newp->sigev_notify = (evp != NULL
+					? evp->sigev_notify : SIGEV_SIGNAL);
+		  newp->ktimerid = ktimerid;
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		}
+	      else
+		{
+		  /* Cannot allocate the timer, fail.  */
+		  __kfreebsd_timer_free (newp);
+		  retval = -1;
+		}
+
+	      return retval;
+	    }
+
+	  __kfreebsd_timer_free (newp);
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* When we come here the syscall does not exist.  Make sure we
+	     do not try to use it again.  */
+	  __no_posix_timers = -1;
+# endif
+	}
+      else
+	{
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* Make sure we have the necessary kernel support.  */
+	  if (__no_posix_timers == 0)
+	    {
+	      struct timespec ts;
+	      int res;
+	      res = INLINE_SYSCALL (clock_getres, 2,
+				    CLOCK_REALTIME, &ts);
+	      __no_posix_timers = (res == -1 ? -1 : 1);
+	    }
+
+	  if (__no_posix_timers > 0)
+# endif
+	    {
+	      /* Create the helper thread.  */
+	      pthread_once (&__helper_once, __start_helper_thread);
+	      if (__helper_tid == 0)
+		{
+		  /* No resources to start the helper thread.  */
+		  __set_errno (EAGAIN);
+		  return -1;
+		}
+
+	      struct timer *newp;
+	      newp = __kfreebsd_timer_alloc ();
+	      if (newp == NULL)
+		return -1;
+
+	      /* Copy the thread parameters the user provided.  */
+	      newp->sival = evp->sigev_value;
+	      newp->thrfunc = evp->sigev_notify_function;
+	      newp->sigev_notify = SIGEV_THREAD;
+
+	      /* We cannot simply copy the thread attributes since the
+		 implementation might keep internal information for
+		 each instance.  */
+	      (void) pthread_attr_init (&newp->attr);
+	      if (evp->sigev_notify_attributes != NULL)
+		{
+		  pthread_attr_t *nattr;
+		  pthread_attr_t *oattr;
+
+		  nattr = (pthread_attr_t *) &newp->attr;
+		  oattr = (pthread_attr_t *) evp->sigev_notify_attributes;
+
+		  nattr->__schedparam = oattr->__schedparam;
+		  nattr->__schedpolicy = oattr->__schedpolicy;
+		  nattr->__guardsize = oattr->__guardsize;
+		  nattr->__stackaddr = oattr->__stackaddr;
+		  nattr->__stacksize = oattr->__stacksize;
+		}
+
+	      /* In any case set the detach flag.  */
+	      (void) pthread_attr_setdetachstate (&newp->attr,
+						  PTHREAD_CREATE_DETACHED);
+
+	      /* Create the event structure for the kernel timer.  */
+	      struct sigevent sev =
+		{ .sigev_value.sival_ptr = newp,
+		  .sigev_signo = SIGTIMER,
+		  .sigev_notify = SIGEV_THREAD_ID,
+		  .sigev_notify_thread_id = __helper_tid,
+		};
+
+	      /* Create the timer.  */
+	      int res;
+	      res = INLINE_SYSCALL (ktimer_create, 3,
+				      clock_id, &sev, &newp->ktimerid);
+	      if (res != -1)
+		{
+		  /* Add to the queue of active timers with thread
+		     delivery.  */
+		  pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+		  newp->next = __active_timer_sigev_thread;
+		  __active_timer_sigev_thread = newp;
+		  pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		  return 0;
+		}
+
+	      /* Free the resources.  */
+	      __kfreebsd_timer_free (newp);
+
+	      return -1;
+	    }
+	}
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  /* Compatibility code.  */
+  return compat_timer_create (clock_id, evp, timerid);
+# endif
+}
+#else
+# ifdef timer_create_alias
+#  define timer_create timer_create_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <linuxthreads/sysdeps/pthread/timer_create.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_delete.c
@@ -0,0 +1,117 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_delete
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_delete (timer_t timerid);
+#  define timer_delete static compat_timer_delete
+#  include <linuxthreads/sysdeps/pthread/timer_delete.c>
+#  undef timer_delete
+# endif
+
+# ifdef timer_delete_alias
+#  define timer_delete timer_delete_alias
+# endif
+
+
+int
+timer_delete (timerid)
+     timer_t timerid;
+{
+# undef timer_delete
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_delete, 1, kt->ktimerid);
+
+      if (res == 0)
+	{
+	  if (kt->sigev_notify == SIGEV_THREAD)
+	    {
+	      /* Remove the timer from the list.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+	      if (__active_timer_sigev_thread == kt)
+		__active_timer_sigev_thread = kt->next;
+	      else
+		{
+		  struct timer *prevp = __active_timer_sigev_thread;
+		  while (prevp->next != NULL)
+		    if (prevp->next == kt)
+		      {
+			prevp->next = kt->next;
+			break;
+		      }
+		    else
+		      prevp = prevp->next;
+		}
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+
+	  /* Free the memory.  */
+	  (void) __kfreebsd_timer_free (kt);
+
+	  return 0;
+	}
+
+      /* The kernel timer is not known or something else bad happened.
+	 Return the error.  */
+# ifndef __ASSUME_POSIX_TIMERS
+      if (errno != ENOSYS)
+	{
+	  __no_posix_timers = 1;
+# endif
+	  return -1;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_delete (timerid);
+# endif
+}
+#else
+# ifdef timer_delete_alias
+#  define timer_delete timer_delete_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <linuxthreads/sysdeps/pthread/timer_delete.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_getoverr.c
@@ -0,0 +1,83 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_getoverrun
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_getoverrun (timer_t timerid);
+#  define timer_getoverrun static compat_timer_getoverrun
+#  include <linuxthreads/sysdeps/pthread/timer_getoverr.c>
+#  undef timer_getoverrun
+# endif
+
+# ifdef timer_getoverrun_alias
+#  define timer_getoverrun timer_getoverrun_alias
+# endif
+
+
+int
+timer_getoverrun (timerid)
+     timer_t timerid;
+{
+# undef timer_getoverrun
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Get the information from the kernel.  */
+      int res = INLINE_SYSCALL (ktimer_getoverrun, 1, kt->ktimerid);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_getoverrun (timerid);
+# endif
+}
+#else
+# ifdef timer_getoverrun_alias
+#  define timer_getoverrun timer_getoverrun_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <linuxthreads/sysdeps/pthread/timer_getoverr.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_gettime.c
@@ -0,0 +1,85 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_gettime
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_gettime (timer_t timerid, struct itimerspec *value);
+#  define timer_gettime static compat_timer_gettime
+#  include <linuxthreads/sysdeps/pthread/timer_gettime.c>
+#  undef timer_gettime
+# endif
+
+# ifdef timer_gettime_alias
+#  define timer_gettime timer_gettime_alias
+# endif
+
+
+int
+timer_gettime (timerid, value)
+     timer_t timerid;
+     struct itimerspec *value;
+{
+# undef timer_gettime
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_gettime, 2, kt->ktimerid, value);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_gettime (timerid, value);
+# endif
+}
+#else
+# ifdef timer_gettime_alias
+#  define timer_gettime timer_gettime_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <linuxthreads/sysdeps/pthread/timer_gettime.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_routines.c
@@ -0,0 +1,214 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <sysdep.h>
+#include <sys/_types.h> /* __lwpid_t */
+#include <atomic.h>
+#include <kernel-features.h>
+#include <linuxthreads/internals.h>	/* LIBC_CANCEL_ASYNC */
+#include <semaphore.h>
+#include "kernel-posix-timers.h"
+
+/* NPTL/Linux simply casts "timer_t" to "struct timer *", but on
+   kFreeBSD timer_t may not be large enough to hold a pointer.
+   So we store the pointers here... (sigh) */
+struct timer *__all_timers[TIMER_MAX];
+
+/* List of active SIGEV_THREAD timers.  */
+struct timer *__active_timer_sigev_thread;
+/* Lock for the __active_timer_sigev_thread.  */
+pthread_mutex_t __active_timer_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
+
+
+struct thread_start_data
+{
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+};
+
+/* TID of the helper thread.  */
+__lwpid_t __helper_tid attribute_hidden;
+sem_t __helper_tid_semaphore attribute_hidden;
+
+#ifdef SYS_ktimer_create
+/* Helper thread to call the user-provided function.  */
+static void *
+timer_sigev_thread (void *arg)
+{
+  /* The parent thread has all signals blocked.  This is a bit
+     surprising for user code, although valid.  We unblock all
+     signals.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+  sigprocmask (SIG_SETMASK, &ss, NULL);
+
+  struct thread_start_data *td = (struct thread_start_data *) arg;
+
+  void (*thrfunc) (sigval_t) = td->thrfunc;
+  sigval_t sival = td->sival;
+
+  /* The TD object was allocated in timer_helper_thread.  */
+  free (td);
+
+  /* Call the user-provided function.  */
+  thrfunc (sival);
+
+  return NULL;
+}
+
+
+/* Helper function to support starting threads for SIGEV_THREAD.  */
+static void *
+timer_helper_thread (void *arg)
+{
+  /* Wait for the SIGTIMER signal, allowing the setXid signal, and
+     none else.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+  __sigaddset (&ss, SIGTIMER);
+
+  syscall (SYS_thr_self, &__helper_tid);
+  sem_post (&__helper_tid_semaphore);
+
+  /* Endless loop of waiting for signals.  The loop is only ended when
+     the thread is canceled.  */
+  while (1)
+    {
+      siginfo_t si;
+
+      /* sigwaitinfo cannot be used here, since it deletes
+	 SIGCANCEL == SIGTIMER from the set.  */
+
+      int oldtype = LIBC_CANCEL_ASYNC ();
+
+      /* XXX The size argument hopefully will have to be changed to the
+	 real size of the user-level sigset_t.  */
+      int result = sigtimedwait (&ss, &si, NULL);
+
+      LIBC_CANCEL_RESET (oldtype);
+
+      if (result > 0)
+	{
+	  if (si.si_code == SI_TIMER)
+	    {
+	      struct timer *tk = (struct timer *) si.si_value.sival_ptr;
+
+	      /* Check the timer is still used and will not go away
+		 while we are reading the values here.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+
+	      struct timer *runp = __active_timer_sigev_thread;
+	      while (runp != NULL)
+		if (runp == tk)
+		  break;
+		else
+		  runp = runp->next;
+
+	      if (runp != NULL)
+		{
+		  struct thread_start_data *td = malloc (sizeof (*td));
+
+		  /* There is not much we can do if the allocation fails.  */
+		  if (td != NULL)
+		    {
+		      /* This is the signal we are waiting for.  */
+		      td->thrfunc = tk->thrfunc;
+		      td->sival = tk->sival;
+
+		      pthread_t th;
+		      (void) pthread_create (&th, &tk->attr,
+					     timer_sigev_thread, td);
+		    }
+		}
+
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+	  else if (si.si_code == SI_LWP
+		   /* Backward compatibility (see rev 211732 in -CURRENT).  */
+		   || si.si_code == SI_USER)
+	    /* The thread is canceled.  */
+	    pthread_exit (NULL);
+	}
+    }
+}
+
+
+/* Control variable for helper thread creation.  */
+pthread_once_t __helper_once attribute_hidden;
+
+
+/* Reset variables so that after a fork a new helper thread gets started.  */
+static void
+reset_helper_control (void)
+{
+  __helper_once = PTHREAD_ONCE_INIT;
+  __helper_tid = 0;
+  sem_destroy (&__helper_tid_semaphore);
+}
+
+
+void
+attribute_hidden
+__start_helper_thread (void)
+{
+  /* The helper thread needs only very little resources
+     and should go away automatically when canceled.  */
+  pthread_attr_t attr;
+  (void) pthread_attr_init (&attr);
+  (void) pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN);
+
+  /* Block all signals in the helper thread but SIGSETXID.  To do this
+     thoroughly we temporarily have to block all signals here.  The
+     helper can lose wakeups if SIGCANCEL is not blocked throughout,
+     but sigfillset omits it SIGSETXID.  So, we add SIGCANCEL back
+     explicitly here.  */
+  sigset_t ss;
+  sigset_t oss;
+  sigfillset (&ss);
+  __sigaddset (&ss, SIGCANCEL);
+  sigprocmask (SIG_SETMASK, &ss, &oss);
+
+  sem_init (&__helper_tid_semaphore, 0, 0);
+
+  /* Create the helper thread for this timer.  */
+  pthread_t th;
+  int res = pthread_create (&th, &attr, timer_helper_thread, NULL);
+  if (res == 0)
+    /* We managed to start the helper thread.  */
+    sem_wait (&__helper_tid_semaphore);
+
+  /* Restore the signal mask.  */
+  sigprocmask (SIG_SETMASK, &oss, NULL);
+
+  /* No need for the attribute anymore.  */
+  (void) pthread_attr_destroy (&attr);
+
+  /* We have to make sure that after fork()ing a new helper thread can
+     be created.  */
+  pthread_atfork (NULL, NULL, reset_helper_control);
+}
+#endif
+
+#ifndef __ASSUME_POSIX_TIMERS
+# include <linuxthreads/sysdeps/pthread/timer_routines.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/timer_settime.c
@@ -0,0 +1,90 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_settime
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_settime (timer_t timerid, int flags,
+				 const struct itimerspec *value,
+				 struct itimerspec *ovalue);
+#  define timer_settime static compat_timer_settime
+#  include <linuxthreads/sysdeps/pthread/timer_settime.c>
+#  undef timer_settime
+# endif
+
+# ifdef timer_settime_alias
+#  define timer_settime timer_settime_alias
+# endif
+
+
+int
+timer_settime (timerid, flags, value, ovalue)
+     timer_t timerid;
+     int flags;
+     const struct itimerspec *value;
+     struct itimerspec *ovalue;
+{
+# undef timer_settime
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_settime, 4, kt->ktimerid, flags,
+				value, ovalue);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_settime (timerid, flags, value, ovalue);
+# endif
+}
+#else
+# ifdef timer_settime_alias
+#  define timer_settime timer_settime_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <linuxthreads/sysdeps/pthread/timer_settime.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/linuxthreads/unregister-atfork.c
@@ -0,0 +1 @@
+#include <linuxthreads/sysdeps/unix/sysv/linux/unregister-atfork.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/llseek.c
@@ -0,0 +1,6 @@
+/* We don't need a definition since the lseek64 function is what we need.  */
+/* llseek doesn't have a prototype.  Since the second parameter is a
+   64bit type, this results in wrong behaviour if no prototype is
+   provided.  */
+link_warning (llseek, "\
+the `llseek' function may be dangerous; use `lseek64' instead.")
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek.c
@@ -0,0 +1,59 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <errno.h>
+
+extern __off_t __syscall_lseek (int __fd, __off_t __offset, int __whence) __THROW;
+libc_hidden_proto (__syscall_lseek)
+extern __off_t __syscall_freebsd6_lseek (int __fd, int __unused1, __off_t __offset,
+				int __whence) __THROW;
+libc_hidden_proto (__syscall_freebsd6_lseek)
+
+__off_t
+__libc_lseek (int fd, __off_t offset, int whence)
+{
+  __off_t result;
+
+  /* First try the new syscall. */
+  result = INLINE_SYSCALL (lseek, 3, fd, offset, whence);
+
+#ifndef __ASSUME_LSEEK_SYSCALL
+  if (result == -1 && errno == ENOSYS)
+    /* New syscall not available, us the old one. */
+    result = INLINE_SYSCALL (freebsd6_lseek, 4, fd, 0, offset, whence);
+#endif
+
+  return result;
+}
+
+weak_alias (__libc_lseek, __lseek)
+libc_hidden_def (__lseek)
+weak_alias (__libc_lseek, lseek)
+
+/* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
+strong_alias (__libc_lseek, __libc_lseek64)
+weak_alias (__libc_lseek64, __lseek64)
+weak_alias (__lseek64, lseek64)
+
+/* 'llseek' is the same as 'lseek', because __off64_t == __off_t.  */
+strong_alias (__libc_lseek, __llseek)
+weak_alias (__llseek, llseek)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c
@@ -0,0 +1 @@
+/* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c
@@ -0,0 +1,49 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_lstat (CHECK_STRING (file),
+			    CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat)
+
+weak_alias (__lxstat, _lxstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c
@@ -0,0 +1,44 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/____longjmp_chk.c
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include <__longjmp.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/dl-machine.h
@@ -0,0 +1,97 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+   Port to kFreeBSD (kernel of FreeBSD) by Robert Millan.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-machine.h>
+
+/* kFreeBSD puts arguments in a different location (see start.S).  */
+#undef RTLD_START
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	" STRINGXV(SETUP_GPX($25)) "\n\
+	" STRINGXV(SETUP_GPX64($18,$25)) "\n\
+	# i386 ABI book says that the first entry of GOT holds\n\
+	# the address of the dynamic structure. Though MIPS ABI\n\
+	# doesn't say nothing about this, I emulate this here.\n\
+	" STRINGXP(PTR_LA) " $9, _DYNAMIC\n\
+	# Subtract OFFSET_GP_GOT\n\
+	" STRINGXP(PTR_S) " $9, -0x7ff0($28)\n\
+	move $9, $29\n\
+	" STRINGXP(PTR_SUBIU) " $29, 16\n\
+	\n\
+	" STRINGXP(PTR_LA) " $8, .Lcoff\n\
+	bltzal $8, .Lcoff\n\
+.Lcoff:	" STRINGXP(PTR_SUBU) " $8, $31, $8\n\
+	\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start\n\
+	" STRINGXP(PTR_ADDU) " $25, $8\n\
+	jalr $25\n\
+	\n\
+	" STRINGXP(PTR_ADDIU) " $29, 16\n\
+	# Get the value of label '_dl_start_user' in t9 ($25).\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start_user\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	\n\
+	\n\
+	" _RTLD_PROLOGUE(_dl_start_user) "\
+	" STRINGXP(SETUP_GP) "\n\
+	" STRINGXV(SETUP_GP64($18,_dl_start_user)) "\n\
+	move $16, $28\n\
+	# Save the user entry point address in a saved register.\n\
+	move $17, $2\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw $2, _dl_skip_args\n\
+	beq $2, $0, 1f\n\
+	# Load the original argument count.\n\
+	" STRINGXP(PTR_L) " $10, 0($4)\n\
+	# Subtract _dl_skip_args from it.\n\
+	subu $10, $2\n\
+	# FIXME: unnecessary? Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll $2, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $29, $2\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(PTR_S) " $10, 0($4)\n\
+1:	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(PTR_L) /* or lw???  fixme */ " $5, 0($4)\n\
+	" STRINGXP(PTR_LA) " $6, " STRINGXP (PTRSIZE) "($4)\n\
+	" STRINGXP(PTR_L) " $4, _rtld_local\n\
+	sll $7, $5, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, $6\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, " STRINGXP (PTRSIZE) " \n\
+	# Make sure the stack pointer is aligned for _dl_init_internal.\n\
+	and $2, $29, -2 * " STRINGXP(SZREG) "\n\
+	" STRINGXP(PTR_S) " $29, -" STRINGXP(SZREG) "($2)\n\
+	" STRINGXP(PTR_SUBIU) " $29, $2, 32\n\
+	" STRINGXP(SAVE_GP(16)) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init_internal\n\
+	# Restore the stack pointer for _start.\n\
+	" STRINGXP(PTR_L)  " $29, 32-" STRINGXP(SZREG) "($29)\n\
+	# Pass our finalizer function to the user in $2 as per ELF ABI.\n\
+	" STRINGXP(PTR_LA) " $2, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	move $25, $17\n\
+	jr $25\n\t"\
+	_RTLD_EPILOGUE(_dl_start_user)\
+	".previous"\
+);
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/elf/start.S
@@ -0,0 +1,121 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004, 2010
+	Free Software Foundation, Inc.
+   Port to kFreeBSD (kernel of FreeBSD) by Robert Millan.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for start.S on MIPS/ELF.
+#endif
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/Mips ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   v0 ($2)	Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   a0 ($4)	Contains a pointer to the arguments and environment:
+		0(a0)			argc
+		4(a0)			argv[0]
+		...
+		(4*argc)(a0)		NULL
+		(4*(argc+1))(a0)	envp[0]
+		...
+					NULL
+   ra ($31)	The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+
+/* We need to call:
+   __libc_start_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+	
+	.text
+	.globl ENTRY_POINT
+	.type ENTRY_POINT,@function
+ENTRY_POINT:
+#ifdef __PIC__
+	SETUP_GPX($0)
+	SETUP_GPX64($25,$0)
+#else
+	PTR_LA $28, _gp		/* Setup GP correctly if we're non-PIC.  */
+	move $31, $0
+#endif
+
+	PTR_L $5, 0($4)			/* argc */
+	PTR_ADDIU $6, $4, PTRSIZE	/* argv  */
+	PTR_LA $4, main		/* main */
+	
+	/* Allocate space on the stack for seven arguments (o32 only)
+	   and make sure the stack is aligned to double words (8 bytes) 
+	   on o32 and quad words (16 bytes) on n32 and n64.  */
+	
+	and $29, -2 * SZREG
+#if _MIPS_SIM == _ABIO32
+	PTR_SUBIU $29, 32
+#endif
+	PTR_LA $7, __libc_csu_init		/* init */
+	PTR_LA $8, __libc_csu_fini
+#if _MIPS_SIM == _ABIO32
+	PTR_S $8, 16($29)		/* fini */
+	PTR_S $2, 20($29)		/* rtld_fini */
+	PTR_S $29, 24($29)		/* stack_end */
+#else
+	move $9, $2		/* rtld_fini */
+	move $10, $29		/* stack_end */
+#endif
+	jal __libc_start_main
+hlt:	b hlt			/* Crash if somehow it does return.  */
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/entry.h
@@ -0,0 +1,7 @@
+/* http://sources.redhat.com/bugzilla/show_bug.cgi?id=12297 */
+
+#ifndef __ASSEMBLY__
+extern void __start (void);
+#endif
+
+#define ENTRY_POINT __start
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/linuxthreads/pt-machine.h
@@ -0,0 +1,49 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   MIPS kFreeBSD version.
+   Copyright (C) 2001, 2002, 2003, 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_PT_MACHINE_H
+#define _FREEBSD_PT_MACHINE_H   1
+
+/*
+  almost all parts are common with linux version
+ */
+
+#include <linuxthreads/sysdeps/mips/pt-machine.h>
+
+#ifndef __ASSEMBLER__
+
+/* and only one FreeBSD specifics */
+
+#include <machine/sysarch.h>
+
+/* Initialize the thread-unique value. */
+
+#undef INIT_THREAD_SELF
+#define INIT_THREAD_SELF(descr, nr)			\
+  {							\
+    if (sysarch (MIPS_SET_TLS, descr) != 0)		\
+      {							\
+	abort();					\
+      }							\
+  }
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* pt-machine.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/linuxthreads/sysdep-cancel.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h>
+
+/* workarounds for http://sources.redhat.com/bugzilla/show_bug.cgi?id=12300 */
+#ifdef __ASSEMBLER__
+# if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+#  define RTLD_SINGLE_THREAD_P(reg) SINGLE_THREAD_P(reg)
+# endif
+#else
+# define RTLD_SINGLE_THREAD_P SINGLE_THREAD_P
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/linuxthreads/tls.h
@@ -0,0 +1,206 @@
+/* Definitions for thread-local data handling.  linuxthreads/MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+
+#ifndef __ASSEMBLER__
+
+# include <stdbool.h>
+# include <pt-machine.h>
+# include <stddef.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+# define READ_THREAD_POINTER() \
+    ({ void *__result;							      \
+       asm volatile (".set\tpush\n\t.set\tmips32r2\n\t"			      \
+		     "rdhwr\t%0, $29\n\t.set\tpop" : "=v" (__result));	      \
+       __result; })
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+
+/* Note: rd must be $v1 to be ABI-conformant.  */
+# define READ_THREAD_POINTER(rd) \
+	.set	push;							      \
+	.set	mips32r2;						      \
+	rdhwr	rd, $29;						      \
+	.set	pop
+#endif /* __ASSEMBLER__ */
+
+/* LinuxThreads can only use TLS if both floating stacks (in the MIPS case,
+   that means support for "rdhwr") and support from the tools are available.
+
+   We have to define USE_TLS consistently, or ldsodefs.h will lay out types
+   differently between an NPTL build and a LinuxThreads build.  It can be set
+   for libc.so and not libpthread.so, but only if we provide appropriate padding
+   in the _pthread_descr_struct.
+
+   Currently nothing defines FLOATING_STACKS.  We could assume this based on
+   kernel version once the TLS patches are available in kernel.org, but
+   it hardly seems worth it.  Use NPTL if you can.
+
+   To avoid bothering with the TLS support code at all, use configure
+   --without-tls.  */
+
+#if defined HAVE_TLS_SUPPORT \
+    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+
+/* Signal that TLS support is available.  */
+# define USE_TLS	1
+
+/* Include padding in _pthread_descr_struct so that libc can find p_errno,
+   if libpthread will only include the padding because of the !IS_IN_libpthread
+   check.  */
+#ifndef FLOATING_STACKS
+# define INCLUDE_TLS_PADDING	1
+#endif
+
+# ifndef __ASSEMBLER__
+
+/* This layout is actually wholly private and not affected by the ABI.
+   Nor does it overlap the pthread data structure, so we need nothing
+   extra here at all.  */
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+# ifdef __FreeBSD_kernel__
+  long gscope_flag;
+# else
+  int gscope_flag;
+# endif
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+#  define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+#  define TLS_INIT_TCB_ALIGN	__alignof__ (struct _pthread_descr_struct)
+
+/* This is the size of the TCB.  */
+#  define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+#  define TLS_TCB_ALIGN		__alignof__ (struct _pthread_descr_struct)
+
+/* This is the size we need before TCB.  */
+#  define TLS_PRE_TCB_SIZE \
+  (sizeof (struct _pthread_descr_struct)				      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer (in hardware register $29) points to the end of
+   the TCB + 0x7000, as for PowerPC.  The pthread_descr structure is
+   immediately in front of the TCB.  */
+#define TLS_TCB_OFFSET		0x7000
+
+/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
+/* This is not really true for powerpc64.  We are following alpha
+   where the DTV pointer is first doubleword in the TCB.  */
+#  define TLS_DTV_AT_TP 1
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+#  define INSTALL_DTV(TCBP, DTVP) \
+  (((tcbhead_t *) (TCBP))[-1].dtv = (DTVP) + 1)
+
+/* Install new dtv for current thread.  */
+#  define INSTALL_NEW_DTV(DTV) (THREAD_DTV() = (DTV))
+
+/* Return dtv of given thread descriptor.  */
+#  define GET_DTV(TCBP)	(((tcbhead_t *) (TCBP))[-1].dtv)
+
+/* Get system call information.  */
+#  include <sysdep.h>
+#  include <machine/sysarch.h>
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp, secondcall)					\
+  ({ INTERNAL_SYSCALL_DECL (err);					\
+  long result_var;							\
+  result_var = INTERNAL_SYSCALL (sysarch, err, 2,			\
+				 MIPS_SET_TLS,				\
+				 (char *) (tcbp) + TLS_TCB_OFFSET);	\
+  INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
+    ? "unknown error" : NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+#  undef THREAD_SELF
+#  define THREAD_SELF \
+    ((pthread_descr) (READ_THREAD_POINTER () \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Get the thread descriptor definition.  */
+#  include <linuxthreads/descr.h>
+
+/* l_tls_offset == 0 is perfectly valid on MIPS, so we have to use some
+   different value to mean unset l_tls_offset.  */
+#  define NO_TLS_OFFSET	-1
+
+/* Initializing the thread pointer requires a syscall which may not be
+   available, so don't do it if we don't need to.  */
+#  define TLS_INIT_TP_EXPENSIVE 1
+
+
+// fix based on local-linuxthreads-gscope.diff from debian
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#  define THREAD_GSCOPE_FLAG_UNUSED 0
+#  define THREAD_GSCOPE_FLAG_USED   1
+#  define THREAD_GSCOPE_FLAG_WAIT   2
+#  define THREAD_GSCOPE_RESET_FLAG()					\
+  do									\
+    { int __res								\
+	= atomic_exchange_rel (&THREAD_SELF->p_gscope_flag,		\
+			       THREAD_GSCOPE_FLAG_UNUSED);		\
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				\
+	lll_futex_wake (&THREAD_SELF->p_gscope_flag, 1);		\
+    }									\
+  while (0)
+#  define THREAD_GSCOPE_SET_FLAG()					\
+  do									\
+    {									\
+      THREAD_SELF->p_gscope_flag = THREAD_GSCOPE_FLAG_USED;		\
+      atomic_write_barrier ();						\
+    }									\
+  while (0)
+#  define THREAD_GSCOPE_WAIT()			\
+  GL(dl_wait_lookup_done) ()
+
+# endif /* __ASSEMBLER__ */
+
+#endif /* HAVE_TLS_SUPPORT */
+
+#endif	/* tls.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/Makefile
@@ -0,0 +1,2 @@
+# pull in __syscall_error routine (needed by sysdep.h in this directory)
+libpthread-routines += sysdep
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/bits/mcontext.h
@@ -0,0 +1,116 @@
+/* Machine-dependent processor state structure for kFreeBSD.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  mips version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ucontext.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: ucontext.h,v 1.2 2007/08/09 11:23:32 katta
+ * $FreeBSD$
+ */
+
+typedef struct	__mcontext {
+	/*
+	 * These fields must match the corresponding fields in struct 
+	 * sigcontext which follow 'sc_mask'. That way we can support
+	 * struct sigcontext and ucontext_t at the same time.
+	 */
+	int		mc_onstack;	/* sigstack state to restore */
+	int	mc_pc;		/* pc at time of signal */
+	int	mc_regs[32];	/* processor regs 0 to 31 */
+        int      sr;             /* status register */
+        int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		mc_fpused;	/* fp has been used */
+	int	mc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	int	mc_fpc_eir;	/* fp exception instruction reg */
+	int	__spare__[8];	/* XXX reserved */ 
+} mcontext_t;
+
+#define	SZREG		4
+
+/* offsets into mcontext_t */
+#define	UCTX_REG(x)	(8 + (x)*SZREG)
+
+#define	UCR_ZERO	UCTX_REG(0)
+#define	UCR_AT		UCTX_REG(1)
+#define	UCR_V0		UCTX_REG(2)
+#define	UCR_V1		UCTX_REG(3)
+#define	UCR_A0		UCTX_REG(4)
+#define	UCR_A1		UCTX_REG(5)
+#define	UCR_A2		UCTX_REG(6)
+#define	UCR_A3		UCTX_REG(7)
+#define	UCR_T0		UCTX_REG(8)
+#define	UCR_T1		UCTX_REG(9)
+#define	UCR_T2		UCTX_REG(10)
+#define	UCR_T3		UCTX_REG(11)
+#define	UCR_T4		UCTX_REG(12)
+#define	UCR_T5		UCTX_REG(13)
+#define	UCR_T6		UCTX_REG(14)
+#define	UCR_T7		UCTX_REG(15)
+#define	UCR_S0		UCTX_REG(16)
+#define	UCR_S1		UCTX_REG(17)
+#define	UCR_S2		UCTX_REG(18)
+#define	UCR_S3		UCTX_REG(19)
+#define	UCR_S4		UCTX_REG(20)
+#define	UCR_S5		UCTX_REG(21)
+#define	UCR_S6		UCTX_REG(22)
+#define	UCR_S7		UCTX_REG(23)
+#define	UCR_T8		UCTX_REG(24)
+#define	UCR_T9		UCTX_REG(25)
+#define	UCR_K0		UCTX_REG(26)
+#define	UCR_K1		UCTX_REG(27)
+#define	UCR_GP		UCTX_REG(28)
+#define	UCR_SP		UCTX_REG(29)
+#define	UCR_S8		UCTX_REG(30)
+#define	UCR_RA		UCTX_REG(31)
+#define UCR_SR          UCTX_REG(32)
+#define	UCR_MDLO	UCTX_REG(33)
+#define	UCR_MDHI	UCTX_REG(34)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/bits/sigcontext.h
@@ -0,0 +1,92 @@
+/* Machine-dependent signal context structure for kFreeBSD.  mips version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/*	$OpenBSD: signal.h,v 1.2 1999/01/27 04:10:03 imp Exp $	*/
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)signal.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: signal.h,v 1.4 2007/01/08 04:58:37 katta
+ * $FreeBSD$
+ */
+
+/*
+ * Information pushed on stack when a signal is delivered.
+ * This is used by the kernel to restore state following
+ * execution of the signal handler.  It is also made available
+ * to the handler to allow it to restore state properly if
+ * a non-standard exit is performed.
+ */
+
+__extension__ struct sigcontext {
+	/*
+	 * The fields following 'sc_mask' must match the definition
+	 * of struct __mcontext. That way we can support
+	 * struct sigcontext and ucontext_t at the same
+	 * time.
+	 */
+	__sigset_t	sc_mask;	/* signal mask to restore */
+	int		sc_onstack;	/* sigstack state to restore */
+	int	sc_pc;		/* pc at time of signal */
+	int	sc_regs[32];	/* processor regs 0 to 31 */
+	int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		sc_fpused;	/* fp has been used */
+	int	sc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	int	sc_fpc_eir;	/* fp exception instruction reg */
+	int		xxx[8];		/* XXX reserved */ 
+};
+
+#endif /* _BITS_SIGCONTEXT_H */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/sysdep.h
@@ -0,0 +1,49 @@
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KFREEBSD_MIPS_SYSDEP_H
+#define _KFREEBSD_MIPS_SYSDEP_H 1
+
+/* This drags in __syscall_error, keep in sync with Makefile in
+   this directory.  */
+#include <ports/sysdeps/unix/sysv/linux/mips/mips32/sysdep.h>
+
+/* Default INLINE_SYSCALL works but is buggy for 64-bit arguments
+   (breaks mmap, lseek...).  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...) __syscall_##name(args)
+
+/* Revert Linux kludge.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)  SYS_##syscall_name
+#else
+# define SYS_ify(syscall_name)  SYS_/**/syscall_name
+#endif
+
+/* Workaround for http://sources.redhat.com/bugzilla/show_bug.cgi?id=12301 */
+#ifdef __ASSEMBLER__
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+#endif   /* ! __ASSEMBLER__ */
+
+#endif /* _KFREEBSD_MIPS_SYSDEP_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips64/bits/mcontext.h
@@ -0,0 +1,116 @@
+/* Machine-dependent processor state structure for kFreeBSD.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  mips version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ucontext.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: ucontext.h,v 1.2 2007/08/09 11:23:32 katta
+ * $FreeBSD$
+ */
+
+typedef struct	__mcontext {
+	/*
+	 * These fields must match the corresponding fields in struct 
+	 * sigcontext which follow 'sc_mask'. That way we can support
+	 * struct sigcontext and ucontext_t at the same time.
+	 */
+	int		mc_onstack;	/* sigstack state to restore */
+	long int	mc_pc;		/* pc at time of signal */
+	long int	mc_regs[32];	/* processor regs 0 to 31 */
+        long int      sr;             /* status register */
+        long int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		mc_fpused;	/* fp has been used */
+	long int	mc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	long int	mc_fpc_eir;	/* fp exception instruction reg */
+	int	__spare__[8];	/* XXX reserved */ 
+} mcontext_t;
+
+#define	SZREG		4
+
+/* offsets into mcontext_t */
+#define	UCTX_REG(x)	(8 + (x)*SZREG)
+
+#define	UCR_ZERO	UCTX_REG(0)
+#define	UCR_AT		UCTX_REG(1)
+#define	UCR_V0		UCTX_REG(2)
+#define	UCR_V1		UCTX_REG(3)
+#define	UCR_A0		UCTX_REG(4)
+#define	UCR_A1		UCTX_REG(5)
+#define	UCR_A2		UCTX_REG(6)
+#define	UCR_A3		UCTX_REG(7)
+#define	UCR_T0		UCTX_REG(8)
+#define	UCR_T1		UCTX_REG(9)
+#define	UCR_T2		UCTX_REG(10)
+#define	UCR_T3		UCTX_REG(11)
+#define	UCR_T4		UCTX_REG(12)
+#define	UCR_T5		UCTX_REG(13)
+#define	UCR_T6		UCTX_REG(14)
+#define	UCR_T7		UCTX_REG(15)
+#define	UCR_S0		UCTX_REG(16)
+#define	UCR_S1		UCTX_REG(17)
+#define	UCR_S2		UCTX_REG(18)
+#define	UCR_S3		UCTX_REG(19)
+#define	UCR_S4		UCTX_REG(20)
+#define	UCR_S5		UCTX_REG(21)
+#define	UCR_S6		UCTX_REG(22)
+#define	UCR_S7		UCTX_REG(23)
+#define	UCR_T8		UCTX_REG(24)
+#define	UCR_T9		UCTX_REG(25)
+#define	UCR_K0		UCTX_REG(26)
+#define	UCR_K1		UCTX_REG(27)
+#define	UCR_GP		UCTX_REG(28)
+#define	UCR_SP		UCTX_REG(29)
+#define	UCR_S8		UCTX_REG(30)
+#define	UCR_RA		UCTX_REG(31)
+#define UCR_SR          UCTX_REG(32)
+#define	UCR_MDLO	UCTX_REG(33)
+#define	UCR_MDHI	UCTX_REG(34)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips64/bits/sigcontext.h
@@ -0,0 +1,92 @@
+/* Machine-dependent signal context structure for kFreeBSD.  mips version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/*	$OpenBSD: signal.h,v 1.2 1999/01/27 04:10:03 imp Exp $	*/
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)signal.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: signal.h,v 1.4 2007/01/08 04:58:37 katta
+ * $FreeBSD$
+ */
+
+/*
+ * Information pushed on stack when a signal is delivered.
+ * This is used by the kernel to restore state following
+ * execution of the signal handler.  It is also made available
+ * to the handler to allow it to restore state properly if
+ * a non-standard exit is performed.
+ */
+
+__extension__ struct sigcontext {
+	/*
+	 * The fields following 'sc_mask' must match the definition
+	 * of struct __mcontext. That way we can support
+	 * struct sigcontext and ucontext_t at the same
+	 * time.
+	 */
+	__sigset_t	sc_mask;	/* signal mask to restore */
+	int		sc_onstack;	/* sigstack state to restore */
+	long int	sc_pc;		/* pc at time of signal */
+	long int	sc_regs[32];	/* processor regs 0 to 31 */
+	long int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		sc_fpused;	/* fp has been used */
+	long int	sc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	long int	sc_fpc_eir;	/* fp exception instruction reg */
+	int		xxx[8];		/* XXX reserved */ 
+};
+
+#endif /* _BITS_SIGCONTEXT_H */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/start_thread.S
@@ -0,0 +1,56 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Modification for amd64 contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+/*
+   The parameters are passed in registers:
+   rdi: flags for rfork
+   rsi: child_stack
+   rdx: func
+   rcx: arg
+*/
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+
+#define SIG_SETMASK	3
+
+/* There is a window of a few instructions, right after the rfork
+   system call, where the handling of a signal would write garbage
+   into the stack shared by the parent and the child (assuming
+   RFMEM is set in flags).  To solve this: 1. We block all signals
+   around the rfork system call and unblock them afterwards in
+   the parent and in the child (but only after changing the stack
+   pointer).  2. The child accesses only values passed in registers
+   and on its own stack.  This way, if the parent is scheduled to
+   run first, and handles a signal, it will not affect the child;
+   and if the child runs first, and handles a signal, it will use
+   the child's stack and not affect the parent.
+*/
+
+/* FIXME */
+
+	.text
+ENTRY (__start_thread)
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/sys/tas.h
@@ -0,0 +1,2 @@
+/* workaround for http://sources.redhat.com/bugzilla/show_bug.cgi?id=12298 */
+#include <ports/sysdeps/unix/sysv/linux/mips/sys/tas.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mkdirat.c
@@ -0,0 +1,126 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write file the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Bosfilen, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_mkdirat (int fd, const char *path, mode_t mode);
+libc_hidden_proto (__syscall_mkdirat)
+
+/* Create a new direcfilery with permission bits MODE.  But interpret
+   relative PATH names relative file the direcfilery associated with FD.  */
+int
+mkdirat (fd, file, mode)
+     int fd;
+     const char *file;
+     mode_t mode;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (mkdirat, 3, fd, file, mode);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  return __mkdir (file, mode);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c
@@ -0,0 +1,86 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern void *__syscall_mmap (void *__addr, size_t __len, int __prot,
+			     int __flags, int __fd, __off_t __offset) __THROW;
+libc_hidden_proto (__syscall_mmap)
+extern void *__syscall_freebsd6_mmap (void *__addr, size_t __len, int __prot,
+			     int __flags, int __fd, int __unused1,
+			     __off_t __offset) __THROW;
+libc_hidden_proto (__syscall_freebsd6_mmap)
+extern ssize_t __syscall_freebsd6_pread (int __fd, void *__buf, size_t __nbytes,
+                                int __unused1, __off_t __offset) __THROW;
+libc_hidden_proto (__syscall_freebsd6_pread)
+
+void *
+__mmap (void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+  void *result;
+
+  /* Validity checks not done by the kernel.  */
+  if (offset != 0)
+    {
+      int pagesize = __getpagesize ();
+      if ((__builtin_expect (pagesize & (pagesize - 1), 0)
+        ? offset % pagesize
+	: offset & (pagesize - 1)))
+	{
+	  __set_errno (EINVAL);
+	  return (void *) (-1);
+	}
+    }
+
+  /* for ANON mapping we must pass -1 in place of fd */
+  if (flags & MAP_ANON)
+    fd = -1;
+
+  /* First try the new syscall. */
+  result = (void *) INLINE_SYSCALL (mmap, 6, addr, len, prot, flags, fd, offset);
+
+#ifndef __ASSUME_MMAP_SYSCALL
+  if (result == (void *) (-1) && errno == ENOSYS)
+    {
+      /* New syscall not available, use the old one. */
+      result = (void *) INLINE_SYSCALL (freebsd6_mmap, 7, addr, len, prot, flags, fd, 0, offset);
+      if (result != (void *) (-1) && fd >= 0 && len > 0)
+	{
+	  /* Force an update of the atime.  POSIX:2001 mandates that this happens
+	  at some time between the mmap() call and the first page-in.  Since
+	  the FreeBSD 6.0 kernel doesn't update the atime upon a page-in, we
+	  do it here.  */
+	  char dummy;
+	  INLINE_SYSCALL (freebsd6_pread, 5, fd, &dummy, 1, 0, offset);
+	}
+    }
+#endif
+
+  return result;
+}
+
+weak_alias (__mmap, mmap)
+
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
+strong_alias (__mmap, __mmap64)
+weak_alias (__mmap64, mmap64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c
@@ -0,0 +1 @@
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/munmap.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern int __syscall_munmap (void *__addr, size_t __len) __THROW;
+libc_hidden_proto (__syscall_munmap)
+
+int
+__munmap (void *addr, size_t len)
+{
+    int pagesize = __getpagesize ();
+    if ((unsigned long) addr & (pagesize - 1))
+    {
+	__set_errno (EINVAL);
+	return -1;
+    }
+  return INLINE_SYSCALL (munmap, 2, addr, len);
+}
+
+weak_alias (__munmap, munmap)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/ethernet.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 1997, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the FreeBSD version of this file. Curiously, that file
+   lacks a copyright in the header. */
+
+#ifndef __NET_ETHERNET_H
+#define __NET_ETHERNET_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <net/if_ether.h>     /* IEEE 802.3 Ethernet constants */
+
+__BEGIN_DECLS
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t octet[ETH_ALEN];
+#define ether_addr_octet octet  
+} __attribute__ ((__packed__));
+
+/* 10Mb/s ethernet header */
+struct ether_header
+{
+  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
+  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
+  u_int16_t ether_type;		        /* packet type ID field	*/
+} __attribute__ ((__packed__));
+
+/* Ethernet protocol ID's */
+#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
+#define	ETHERTYPE_IP		0x0800		/* IP */
+#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
+#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
+
+#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
+#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
+#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
+#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN) /* min packet length */
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN) /* max packet length */
+
+/* make sure ethenet length is valid */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
+
+__END_DECLS
+
+#endif	/* net/ethernet.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h
@@ -0,0 +1,451 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if.h,v 1.108 2007/06/11 20:08:11 andre Exp $
+ */
+
+#ifndef _NET_IF_H_
+#define	_NET_IF_H_
+
+#include <sys/cdefs.h>
+
+#include <features.h>
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+struct ifnet;
+
+/*
+ * Length of interface external name, including terminating '\0'.
+ * Note: this is the same size as a generic device's external name.
+ */
+#define		IF_NAMESIZE	16
+#define		IFNAMSIZ	IF_NAMESIZE
+#define		IF_MAXUNIT	0x7fff	/* historical value */
+
+/*
+ * Structure used to query names of interface cloners.
+ */
+
+struct if_clonereq {
+	int	ifcr_total;		/* total cloners (out) */
+	int	ifcr_count;		/* room for this many in user buffer */
+	char	*ifcr_buffer;		/* buffer for cloner names */
+};
+
+/*
+ * Structure describing information about an interface
+ * which may be of interest to management entities.
+ */
+struct if_data {
+	/* generic interface information */
+	unsigned char	ifi_type;		/* ethernet, tokenring, etc */
+	unsigned char	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
+	unsigned char	ifi_addrlen;		/* media address length */
+	unsigned char	ifi_hdrlen;		/* media header length */
+	unsigned char	ifi_link_state;		/* current link state */
+	unsigned char	ifi_spare_char1;	/* spare byte */
+	unsigned char	ifi_spare_char2;	/* spare byte */
+	unsigned char	ifi_datalen;		/* length of this data struct */
+	unsigned long	ifi_mtu;		/* maximum transmission unit */
+	unsigned long	ifi_metric;		/* routing metric (external only) */
+	unsigned long	ifi_baudrate;		/* linespeed */
+	/* volatile statistics */
+	unsigned long	ifi_ipackets;		/* packets received on interface */
+	unsigned long	ifi_ierrors;		/* input errors on interface */
+	unsigned long	ifi_opackets;		/* packets sent on interface */
+	unsigned long	ifi_oerrors;		/* output errors on interface */
+	unsigned long	ifi_collisions;		/* collisions on csma interfaces */
+	unsigned long	ifi_ibytes;		/* total number of octets received */
+	unsigned long	ifi_obytes;		/* total number of octets sent */
+	unsigned long	ifi_imcasts;		/* packets received via multicast */
+	unsigned long	ifi_omcasts;		/* packets sent via multicast */
+	unsigned long	ifi_iqdrops;		/* dropped on input, this interface */
+	unsigned long	ifi_noproto;		/* destined for unsupported protocol */
+	unsigned long	ifi_hwassist;		/* HW offload capabilities, see IFCAP */
+	time_t	ifi_epoch;		/* uptime at attach or stat reset */
+	struct	timeval ifi_lastchange;	/* time of last administrative change */
+};
+
+/*-
+ * Interface flags are of two types: network stack owned flags, and driver
+ * owned flags.  Historically, these values were stored in the same ifnet
+ * flags field, but with the advent of fine-grained locking, they have been
+ * broken out such that the network stack is responsible for synchronizing
+ * the stack-owned fields, and the device driver the device-owned fields.
+ * Both halves can perform lockless reads of the other half's field, subject
+ * to accepting the involved races.
+ *
+ * Both sets of flags come from the same number space, and should not be
+ * permitted to conflict, as they are exposed to user space via a single
+ * field.
+ *
+ * The following symbols identify read and write requirements for fields:
+ *
+ * (i) if_flags field set by device driver before attach, read-only there
+ *     after.
+ * (n) if_flags field written only by the network stack, read by either the
+ *     stack or driver.
+ * (d) if_drv_flags field written only by the device driver, read by either
+ *     the stack or driver.
+ */
+#define	IFF_UP		0x1		/* (n) interface is up */
+#define	IFF_BROADCAST	0x2		/* (i) broadcast address valid */
+#define	IFF_DEBUG	0x4		/* (n) turn on debugging */
+#define	IFF_LOOPBACK	0x8		/* (i) is a loopback net */
+#define	IFF_POINTOPOINT	0x10		/* (i) is a point-to-point link */
+#define	IFF_SMART	0x20		/* (i) interface manages own routes */
+#define	IFF_DRV_RUNNING	0x40		/* (d) resources allocated */
+#define	IFF_NOARP	0x80		/* (n) no address resolution protocol */
+#define	IFF_PROMISC	0x100		/* (n) receive all packets */
+#define	IFF_ALLMULTI	0x200		/* (n) receive all multicast packets */
+#define	IFF_DRV_OACTIVE	0x400		/* (d) tx hardware queue is full */
+#define	IFF_SIMPLEX	0x800		/* (i) can't hear own transmissions */
+#define	IFF_LINK0	0x1000		/* per link layer defined bit */
+#define	IFF_LINK1	0x2000		/* per link layer defined bit */
+#define	IFF_LINK2	0x4000		/* per link layer defined bit */
+#define	IFF_ALTPHYS	IFF_LINK2	/* use alternate physical connection */
+#define	IFF_MULTICAST	0x8000		/* (i) supports multicast */
+#define	IFF_CANTCONFIG	0x10000		/* (i) unconfigurable using ioctl(2) */
+#define	IFF_PPROMISC	0x20000		/* (n) user-requested promisc mode */
+#define	IFF_MONITOR	0x40000		/* (n) user-requested monitor mode */
+#define	IFF_STATICARP	0x80000		/* (n) static ARP */
+#define	IFF_NEEDSGIANT	0x100000	/* (i) hold Giant over if_start calls */
+#define IFF_DYING       0x200000        /* (n) interface is winding down */
+#define	IFF_RENAMING    0x400000        /* (n) interface is being renamed */
+
+/*
+ * Old names for driver flags so that user space tools can continue to use
+ * the old (portable) names.
+ */
+#ifndef _KERNEL
+#define	IFF_RUNNING	IFF_DRV_RUNNING
+#define	IFF_OACTIVE	IFF_DRV_OACTIVE
+#endif
+
+/* flags set internally only: */
+#define	IFF_CANTCHANGE \
+	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_DRV_RUNNING|IFF_DRV_OACTIVE|\
+	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|IFF_PROMISC|\
+	    IFF_DYING|IFF_CANTCONFIG)
+
+/*
+ * Values for if_link_state.
+ */
+#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
+#define	LINK_STATE_DOWN		1	/* link is down */
+#define	LINK_STATE_UP		2	/* link is up */
+
+/*
+ * Some convenience macros used for setting ifi_baudrate.
+ * XXX 1000 vs. 1024? --thorpej@netbsd.org
+ */
+#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
+#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
+#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
+
+/*
+ * Capabilities that interfaces can advertise.
+ *
+ * struct ifnet.if_capabilities
+ *   contains the optional features & capabilities a particular interface
+ *   supports (not only the driver but also the detected hw revision).
+ *   Capabilities are defined by IFCAP_* below.
+ * struct ifnet.if_capenable
+ *   contains the enabled (either by default or through ifconfig) optional
+ *   features & capabilities on this interface.
+ *   Capabilities are defined by IFCAP_* below.
+ * struct if_data.ifi_hwassist in mbuf CSUM_ flag form, controlled by above
+ *   contains the enabled optional feature & capabilites that can be used
+ *   individually per packet and are specified in the mbuf pkthdr.csum_flags
+ *   field.  IFCAP_* and CSUM_* do not match one to one and CSUM_* may be
+ *   more detailed or differenciated than IFCAP_*.
+ *   Hwassist features are defined CSUM_* in sys/mbuf.h
+ */
+#define	IFCAP_RXCSUM		0x00001  /* can offload checksum on RX */
+#define	IFCAP_TXCSUM		0x00002  /* can offload checksum on TX */
+#define	IFCAP_NETCONS		0x00004  /* can be a network console */
+#define	IFCAP_VLAN_MTU		0x00008	/* VLAN-compatible MTU */
+#define	IFCAP_VLAN_HWTAGGING	0x00010	/* hardware VLAN tag support */
+#define	IFCAP_JUMBO_MTU		0x00020	/* 9000 byte MTU supported */
+#define	IFCAP_POLLING		0x00040	/* driver supports polling */
+#define	IFCAP_VLAN_HWCSUM	0x00080	/* can do IFCAP_HWCSUM on VLANs */
+#define	IFCAP_TSO4		0x00100	/* can do TCP Segmentation Offload */
+#define	IFCAP_TSO6		0x00200	/* can do TCP6 Segmentation Offload */
+#define	IFCAP_LRO		0x00400	/* can do Large Receive Offload */
+#define	IFCAP_WOL_UCAST		0x00800	/* wake on any unicast frame */
+#define	IFCAP_WOL_MCAST		0x01000	/* wake on any multicast frame */
+#define	IFCAP_WOL_MAGIC		0x02000	/* wake on any Magic Packet */
+#define	IFCAP_TOE4		0x04000	/* interface can offload TCP */
+#define	IFCAP_TOE6		0x08000	/* interface can offload TCP6 */
+#define	IFCAP_VLAN_HWFILTER	0x10000 /* interface hw can filter vlan tag */
+#define IFCAP_POLLING_NOCOUNT   0x20000 /* polling ticks cannot be fragmented */
+#define	IFCAP_VLAN_HWTSO        0x40000 /* can do IFCAP_TSO on VLANs */
+#define	IFCAP_LINKSTATE         0x80000 /* the runtime link state is dynamic */
+
+#define	IFCAP_HWCSUM		(IFCAP_RXCSUM | IFCAP_TXCSUM)
+#define	IFCAP_TSO		(IFCAP_TSO4 | IFCAP_TSO6)
+#define	IFCAP_WOL		(IFCAP_WOL_UCAST | IFCAP_WOL_MCAST | IFCAP_WOL_MAGIC)
+#define	IFCAP_TOE		(IFCAP_TOE4 | IFCAP_TOE6)
+
+#define	IFQ_MAXLEN	50
+#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
+
+/*
+ * Message format for use in obtaining information about interfaces
+ * from getkerninfo and the routing socket
+ */
+struct if_msghdr {
+	unsigned short	ifm_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifm_version;	/* future binary compatibility */
+	unsigned char	ifm_type;	/* message type */
+	int	ifm_addrs;	/* like rtm_addrs */
+	int	ifm_flags;	/* value of if_flags */
+	unsigned short	ifm_index;	/* index for associated ifp */
+	struct	if_data ifm_data;/* statistics and other data about if */
+};
+
+/*
+ * Message format for use in obtaining information about interface addresses
+ * from getkerninfo and the routing socket
+ */
+struct ifa_msghdr {
+	unsigned short	ifam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifam_version;	/* future binary compatibility */
+	unsigned char	ifam_type;	/* message type */
+	int	ifam_addrs;	/* like rtm_addrs */
+	int	ifam_flags;	/* value of ifa_flags */
+	unsigned short	ifam_index;	/* index for associated ifp */
+	int	ifam_metric;	/* value of ifa_metric */
+};
+
+/*
+ * Message format for use in obtaining information about multicast addresses
+ * from the routing socket
+ */
+struct ifma_msghdr {
+	unsigned short	ifmam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifmam_version;	/* future binary compatibility */
+	unsigned char	ifmam_type;	/* message type */
+	int	ifmam_addrs;	/* like rtm_addrs */
+	int	ifmam_flags;	/* value of ifa_flags */
+	unsigned short	ifmam_index;	/* index for associated ifp */
+};
+
+/*
+ * Message format announcing the arrival or departure of a network interface.
+ */
+struct if_announcemsghdr {
+	unsigned short	ifan_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifan_version;	/* future binary compatibility */
+	unsigned char	ifan_type;	/* message type */
+	unsigned short	ifan_index;	/* index for associated ifp */
+	char	ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
+	unsigned short	ifan_what;	/* what type of announcement */
+};
+
+#define	IFAN_ARRIVAL	0	/* interface arrival */
+#define	IFAN_DEPARTURE	1	/* interface departure */
+
+/*
+ * Buffer with length to be used in SIOCGIFDESCR/SIOCSIFDESCR requests
+ */
+struct ifreq_buffer {
+	size_t  length;
+	void    *buffer;
+};
+ 
+/*
+ * Interface request structure used for socket
+ * ioctl's.  All interface ioctl's must have parameter
+ * definitions which begin with ifr_name.  The
+ * remainder may be interface specific.
+ */
+struct	ifreq {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		struct	sockaddr ifru_addr;
+		struct	sockaddr ifru_dstaddr;
+		struct	sockaddr ifru_broadaddr;
+		struct	sockaddr ifru_netmask;
+		struct  ifreq_buffer ifru_buffer;
+		short	ifru_flags[2];
+		short	ifru_index;
+		int	ifru_jid;
+		int	ifru_metric;
+		int	ifru_mtu;
+		int	ifru_phys;
+		int	ifru_media;
+		char *	ifru_data;
+		int	ifru_cap[2];
+	} ifr_ifru;
+#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
+#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
+#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
+#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
+#define	ifr_buffer      ifr_ifru.ifru_buffer    /* user supplied buffer with its length */
+#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags (low 16 bits) */
+#define	ifr_flagshigh	ifr_ifru.ifru_flags[1]	/* flags (high 16 bits) */
+#define ifr_jid         ifr_ifru.ifru_jid       /* jail/vnet */
+#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
+#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
+#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
+#define ifr_media	ifr_ifru.ifru_media	/* physical media */
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
+#define	ifr_reqcap	ifr_ifru.ifru_cap[0]	/* requested capabilities */
+#define	ifr_curcap	ifr_ifru.ifru_cap[1]	/* current capabilities */
+#define	ifr_index	ifr_ifru.ifru_index	/* interface index */
+};
+
+#define	_SIZEOF_ADDR_IFREQ(ifr) \
+	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
+	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
+	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))
+
+struct ifaliasreq {
+	char	ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	struct	sockaddr ifra_addr;
+	struct	sockaddr ifra_broadaddr;
+	struct	sockaddr ifra_mask;
+};
+
+struct ifmediareq {
+	char	ifm_name[IFNAMSIZ];	/* if name, e.g. "en0" */
+	int	ifm_current;		/* current media options */
+	int	ifm_mask;		/* don't care mask */
+	int	ifm_status;		/* media status */
+	int	ifm_active;		/* active options */
+	int	ifm_count;		/* # entries in ifm_ulist array */
+	int	*ifm_ulist;		/* media words */
+};
+
+struct  ifdrv {
+	char            ifd_name[IFNAMSIZ];     /* if name, e.g. "en0" */
+	unsigned long   ifd_cmd;
+	size_t          ifd_len;
+	void            *ifd_data;
+};
+
+/*
+ * Structure used to retrieve aux status data from interfaces.
+ * Kernel suppliers to this interface should respect the formatting
+ * needed by ifconfig(8): each line starts with a TAB and ends with
+ * a newline.  The canonical example to copy and paste is in if_tun.c.
+ */
+
+#define	IFSTATMAX	800		/* 10 lines of text */
+struct ifstat {
+	char	ifs_name[IFNAMSIZ];	/* if name, e.g. "en0" */
+	char	ascii[IFSTATMAX + 1];
+};
+
+/*
+ * Structure used in SIOCGIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible).
+ */
+struct	ifconf {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		char    *ifcu_buf;
+		struct	ifreq *ifcu_req;
+	} ifc_ifcu;
+#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
+#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
+};
+
+#if defined (__amd64__) || defined (COMPAT_32BIT)
+struct ifconf32 {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		unsigned int	ifcu_buf;
+		unsigned int	ifcu_req;
+	} ifc_ifcu;
+};
+#endif
+
+/*
+ * interface groups
+ */
+
+#define	IFG_ALL		"all"		/* group contains all interfaces */
+/* XXX: will we implement this? */
+#define	IFG_EGRESS	"egress"	/* if(s) default route(s) point to */
+
+struct ifg_req {
+	union {
+		char			 ifgrqu_group[IFNAMSIZ];
+		char			 ifgrqu_member[IFNAMSIZ];
+	} ifgrq_ifgrqu;
+#define	ifgrq_group	ifgrq_ifgrqu.ifgrqu_group
+#define	ifgrq_member	ifgrq_ifgrqu.ifgrqu_member
+};
+
+/*
+ * Used to lookup groups for an interface
+ */
+struct ifgroupreq {
+	char	ifgr_name[IFNAMSIZ];
+	unsigned int	ifgr_len;
+	union {
+		char	ifgru_group[IFNAMSIZ];
+		struct	ifg_req *ifgru_groups;
+	} ifgr_ifgru;
+#define ifgr_group	ifgr_ifgru.ifgru_group
+#define ifgr_groups	ifgr_ifgru.ifgru_groups
+};
+
+/*
+ * Structure for SIOC[AGD]LIFADDR
+ */
+struct if_laddrreq {
+	char	iflr_name[IFNAMSIZ];
+	unsigned int	flags;
+#define	IFLR_PREFIX	0x8000  /* in: prefix given  out: kernel fills id */
+	unsigned int	prefixlen;         /* in/out */
+	struct	sockaddr_storage addr;   /* in/out */
+	struct	sockaddr_storage dstaddr; /* out */
+};
+
+struct if_nameindex {
+	unsigned int	if_index;	/* 1, 2, ... */
+	char		*if_name;	/* null terminated name: "le0", ... */
+};
+
+__BEGIN_DECLS
+void			 if_freenameindex(struct if_nameindex *);
+char			*if_indextoname(unsigned int, char *);
+struct if_nameindex	*if_nameindex(void);
+unsigned int		 if_nametoindex(const char *);
+__END_DECLS
+
+#endif /* !_NET_IF_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if_ether.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NET_IF_ETHER_H
+#define _NET_IF_ETHER_H	1
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#endif	/* net/if_ether.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/icmp6.h
@@ -0,0 +1,525 @@
+/* Copyright (C) 1991-1997,2000,2006,2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NETINET_ICMP6_H
+#define _NETINET_ICMP6_H 1
+
+#include <inttypes.h>
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#define ICMP6_FILTER 18
+
+#define ICMP6_FILTER_BLOCK		1
+#define ICMP6_FILTER_PASS		2
+#define ICMP6_FILTER_BLOCKOTHERS	3
+#define ICMP6_FILTER_PASSONLY		4
+
+#define ICMPV6_PLD_MAXLEN	1232	/* IPV6_MMTU - sizeof(struct ip6_hdr)
+					   - sizeof(struct icmp6_hdr) */
+
+struct icmp6_filter
+  {
+    uint32_t icmp6_filt[8];
+  } __attribute__ ((__packed__));
+
+struct icmp6_hdr
+  {
+    uint8_t     icmp6_type;   /* type field */
+    uint8_t     icmp6_code;   /* code field */
+    uint16_t    icmp6_cksum;  /* checksum field */
+    union
+      {
+	uint32_t  icmp6_un_data32[1]; /* type-specific field */
+	uint16_t  icmp6_un_data16[2]; /* type-specific field */
+	uint8_t   icmp6_un_data8[4];  /* type-specific field */
+      } icmp6_dataun;
+  } __attribute__ ((__packed__));
+
+#define icmp6_data32    icmp6_dataun.icmp6_un_data32
+#define icmp6_data16    icmp6_dataun.icmp6_un_data16
+#define icmp6_data8     icmp6_dataun.icmp6_un_data8
+#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
+#define icmp6_mtu       icmp6_data32[0]  /* packet too big */
+#define icmp6_id        icmp6_data16[0]  /* echo request/reply */
+#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
+#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */
+
+#define ICMP6_DST_UNREACH             1
+#define ICMP6_PACKET_TOO_BIG          2
+#define ICMP6_TIME_EXCEEDED           3
+#define ICMP6_PARAM_PROB              4
+
+#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */
+
+#define ICMP6_NI_SUBJ_IPV6            0 /* Query Subject is an IPv6 address */
+#define ICMP6_NI_SUBJ_FQDN            1 /* Query Subject is a Domain name */
+#define ICMP6_NI_SUBJ_IPV4            2 /* Query Subject is an IPv4 address */
+
+#define ICMP6_NI_SUCCESS              0 /* node information successful reply */
+#define ICMP6_NI_REFUSED              1 /* node information request is refused */
+#define ICMP6_NI_UNKNOWN              2 /* unknown Qtype */
+
+#define ICMP6_ECHO_REQUEST          128
+#define ICMP6_ECHO_REPLY            129
+#define MLD_LISTENER_QUERY          130
+#define MLD_LISTENER_REPORT         131
+#define MLD_LISTENER_DONE           132
+#define MLD_LISTENER_REDUCTION      MLD_LISTENER_DONE
+
+/* RFC2292 decls */
+#define ICMP6_MEMBERSHIP_QUERY      130 /* group membership query */
+#define ICMP6_MEMBERSHIP_REPORT     131 /* group membership report */
+#define ICMP6_MEMBERSHIP_REDUCTION  132 /* group membership termination */
+/* the followings are for backward compatibility to old KAME apps. */
+#define MLD6_LISTENER_QUERY         MLD_LISTENER_QUERY
+#define MLD6_LISTENER_REPORT        MLD_LISTENER_REPORT
+#define MLD6_LISTENER_DONE          MLD_LISTENER_DONE
+
+
+#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */
+#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with destination */
+                                        /* administratively prohibited */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source address */
+#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */
+#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */
+
+#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */
+#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */
+
+#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */
+#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */
+#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */
+
+#define ICMP6_FILTER_WILLPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
+
+#define ICMP6_FILTER_WILLBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
+
+#define ICMP6_FILTER_SETPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETPASSALL(filterp) \
+	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
+
+#define ICMP6_FILTER_SETBLOCKALL(filterp) \
+	memset (filterp, 0, sizeof (struct icmp6_filter));
+
+#define ND_ROUTER_SOLICIT           133
+#define ND_ROUTER_ADVERT            134
+#define ND_NEIGHBOR_SOLICIT         135
+#define ND_NEIGHBOR_ADVERT          136
+#define ND_REDIRECT                 137
+
+struct nd_router_solicit      /* router solicitation */
+  {
+    struct icmp6_hdr  nd_rs_hdr;
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_rs_type               nd_rs_hdr.icmp6_type
+#define nd_rs_code               nd_rs_hdr.icmp6_code
+#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum
+#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]
+
+struct nd_router_advert       /* router advertisement */
+  {
+    struct icmp6_hdr  nd_ra_hdr;
+    uint32_t   nd_ra_reachable;   /* reachable time */
+    uint32_t   nd_ra_retransmit;  /* retransmit timer */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_ra_type               nd_ra_hdr.icmp6_type
+#define nd_ra_code               nd_ra_hdr.icmp6_code
+#define nd_ra_cksum              nd_ra_hdr.icmp6_cksum
+#define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]
+#define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]
+#define ND_RA_FLAG_MANAGED       0x80
+#define ND_RA_FLAG_OTHER         0x40
+#define ND_RA_FLAG_HOME_AGENT    0x20
+#define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]
+
+struct nd_neighbor_solicit    /* neighbor solicitation */
+  {
+    struct icmp6_hdr  nd_ns_hdr;
+    struct in6_addr   nd_ns_target; /* target address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_ns_type               nd_ns_hdr.icmp6_type
+#define nd_ns_code               nd_ns_hdr.icmp6_code
+#define nd_ns_cksum              nd_ns_hdr.icmp6_cksum
+#define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]
+
+struct nd_neighbor_advert     /* neighbor advertisement */
+  {
+    struct icmp6_hdr  nd_na_hdr;
+    struct in6_addr   nd_na_target; /* target address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_na_type               nd_na_hdr.icmp6_type
+#define nd_na_code               nd_na_hdr.icmp6_code
+#define nd_na_cksum              nd_na_hdr.icmp6_cksum
+#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
+#if     BYTE_ORDER == BIG_ENDIAN
+#define ND_NA_FLAG_ROUTER        0x80000000
+#define ND_NA_FLAG_SOLICITED     0x40000000
+#define ND_NA_FLAG_OVERRIDE      0x20000000
+#else   /* BYTE_ORDER == LITTLE_ENDIAN */
+#define ND_NA_FLAG_ROUTER        0x00000080
+#define ND_NA_FLAG_SOLICITED     0x00000040
+#define ND_NA_FLAG_OVERRIDE      0x00000020
+#endif
+
+struct nd_redirect            /* redirect */
+  {
+    struct icmp6_hdr  nd_rd_hdr;
+    struct in6_addr   nd_rd_target; /* target address */
+    struct in6_addr   nd_rd_dst;    /* destination address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));;
+
+#define nd_rd_type               nd_rd_hdr.icmp6_type
+#define nd_rd_code               nd_rd_hdr.icmp6_code
+#define nd_rd_cksum              nd_rd_hdr.icmp6_cksum
+#define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]
+
+struct nd_opt_hdr             /* Neighbor discovery option header */
+  {
+    uint8_t  nd_opt_type;
+    uint8_t  nd_opt_len;        /* in units of 8 octets */
+    /* followed by option specific data */
+  } __attribute__ ((__packed__));
+
+#define ND_OPT_SOURCE_LINKADDR		1
+#define ND_OPT_TARGET_LINKADDR		2
+#define ND_OPT_PREFIX_INFORMATION	3
+#define ND_OPT_REDIRECTED_HEADER	4
+#define ND_OPT_MTU			5
+#define ND_OPT_RTR_ADV_INTERVAL		7
+#define ND_OPT_HOME_AGENT_INFO		8
+
+struct nd_opt_prefix_info     /* prefix information */
+  {
+    uint8_t   nd_opt_pi_type;
+    uint8_t   nd_opt_pi_len;
+    uint8_t   nd_opt_pi_prefix_len;
+    uint8_t   nd_opt_pi_flags_reserved;
+    uint32_t  nd_opt_pi_valid_time;
+    uint32_t  nd_opt_pi_preferred_time;
+    uint32_t  nd_opt_pi_reserved2;
+    struct in6_addr  nd_opt_pi_prefix;
+  } __attribute__ ((__packed__));
+
+#define ND_OPT_PI_FLAG_ONLINK	0x80
+#define ND_OPT_PI_FLAG_AUTO	0x40
+#define ND_OPT_PI_FLAG_RADDR	0x20
+
+struct nd_opt_rd_hdr          /* redirected header */
+  {
+    uint8_t   nd_opt_rh_type;
+    uint8_t   nd_opt_rh_len;
+    uint16_t  nd_opt_rh_reserved1;
+    uint32_t  nd_opt_rh_reserved2;
+    /* followed by IP header and data */
+  } __attribute__ ((__packed__));
+
+struct nd_opt_mtu             /* MTU option */
+  {
+    uint8_t   nd_opt_mtu_type;
+    uint8_t   nd_opt_mtu_len;
+    uint16_t  nd_opt_mtu_reserved;
+    uint32_t  nd_opt_mtu_mtu;
+  } __attribute__ ((__packed__));
+
+struct mld_hdr
+  {
+    struct icmp6_hdr    mld_icmp6_hdr;
+    struct in6_addr     mld_addr; /* multicast address */
+  } __attribute__ ((__packed__));
+
+#define mld_type        mld_icmp6_hdr.icmp6_type
+#define mld_code        mld_icmp6_hdr.icmp6_code
+#define mld_cksum       mld_icmp6_hdr.icmp6_cksum
+#define mld_maxdelay    mld_icmp6_hdr.icmp6_data16[0]
+#define mld_reserved    mld_icmp6_hdr.icmp6_data16[1]
+
+/* definitions to provide backward compatibility to old KAME applications */
+#define mld6_hdr        mld_hdr
+#define mld6_type       mld_type
+#define mld6_code       mld_code
+#define mld6_cksum      mld_cksum
+#define mld6_maxdelay   mld_maxdelay
+#define mld6_reserved   mld_reserved
+#define mld6_addr       mld_addr
+
+#define ICMP6_ROUTER_RENUMBERING    138
+
+#define ICMP6_ROUTER_RENUMBERING_COMMAND  0 /* rr command */
+#define ICMP6_ROUTER_RENUMBERING_RESULT   1 /* rr result */
+#define ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET   255 /* rr seq num reset */
+
+struct icmp6_router_renum    /* router renumbering header */
+  {
+    struct icmp6_hdr    rr_hdr;
+    uint8_t             rr_segnum;
+    uint8_t             rr_flags;
+    uint16_t            rr_maxdelay;
+    uint32_t            rr_reserved;
+  } __attribute__ ((__packed__));
+
+#define rr_type		rr_hdr.icmp6_type
+#define rr_code         rr_hdr.icmp6_code
+#define rr_cksum        rr_hdr.icmp6_cksum
+#define rr_seqnum       rr_hdr.icmp6_data32[0]
+
+/* Router renumbering flags */
+#define ICMP6_RR_FLAGS_TEST             0x80
+#define ICMP6_RR_FLAGS_REQRESULT        0x40
+#define ICMP6_RR_FLAGS_FORCEAPPLY       0x20
+#define ICMP6_RR_FLAGS_SPECSITE         0x10
+#define ICMP6_RR_FLAGS_PREVDONE         0x08
+
+#define ICMP6_WRUREQUEST                139     /* who are you request */
+#define ICMP6_WRUREPLY                  140     /* who are you reply */
+#define ICMP6_FQDN_QUERY                139     /* FQDN query */
+#define ICMP6_FQDN_REPLY                140     /* FQDN reply */
+#define ICMP6_NI_QUERY                  139     /* node information request */
+#define ICMP6_NI_REPLY                  140     /* node information reply */
+
+struct rr_pco_match    /* match prefix part */
+  {
+    uint8_t             rpm_code;
+    uint8_t             rpm_len;
+    uint8_t             rpm_ordinal;
+    uint8_t             rpm_matchlen;
+    uint8_t             rpm_minlen;
+    uint8_t             rpm_maxlen;
+    uint16_t            rpm_reserved;
+    struct in6_addr     rpm_prefix;
+  } __attribute__ ((__packed__));
+
+/* PCO code values */
+#define RPM_PCO_ADD             1
+#define RPM_PCO_CHANGE          2
+#define RPM_PCO_SETGLOBAL       3
+#define RPM_PCO_MAX             4
+
+struct rr_pco_use      /* use prefix part */
+  {
+    uint8_t             rpu_uselen;
+    uint8_t             rpu_keeplen;
+    uint8_t             rpu_ramask;
+    uint8_t             rpu_raflags;
+    uint32_t            rpu_vltime;
+    uint32_t            rpu_pltime;
+    uint32_t            rpu_flags;
+    struct in6_addr     rpu_prefix;
+  } __attribute__ ((__packed__));
+
+#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK  0x80
+#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO    0x40
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40
+#endif
+
+struct rr_result       /* router renumbering result message */
+  {
+    uint16_t            rrr_flags;
+    uint8_t             rrr_ordinal;
+    uint8_t             rrr_matchedlen;
+    uint32_t            rrr_ifid;
+    struct in6_addr     rrr_prefix;
+  } __attribute__ ((__packed__));
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0002
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0200
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0100
+#endif
+
+/* Mobile IPv6 extension: Advertisement Interval.  */
+struct nd_opt_adv_interval
+  {
+    uint8_t   nd_opt_adv_interval_type;
+    uint8_t   nd_opt_adv_interval_len;
+    uint16_t  nd_opt_adv_interval_reserved;
+    uint32_t  nd_opt_adv_interval_ival;
+  };
+
+/* Mobile IPv6 extension: Home Agent Info.  */
+struct nd_opt_home_agent_info
+  {
+    uint8_t   nd_opt_home_agent_info_type;
+    uint8_t   nd_opt_home_agent_info_len;
+    uint16_t  nd_opt_home_agent_info_reserved;
+    uint16_t  nd_opt_home_agent_info_preference;
+    uint16_t  nd_opt_home_agent_info_lifetime;
+  };
+
+/*-
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+/*
+ * IP6 route structure
+ */
+
+struct route_in6 {
+        struct  rtentry *ro_rt;
+        struct  llentry *ro_lle;
+        struct  sockaddr_in6 ro_dst;
+};
+
+/*
+ * Variables related to this implementation
+ * of the internet control message protocol version 6.
+ */
+struct icmp6errstat {
+	u_quad_t icp6errs_dst_unreach_noroute;
+	u_quad_t icp6errs_dst_unreach_admin;
+	u_quad_t icp6errs_dst_unreach_beyondscope;
+	u_quad_t icp6errs_dst_unreach_addr;
+	u_quad_t icp6errs_dst_unreach_noport;
+	u_quad_t icp6errs_packet_too_big;
+	u_quad_t icp6errs_time_exceed_transit;
+	u_quad_t icp6errs_time_exceed_reassembly;
+	u_quad_t icp6errs_paramprob_header;
+	u_quad_t icp6errs_paramprob_nextheader;
+	u_quad_t icp6errs_paramprob_option;
+	u_quad_t icp6errs_redirect; /* we regard redirect as an error here */
+	u_quad_t icp6errs_unknown;
+};
+
+struct icmp6stat {
+/* statistics related to icmp6 packets generated */
+	u_quad_t icp6s_error;		/* # of calls to icmp6_error */
+	u_quad_t icp6s_canterror;	/* no error 'cuz old was icmp */
+	u_quad_t icp6s_toofreq;		/* no error 'cuz rate limitation */
+	u_quad_t icp6s_outhist[256];
+/* statistics related to input message processed */
+	u_quad_t icp6s_badcode;		/* icmp6_code out of range */
+	u_quad_t icp6s_tooshort;	/* packet < sizeof(struct icmp6_hdr) */
+	u_quad_t icp6s_checksum;	/* bad checksum */
+	u_quad_t icp6s_badlen;		/* calculated bound mismatch */
+	/*
+	 * number of responses: this member is inherited from netinet code, but
+	 * for netinet6 code, it is already available in icp6s_outhist[].
+	 */
+	u_quad_t icp6s_reflect;
+	u_quad_t icp6s_inhist[256];	
+	u_quad_t icp6s_nd_toomanyopt;	/* too many ND options */
+	struct icmp6errstat icp6s_outerrhist;
+#define icp6s_odst_unreach_noroute \
+	icp6s_outerrhist.icp6errs_dst_unreach_noroute
+#define icp6s_odst_unreach_admin icp6s_outerrhist.icp6errs_dst_unreach_admin
+#define icp6s_odst_unreach_beyondscope \
+	icp6s_outerrhist.icp6errs_dst_unreach_beyondscope
+#define icp6s_odst_unreach_addr icp6s_outerrhist.icp6errs_dst_unreach_addr
+#define icp6s_odst_unreach_noport icp6s_outerrhist.icp6errs_dst_unreach_noport
+#define icp6s_opacket_too_big icp6s_outerrhist.icp6errs_packet_too_big
+#define icp6s_otime_exceed_transit \
+	icp6s_outerrhist.icp6errs_time_exceed_transit
+#define icp6s_otime_exceed_reassembly \
+	icp6s_outerrhist.icp6errs_time_exceed_reassembly
+#define icp6s_oparamprob_header icp6s_outerrhist.icp6errs_paramprob_header
+#define icp6s_oparamprob_nextheader \
+	icp6s_outerrhist.icp6errs_paramprob_nextheader
+#define icp6s_oparamprob_option icp6s_outerrhist.icp6errs_paramprob_option
+#define icp6s_oredirect icp6s_outerrhist.icp6errs_redirect
+#define icp6s_ounknown icp6s_outerrhist.icp6errs_unknown
+	u_quad_t icp6s_pmtuchg;		/* path MTU changes */
+	u_quad_t icp6s_nd_badopt;	/* bad ND options */
+	u_quad_t icp6s_badns;		/* bad neighbor solicitation */
+	u_quad_t icp6s_badna;		/* bad neighbor advertisement */
+	u_quad_t icp6s_badrs;		/* bad router advertisement */
+	u_quad_t icp6s_badra;		/* bad router advertisement */
+	u_quad_t icp6s_badredirect;	/* bad redirect message */
+};
+
+#endif /* netinet/icmpv6.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/if_ether.h
@@ -0,0 +1,138 @@
+/* Copyright (C) 1996, 1997, 1999, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IF_ETHER_H
+
+#define __NETINET_IF_ETHER_H	1
+#include <features.h>
+#include <sys/types.h>
+
+#include <net/if_ether.h>
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
+ *	$FreeBSD$
+ */
+
+#include <net/ethernet.h>
+#include <net/if_arp.h>
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+/*
+ * Ethernet Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  Structure below is adapted
+ * to resolving internet addresses.  Field names used correspond to
+ * RFC 826.
+ */
+struct	ether_arp {
+	struct	arphdr ea_hdr;		/* fixed-size header */
+	u_int8_t arp_sha[ETH_ALEN];	/* sender hardware address */
+	u_int8_t arp_spa[4];		/* sender protocol address */
+	u_int8_t arp_tha[ETH_ALEN];	/* target hardware address */
+	u_int8_t arp_tpa[4];		/* target protocol address */
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+struct sockaddr_inarp {
+	__SOCKADDR_COMMON (sin_);
+	in_port_t sin_port;                 /* Port number.  */
+	struct in_addr sin_addr;            /* Internet address.  */
+	struct in_addr sin_srcaddr;
+	unsigned short sin_tos;
+	unsigned short sin_other;
+#define SIN_PROXY 1
+};
+
+/*
+ * IP and ethernet specific routing flags
+ */
+#define	RTF_USETRAILERS	RTF_PROTO1	/* use trailers */
+#define RTF_ANNOUNCE	RTF_PROTO2	/* announce new arp entry */
+
+/*
+ * Macro to map an IP multicast address to an Ethernet multicast address.
+ * The high-order 25 bits of the Ethernet address are statically assigned,
+ * and the low-order 23 bits are taken from the low end of the IP address.
+ */
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) \
+	/* struct in_addr *ipaddr; */ \
+	/* u_char enaddr[ETH_ALEN];	   */ \
+{ \
+	(enaddr)[0] = 0x01; \
+	(enaddr)[1] = 0x00; \
+	(enaddr)[2] = 0x5e; \
+	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f; \
+	(enaddr)[4] = ((u_int8_t *)ipaddr)[2]; \
+	(enaddr)[5] = ((u_int8_t *)ipaddr)[3]; \
+}
+
+/*
+ * Macro to map an IP6 multicast address to an Ethernet multicast address.
+ * The high-order 16 bits of the Ethernet address are statically assigned,
+ * and the low-order 32 bits are taken from the low end of the IP6 address.
+ */
+#define ETHER_MAP_IPV6_MULTICAST(ip6addr, enaddr)			\
+/* struct	in6_addr *ip6addr; */					\
+/* u_char	enaddr[ETH_ALEN]; */				\
+{                                                                       \
+	(enaddr)[0] = 0x33;						\
+	(enaddr)[1] = 0x33;						\
+	(enaddr)[2] = ((u_int8_t *)ip6addr)[12];				\
+	(enaddr)[3] = ((u_int8_t *)ip6addr)[13];				\
+	(enaddr)[4] = ((u_int8_t *)ip6addr)[14];				\
+	(enaddr)[5] = ((u_int8_t *)ip6addr)[15];				\
+}
+
+__END_DECLS
+#endif /* __USE_BSD */
+
+#endif /* netinet/if_ether.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h
@@ -0,0 +1,296 @@
+/* Copyright (C) 1991-1993, 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IP_ICMP_H
+#define __NETINET_IP_ICMP_H    1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+struct icmphdr
+{
+  u_int8_t type;		/* message type */
+  u_int8_t code;		/* type sub-code */
+  u_int16_t checksum;
+  union
+  {
+    struct
+    {
+      u_int16_t	id;
+      u_int16_t	sequence;
+    } echo;			/* echo datagram */
+    u_int32_t	gateway;	/* gateway address */
+    struct
+    {
+      u_int16_t	__unused;
+      u_int16_t	mtu;
+    } frag;			/* path mtu discovery */
+  } un;
+};
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+#ifdef __USE_BSD
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+/*
+ * Internal of an ICMP Router Advertisement
+ */
+struct icmp_ra_addr
+{
+  u_int32_t ira_addr;
+  u_int32_t ira_preference;
+};
+
+struct icmp
+{
+  u_int8_t  icmp_type;	/* type of message, see below */
+  u_int8_t  icmp_code;	/* type sub code */
+  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
+  union
+  {
+    u_char ih_pptr;		/* ICMP_PARAMPROB */
+    struct in_addr ih_gwaddr;	/* gateway address */
+    struct ih_idseq		/* echo datagram */
+    {
+      u_int16_t icd_id;
+      u_int16_t icd_seq;
+    } ih_idseq;
+    u_int32_t ih_void;
+
+    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
+    struct ih_pmtu
+    {
+      u_int16_t ipm_void;
+      u_int16_t ipm_nextmtu;
+    } ih_pmtu;
+
+    struct ih_rtradv
+    {
+      u_int8_t irt_num_addrs;
+      u_int8_t irt_wpa;
+      u_int16_t irt_lifetime;
+    } ih_rtradv;
+  } icmp_hun;
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+  union
+  {
+    struct
+    {
+      u_int32_t its_otime;
+      u_int32_t its_rtime;
+      u_int32_t its_ttime;
+    } id_ts;
+    struct
+    {
+      struct ip idi_ip;
+      /* options and then 64 bits of data */
+    } id_ip;
+    struct icmp_ra_addr id_radv;
+    u_int32_t   id_mask;
+    u_int8_t    id_data[1];
+  } icmp_dun;
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+};
+
+/*
+ * Lower bounds on packet lengths for various types.
+ * For the error advice packets must first insure that the
+ * packet is large enough to contain the returned ip header.
+ * Only then can we do the check to see if 64 bits of packet
+ * data have been returned, since we need to check the returned
+ * ip header length.
+ */
+#define	ICMP_MINLEN	8				/* abs minimum */
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
+#define	ICMP_MASKLEN	12				/* address mask */
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
+#ifndef _IP_VHL
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+	/* N.B.: must separately check that ip_hl >= 5 */
+#else
+#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
+	/* N.B.: must separately check that header length >= 5 */
+#endif
+
+/*
+ * Definition of type and code field values.
+ */
+#define	ICMP_ECHOREPLY		0		/* echo reply */
+#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
+#define		ICMP_UNREACH_NET	0		/* bad net */
+#define		ICMP_UNREACH_HOST	1		/* bad host */
+#define		ICMP_UNREACH_PROTOCOL	2		/* bad protocol */
+#define		ICMP_UNREACH_PORT	3		/* bad port */
+#define		ICMP_UNREACH_NEEDFRAG	4		/* IP_DF caused drop */
+#define		ICMP_UNREACH_SRCFAIL	5		/* src route failed */
+#define		ICMP_UNREACH_NET_UNKNOWN 6		/* unknown net */
+#define		ICMP_UNREACH_HOST_UNKNOWN 7		/* unknown host */
+#define		ICMP_UNREACH_ISOLATED	8		/* src host isolated */
+#define		ICMP_UNREACH_NET_PROHIB	9		/* prohibited access */
+#define		ICMP_UNREACH_HOST_PROHIB 10		/* ditto */
+#define		ICMP_UNREACH_TOSNET	11		/* bad tos for net */
+#define		ICMP_UNREACH_TOSHOST	12		/* bad tos for host */
+#define		ICMP_UNREACH_FILTER_PROHIB 13		/* admin prohib */
+#define		ICMP_UNREACH_HOST_PRECEDENCE 14		/* host prec vio. */
+#define		ICMP_UNREACH_PRECEDENCE_CUTOFF 15	/* prec cutoff */
+#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
+#define	ICMP_REDIRECT		5		/* shorter route, codes: */
+#define		ICMP_REDIRECT_NET	0		/* for network */
+#define		ICMP_REDIRECT_HOST	1		/* for host */
+#define		ICMP_REDIRECT_TOSNET	2		/* for tos and net */
+#define		ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
+#define	ICMP_ALTHOSTADDR	6		/* alternate host address */
+#define	ICMP_ECHO		8		/* echo service */
+#define	ICMP_ROUTERADVERT	9		/* router advertisement */
+#define		ICMP_ROUTERADVERT_NORMAL		0	/* normal advertisement */
+#define		ICMP_ROUTERADVERT_NOROUTE_COMMON	16	/* selective routing */
+#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
+#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
+#define		ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
+#define		ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
+#define	ICMP_PARAMPROB		12		/* ip header bad */
+#define		ICMP_PARAMPROB_ERRATPTR 0		/* error at param ptr */
+#define		ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
+#define		ICMP_PARAMPROB_LENGTH 2			/* bad length */
+#define	ICMP_TSTAMP		13		/* timestamp request */
+#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
+#define	ICMP_IREQ		15		/* information request */
+#define	ICMP_IREQREPLY		16		/* information reply */
+#define	ICMP_MASKREQ		17		/* address mask request */
+#define	ICMP_MASKREPLY		18		/* address mask reply */
+#define	ICMP_TRACEROUTE		30		/* traceroute */
+#define	ICMP_DATACONVERR	31		/* data conversion error */
+#define	ICMP_MOBILE_REDIRECT	32		/* mobile host redirect */
+#define	ICMP_IPV6_WHEREAREYOU	33		/* IPv6 where-are-you */
+#define	ICMP_IPV6_IAMHERE	34		/* IPv6 i-am-here */
+#define	ICMP_MOBILE_REGREQUEST	35		/* mobile registration req */
+#define	ICMP_MOBILE_REGREPLY	36		/* mobile registration reply */
+#define	ICMP_SKIP		39		/* SKIP */
+#define	ICMP_PHOTURIS		40		/* Photuris */
+#define		ICMP_PHOTURIS_UNKNOWN_INDEX	1	/* unknown sec index */
+#define		ICMP_PHOTURIS_AUTH_FAILED	2	/* auth failed */
+#define		ICMP_PHOTURIS_DECRYPT_FAILED	3	/* decrypt failed */
+
+#define	ICMP_MAXTYPE		40
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#endif /* __USE_BSD */
+
+__END_DECLS
+
+#endif /* netinet/ip_icmp.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h
@@ -0,0 +1,267 @@
+/* netinet/tcp.h
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_TCP_H
+#define _NETINET_TCP_H	1
+
+#include <features.h>
+#include <sys/queue.h>
+
+/*
+ * User-settable options (used with setsockopt).
+ */
+#define	TCP_NODELAY	 1	/* Don't delay send to coalesce packets  */
+#define	TCP_MAXSEG	 2	/* Set maximum segment size  */
+#define TCP_NOPUSH	 4	/* Don't push last block of write  */
+#define TCP_NOOPT	 8	/* Don't use TCP options  */
+#define TCP_MD5SIG	16	/* use MD5 digests (RFC2385) */
+#define TCP_INFO	32	/* retrieve tcp_info structure */
+#define TCP_CONGESTION  64	/* get/set congestion control algorithm */
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+
+typedef	u_int32_t tcp_seq;
+typedef	u_int32_t tcp_cc;	/* connection count, per RFC 1644 */
+
+/* Miscellaneous constants */
+#define MAX_SACK_BLKS   6       /* Max # SACK blocks stored at receiver side */   
+#define TCP_MAX_SACK    4       /* MAX # SACKs sent in any segment */
+
+# ifdef __FAVOR_BSD
+/*
+ * TCP header.
+ * Per RFC 793, September, 1981.
+ */
+struct tcphdr
+  {
+    u_int16_t th_sport;		/* source port */
+    u_int16_t th_dport;		/* destination port */
+    tcp_seq th_seq;		/* sequence number */
+    tcp_seq th_ack;		/* acknowledgement number */
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int8_t th_x2:4;		/* (unused) */
+    u_int8_t th_off:4;		/* data offset */
+#  endif
+#  if __BYTE_ORDER == __BIG_ENDIAN
+    u_int8_t th_off:4;		/* data offset */
+    u_int8_t th_x2:4;		/* (unused) */
+#  endif
+    u_int8_t th_flags;
+#  define TH_FIN	0x01
+#  define TH_SYN	0x02
+#  define TH_RST	0x04
+#  define TH_PUSH	0x08
+#  define TH_ACK	0x10
+#  define TH_URG	0x20
+    u_int16_t th_win;		/* window */
+    u_int16_t th_sum;		/* checksum */
+    u_int16_t th_urp;		/* urgent pointer */
+};
+
+# else /* !__FAVOR_BSD */
+struct tcphdr
+  {
+    u_int16_t source;
+    u_int16_t dest;
+    u_int32_t seq;
+    u_int32_t ack_seq;
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int16_t res1:4;
+    u_int16_t doff:4;
+    u_int16_t fin:1;
+    u_int16_t syn:1;
+    u_int16_t rst:1;
+    u_int16_t psh:1;
+    u_int16_t ack:1;
+    u_int16_t urg:1;
+    u_int16_t res2:2;
+#  elif __BYTE_ORDER == __BIG_ENDIAN
+    u_int16_t doff:4;
+    u_int16_t res1:4;
+    u_int16_t res2:2;
+    u_int16_t urg:1;
+    u_int16_t ack:1;
+    u_int16_t psh:1;
+    u_int16_t rst:1;
+    u_int16_t syn:1;
+    u_int16_t fin:1;
+#  else
+#   error "Adjust your <bits/endian.h> defines"
+#  endif
+    u_int16_t window;
+    u_int16_t check;
+    u_int16_t urg_ptr;
+};
+# endif /* __FAVOR_BSD */
+
+enum
+{
+  TCP_ESTABLISHED = 1,
+  TCP_SYN_SENT,
+  TCP_SYN_RECV,
+  TCP_FIN_WAIT1,
+  TCP_FIN_WAIT2,
+  TCP_TIME_WAIT,
+  TCP_CLOSE,
+  TCP_CLOSE_WAIT,
+  TCP_LAST_ACK,
+  TCP_LISTEN,
+  TCP_CLOSING   /* now a valid state */
+};
+
+# define TCPOPT_EOL		0
+# define TCPOPT_NOP		1
+# define TCPOPT_MAXSEG		2
+# define    TCPOLEN_MAXSEG		4
+# define TCPOPT_WINDOW		3
+# define    TCPOLEN_WINDOW		3
+# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
+# define    TCPOLEN_SACK_PERMITTED	2
+# define TCPOPT_SACK		5		/* Experimental */
+# define TCPOPT_TIMESTAMP	8
+# define    TCPOLEN_TIMESTAMP	10
+# define    TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */
+# define    TCPOPT_TSTAMP_HDR	\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)
+#define	TCPOPT_CC		11		/* CC options: RFC-1644 */
+#define TCPOPT_CCNEW		12
+#define TCPOPT_CCECHO		13
+#define	   TCPOLEN_CC			6
+#define	   TCPOLEN_CC_APPA		(TCPOLEN_CC+2)
+#define	   TCPOPT_CC_HDR(ccopt)		\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|(ccopt)<<8|TCPOLEN_CC)
+
+/*
+ * Default maximum segment size for TCP.
+ * With an IP MSS of 576, this is 536,
+ * but 512 is probably more convenient.
+ * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
+ */
+# define TCP_MSS	512
+
+/*
+ * Default maximum segment size for TCP6.
+ * With an IP MSS of 1280, this is 1220,
+ * but 1024 is probably more convenient.
+ * This should be defined as MIN(1024, IP6_MSS - sizeof (struct tcpip6hdr)).
+ */
+# define TCP6_MSS	1024
+
+# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */
+# define TTCP_CLIENT_SND_WND 4096 /* default send window for T/TCP client */
+
+# define TCP_MAX_WINSHIFT	14	/* maximum window shift */
+
+#define TCP_MAXBURST		4	/* maximum segments in a burst */
+
+#define TCP_MAXHLEN	(0xf<<2)	/* max length of header in bytes */
+#define TCP_MAXOLEN	(TCP_MAXHLEN - sizeof (struct tcphdr))
+					/* max space left for options */
+
+# define SOL_TCP		6	/* TCP level */
+
+
+# define TCPI_OPT_TIMESTAMPS	1
+# define TCPI_OPT_SACK		2
+# define TCPI_OPT_WSCALE	4
+# define TCPI_OPT_ECN		8
+
+/* Values for tcpi_state.  */
+enum tcp_ca_state
+{
+  TCP_CA_Open = 0,
+  TCP_CA_Disorder = 1,
+  TCP_CA_CWR = 2,
+  TCP_CA_Recovery = 3,
+  TCP_CA_Loss = 4
+};
+
+struct tcp_info
+{
+  u_int8_t	tcpi_state;
+  u_int8_t	tcpi_ca_state;
+  u_int8_t	tcpi_retransmits;
+  u_int8_t	tcpi_probes;
+  u_int8_t	tcpi_backoff;
+  u_int8_t	tcpi_options;
+  u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+
+  u_int32_t	tcpi_rto;
+  u_int32_t	tcpi_ato;
+  u_int32_t	tcpi_snd_mss;
+  u_int32_t	tcpi_rcv_mss;
+
+  u_int32_t	tcpi_unacked;
+  u_int32_t	tcpi_sacked;
+  u_int32_t	tcpi_lost;
+  u_int32_t	tcpi_retrans;
+  u_int32_t	tcpi_fackets;
+
+  /* Times. */
+  u_int32_t	tcpi_last_data_sent;
+  u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
+  u_int32_t	tcpi_last_data_recv;
+  u_int32_t	tcpi_last_ack_recv;
+
+  /* Metrics. */
+  u_int32_t	tcpi_pmtu;
+  u_int32_t	tcpi_rcv_ssthresh;
+  u_int32_t	tcpi_rtt;
+  u_int32_t	tcpi_rttvar;
+  u_int32_t	tcpi_snd_ssthresh;
+  u_int32_t	tcpi_snd_cwnd;
+  u_int32_t	tcpi_advmss;
+  u_int32_t	tcpi_reordering;
+};
+
+#endif /* Misc.  */
+
+#endif /* netinet/tcp.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nfs/nfs.h
@@ -0,0 +1,3 @@
+#include <stdint.h>
+#include <sys/mount.h>
+#include <nfs/nfsproto.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/not-cancel.h
@@ -0,0 +1,91 @@
+/* Uncancelable versions of cancelable interfaces.  kFreeBSD version.
+   Copyright (C) 2003, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sysdep.h>
+
+/* Uncancelable open.  */
+#define open_not_cancel(name, flags, mode) \
+   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
+#define open_not_cancel_2(name, flags) \
+   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+
+/* Uncancelable openat.  */
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+extern int __openat_nocancel (int fd, const char *fname, int oflag,
+			      mode_t mode) attribute_hidden;
+extern int __openat64_nocancel (int fd, const char *fname, int oflag,
+				mode_t mode) attribute_hidden;
+#else
+# define __openat_nocancel(fd, fname, oflag, mode) \
+  openat (fd, fname, oflag, mode)
+# define __openat64_nocancel(fd, fname, oflag, mode) \
+  openat64 (fd, fname, oflag, mode)
+#endif
+
+#define openat_not_cancel(fd, fname, oflag, mode) \
+  __openat_nocancel (fd, fname, oflag, mode)
+#define openat_not_cancel_3(fd, fname, oflag) \
+  __openat_nocancel (fd, fname, oflag, 0)
+#define openat64_not_cancel(fd, fname, oflag, mode) \
+  __openat64_nocancel (fd, fname, oflag, mode)
+#define openat64_not_cancel_3(fd, fname, oflag) \
+  __openat64_nocancel (fd, fname, oflag, 0)
+
+/* Uncancelable close.  */
+#define close_not_cancel(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+
+#define close_not_cancel_no_status(fd) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err); \
+	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+
+/* Uncancelable read.  */
+#define read_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+
+/* Uncancelable write.  */
+#define write_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+
+/* Uncancelable writev.  */
+#define writev_not_cancel_no_status(fd, iov, n) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err); \
+	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+
+/* Uncancelable fcntl.  */
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl_nocancel (fd, cmd, val)
+
+/* Uncancelable waitpid.  */
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
+
+/* Uncancelable pause.  */
+# define pause_not_cancel() \
+  __pause_nocancel ()
+
+/* Uncancelable nanosleep.  */
+# define nanosleep_not_cancel(requested_time, remaining) \
+  INLINE_SYSCALL (nanosleep, 2, requested_time, remaining)
+
+/* Uncancelable sigsuspend.  */
+#define sigsuspend_not_cancel(set) \
+  INLINE_SYSCALL (sigsuspend, 1, set)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/Implies
@@ -0,0 +1 @@
+pthread
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/bits/local_lim.h
@@ -0,0 +1,48 @@
+/* Minimum guaranteed maximum values for system limits.  FreeBSD version.
+   Copyright (C) 1993-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/syslimits.h>
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* This is the value this implementation supports.  */
+#define PTHREAD_THREADS_MAX	1024
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
+
+/* Maximum number of POSIX timers available.  */
+#define TIMER_MAX	256
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/bits/posix_opt.h
@@ -0,0 +1,190 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	200809L
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	200809L
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200809L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200809L
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	200809L
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200809L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200809L
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+/* X/Open realtime support is only partially available.  */
+#define _XOPEN_REALTIME	-1
+
+/* X/Open realtime thread support is only partially available.  */
+#define _XOPEN_REALTIME_THREADS	-1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200809L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS	1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
+
+/* We provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200809L
+
+/* We support POSIX.1b semaphores, but only the non-shared form for now.  */
+#define _POSIX_SEMAPHORES	200809L
+
+/* Real-time signals are not available.  */
+#define _POSIX_REALTIME_SIGNALS	-1
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	200809L
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+/* Support for prioritization is not available.  */
+#define _POSIX_PRIORITIZED_IO	-1
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	1
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
+
+/* CPU-time clocks somewhere supported.  */
+#define _POSIX_CPUTIME	0
+
+/* We support somewhere the clock also in threads.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200809L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200809L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200809L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200809L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	200809L
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200809L
+
+/* POSIX message queues are not available.  */
+#define _POSIX_MESSAGE_PASSING	-1
+
+/* Thread process-shared synchronization is not supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	-1
+
+/* The monotonic clock is available.  */
+#define _POSIX_MONOTONIC_CLOCK	200809L
+
+/* The clock selection interfaces are not available.  */
+#define _POSIX_CLOCK_SELECTION	-1
+
+/* Advisory information interfaces are not available.  */
+#define _POSIX_ADVISORY_INFO	-1
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200809L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200809L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200809L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+/* No support for priority inheritance or protection.  */
+#define _POSIX_THREAD_PRIO_INHERIT	-1
+#define _POSIX_THREAD_PRIO_PROTECT	-1
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/kernel-posix-timers.h
@@ -0,0 +1,119 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/_types.h>
+
+
+/* Nonzero if the system calls are not available.  */
+extern int __no_posix_timers attribute_hidden;
+
+/* Callback to start helper thread.  */
+extern void __start_helper_thread (void) attribute_hidden;
+
+/* Control variable for helper thread creation.  */
+extern pthread_once_t __helper_once attribute_hidden;
+
+/* TID of the helper thread.  */
+extern __lwpid_t __helper_tid attribute_hidden;
+
+/* List of active SIGEV_THREAD timers.  */
+extern struct timer *__active_timer_sigev_thread attribute_hidden;
+/* Lock for the __active_timer_sigev_thread.  */
+extern pthread_mutex_t __active_timer_sigev_thread_lock attribute_hidden;
+
+
+/* Type of timers in the kernel.  */
+typedef int kernel_timer_t;
+
+
+/* Internal representation of timer.  */
+struct timer
+{
+  /* Notification mechanism.  */
+  int sigev_notify;
+
+  /* Timer ID returned by the kernel.  */
+  kernel_timer_t ktimerid;
+
+  /* All new elements must be added after ktimerid.  And if the thrfunc
+     element is not the third element anymore the memory allocation in
+     timer_create needs to be changed.  */
+
+  /* Parameters for the thread to be started for SIGEV_THREAD.  */
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+  pthread_attr_t attr;
+
+  /* Next element in list of active SIGEV_THREAD timers.  */
+  struct timer *next;
+};
+
+extern struct timer *__all_timers[TIMER_MAX];
+
+static inline struct timer *
+__kfreebsd_timer_alloc ()
+{
+  unsigned int i;
+  struct timer *timer = malloc (sizeof (struct timer));
+
+  /* Find a free slot (and reserve it atomically).  */
+  for (i = 0; i < TIMER_MAX; i++)
+    if (atomic_compare_and_exchange_val_acq (&__all_timers[i],
+					     timer, NULL) == NULL)
+      return timer;
+
+  errno = EAGAIN;
+  return NULL;
+}
+
+static inline struct timer *
+__kfreebsd_timer_id2ptr (timer_t id)
+{
+  void *ret = NULL;
+
+  if (id >= 0 && id < TIMER_MAX)
+    ret = __all_timers[id];
+
+  if (! ret)
+    errno = EINVAL;
+
+  return ret;
+}
+
+static inline timer_t
+__kfreebsd_timer_ptr2id (struct timer *ptr)
+{
+  unsigned int i;
+  for (i = 0; i < TIMER_MAX; i++)
+    if (__all_timers[i] == ptr)
+      return i;
+
+  return -1;
+}
+
+void static inline
+__kfreebsd_timer_free (struct timer *ptr)
+{
+  __all_timers[__kfreebsd_timer_ptr2id (ptr)] = NULL;
+  free (ptr);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_create.c
@@ -0,0 +1,229 @@
+/* Copyright (C) 2003,2004, 2007, 2009, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include <internaltypes.h>
+#include <nptl/pthreadP.h>
+#include "kernel-posix-timers.h"
+#include "kernel-posix-cpu-timers.h"
+
+
+#ifdef SYS_ktimer_create
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_create (clockid_t clock_id, struct sigevent *evp,
+				timer_t *timerid);
+#  define timer_create static compat_timer_create
+#  include <nptl/sysdeps/pthread/timer_create.c>
+#  undef timer_create
+
+/* Nonzero if the system calls are not available.  */
+int __no_posix_timers attribute_hidden;
+# endif
+
+# ifdef timer_create_alias
+#  define timer_create timer_create_alias
+# endif
+
+
+int
+timer_create (clock_id, evp, timerid)
+     clockid_t clock_id;
+     struct sigevent *evp;
+     timer_t *timerid;
+{
+# undef timer_create
+# ifndef __ASSUME_POSIX_TIMERS
+  if  (__no_posix_timers >= 0)
+# endif
+    {
+      /* If the user wants notification via a thread we need to handle
+	 this special.  */
+      if (evp == NULL
+	  || __builtin_expect (evp->sigev_notify != SIGEV_THREAD, 1))
+	{
+	  struct sigevent local_evp;
+
+	  struct timer *newp = __kfreebsd_timer_alloc ();
+
+	  if (newp == NULL)
+	    /* No more memory.  */
+	    return -1;
+
+	  if (evp == NULL)
+	    {
+	      /* The kernel has to pass up the timer ID which is a
+		 userlevel object.  Therefore we cannot leave it up to
+		 the kernel to determine it.  */
+	      local_evp.sigev_notify = SIGEV_SIGNAL;
+	      local_evp.sigev_signo = SIGALRM;
+	      local_evp.sigev_value.sival_ptr = newp;
+
+	      evp = &local_evp;
+	    }
+
+	  kernel_timer_t ktimerid;
+	  int retval = INLINE_SYSCALL (ktimer_create, 3, clock_id, evp,
+				       &ktimerid);
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  if (retval != -1 || errno != ENOSYS)
+# endif
+	    {
+# ifndef __ASSUME_POSIX_TIMERS
+	      __no_posix_timers = 1;
+# endif
+
+	      if (retval != -1)
+		{
+		  newp->sigev_notify = (evp != NULL
+					? evp->sigev_notify : SIGEV_SIGNAL);
+		  newp->ktimerid = ktimerid;
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		}
+	      else
+		{
+		  /* Cannot allocate the timer, fail.  */
+		  __kfreebsd_timer_free (newp);
+		  retval = -1;
+		}
+
+	      return retval;
+	    }
+
+	  __kfreebsd_timer_free (newp);
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* When we come here the syscall does not exist.  Make sure we
+	     do not try to use it again.  */
+	  __no_posix_timers = -1;
+# endif
+	}
+      else
+	{
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* Make sure we have the necessary kernel support.  */
+	  if (__no_posix_timers == 0)
+	    {
+	      struct timespec ts;
+	      int res;
+	      res = INLINE_SYSCALL (clock_getres, 2,
+				    CLOCK_REALTIME, &ts);
+	      __no_posix_timers = (res == -1 ? -1 : 1);
+	    }
+
+	  if (__no_posix_timers > 0)
+# endif
+	    {
+	      /* Create the helper thread.  */
+	      pthread_once (&__helper_once, __start_helper_thread);
+	      if (__helper_tid == 0)
+		{
+		  /* No resources to start the helper thread.  */
+		  __set_errno (EAGAIN);
+		  return -1;
+		}
+
+	      struct timer *newp;
+	      newp = __kfreebsd_timer_alloc ();
+	      if (newp == NULL)
+		return -1;
+
+	      /* Copy the thread parameters the user provided.  */
+	      newp->sival = evp->sigev_value;
+	      newp->thrfunc = evp->sigev_notify_function;
+	      newp->sigev_notify = SIGEV_THREAD;
+
+	      /* We cannot simply copy the thread attributes since the
+		 implementation might keep internal information for
+		 each instance.  */
+	      (void) pthread_attr_init (&newp->attr);
+	      if (evp->sigev_notify_attributes != NULL)
+		{
+		  struct pthread_attr *nattr;
+		  struct pthread_attr *oattr;
+
+		  nattr = (struct pthread_attr *) &newp->attr;
+		  oattr = (struct pthread_attr *) evp->sigev_notify_attributes;
+
+		  nattr->schedparam = oattr->schedparam;
+		  nattr->schedpolicy = oattr->schedpolicy;
+		  nattr->flags = oattr->flags;
+		  nattr->guardsize = oattr->guardsize;
+		  nattr->stackaddr = oattr->stackaddr;
+		  nattr->stacksize = oattr->stacksize;
+		}
+
+	      /* In any case set the detach flag.  */
+	      (void) pthread_attr_setdetachstate (&newp->attr,
+						  PTHREAD_CREATE_DETACHED);
+
+	      /* Create the event structure for the kernel timer.  */
+	      struct sigevent sev =
+		{ .sigev_value.sival_ptr = newp,
+		  .sigev_signo = SIGTIMER,
+		  .sigev_notify = SIGEV_THREAD_ID,
+		  .sigev_notify_thread_id = __helper_tid,
+		};
+
+	      /* Create the timer.  */
+	      int res;
+	      res = INLINE_SYSCALL (ktimer_create, 3,
+				      clock_id, &sev, &newp->ktimerid);
+	      if (res != -1)
+		{
+		  /* Add to the queue of active timers with thread
+		     delivery.  */
+		  pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+		  newp->next = __active_timer_sigev_thread;
+		  __active_timer_sigev_thread = newp;
+		  pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		  return 0;
+		}
+
+	      /* Free the resources.  */
+	      __kfreebsd_timer_free (newp);
+
+	      return -1;
+	    }
+	}
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  /* Compatibility code.  */
+  return compat_timer_create (clock_id, evp, timerid);
+# endif
+}
+#else
+# ifdef timer_create_alias
+#  define timer_create timer_create_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <nptl/sysdeps/pthread/timer_create.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_delete.c
@@ -0,0 +1,117 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_delete
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_delete (timer_t timerid);
+#  define timer_delete static compat_timer_delete
+#  include <nptl/sysdeps/pthread/timer_delete.c>
+#  undef timer_delete
+# endif
+
+# ifdef timer_delete_alias
+#  define timer_delete timer_delete_alias
+# endif
+
+
+int
+timer_delete (timerid)
+     timer_t timerid;
+{
+# undef timer_delete
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_delete, 1, kt->ktimerid);
+
+      if (res == 0)
+	{
+	  if (kt->sigev_notify == SIGEV_THREAD)
+	    {
+	      /* Remove the timer from the list.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+	      if (__active_timer_sigev_thread == kt)
+		__active_timer_sigev_thread = kt->next;
+	      else
+		{
+		  struct timer *prevp = __active_timer_sigev_thread;
+		  while (prevp->next != NULL)
+		    if (prevp->next == kt)
+		      {
+			prevp->next = kt->next;
+			break;
+		      }
+		    else
+		      prevp = prevp->next;
+		}
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+
+	  /* Free the memory.  */
+	  (void) __kfreebsd_timer_free (kt);
+
+	  return 0;
+	}
+
+      /* The kernel timer is not known or something else bad happened.
+	 Return the error.  */
+# ifndef __ASSUME_POSIX_TIMERS
+      if (errno != ENOSYS)
+	{
+	  __no_posix_timers = 1;
+# endif
+	  return -1;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_delete (timerid);
+# endif
+}
+#else
+# ifdef timer_delete_alias
+#  define timer_delete timer_delete_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <nptl/sysdeps/pthread/timer_delete.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_getoverr.c
@@ -0,0 +1,83 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_getoverrun
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_getoverrun (timer_t timerid);
+#  define timer_getoverrun static compat_timer_getoverrun
+#  include <nptl/sysdeps/pthread/timer_getoverr.c>
+#  undef timer_getoverrun
+# endif
+
+# ifdef timer_getoverrun_alias
+#  define timer_getoverrun timer_getoverrun_alias
+# endif
+
+
+int
+timer_getoverrun (timerid)
+     timer_t timerid;
+{
+# undef timer_getoverrun
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Get the information from the kernel.  */
+      int res = INLINE_SYSCALL (ktimer_getoverrun, 1, kt->ktimerid);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_getoverrun (timerid);
+# endif
+}
+#else
+# ifdef timer_getoverrun_alias
+#  define timer_getoverrun timer_getoverrun_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <nptl/sysdeps/pthread/timer_getoverr.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_gettime.c
@@ -0,0 +1,85 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_gettime
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_gettime (timer_t timerid, struct itimerspec *value);
+#  define timer_gettime static compat_timer_gettime
+#  include <nptl/sysdeps/pthread/timer_gettime.c>
+#  undef timer_gettime
+# endif
+
+# ifdef timer_gettime_alias
+#  define timer_gettime timer_gettime_alias
+# endif
+
+
+int
+timer_gettime (timerid, value)
+     timer_t timerid;
+     struct itimerspec *value;
+{
+# undef timer_gettime
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_gettime, 2, kt->ktimerid, value);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_gettime (timerid, value);
+# endif
+}
+#else
+# ifdef timer_gettime_alias
+#  define timer_gettime timer_gettime_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <nptl/sysdeps/pthread/timer_gettime.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_routines.c
@@ -0,0 +1,208 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <sysdep.h>
+#include <sys/_types.h> /* __lwpid_t */
+#include <atomic.h>
+#include <kernel-features.h>
+#include <nptl/pthreadP.h>
+#include "kernel-posix-timers.h"
+
+/* NPTL/Linux simply casts "timer_t" to "struct timer *", but on
+   kFreeBSD timer_t may not be large enough to hold a pointer.
+   So we store the pointers here... (sigh) */
+struct timer *__all_timers[TIMER_MAX];
+
+/* List of active SIGEV_THREAD timers.  */
+struct timer *__active_timer_sigev_thread;
+/* Lock for the __active_timer_sigev_thread.  */
+pthread_mutex_t __active_timer_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
+
+
+struct thread_start_data
+{
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+};
+
+
+#ifdef SYS_ktimer_create
+/* Helper thread to call the user-provided function.  */
+static void *
+timer_sigev_thread (void *arg)
+{
+  /* The parent thread has all signals blocked.  This is a bit
+     surprising for user code, although valid.  We unblock all
+     signals.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+  sigprocmask (SIG_SETMASK, &ss, NULL);
+
+  struct thread_start_data *td = (struct thread_start_data *) arg;
+
+  void (*thrfunc) (sigval_t) = td->thrfunc;
+  sigval_t sival = td->sival;
+
+  /* The TD object was allocated in timer_helper_thread.  */
+  free (td);
+
+  /* Call the user-provided function.  */
+  thrfunc (sival);
+
+  return NULL;
+}
+
+
+/* Helper function to support starting threads for SIGEV_THREAD.  */
+static void *
+timer_helper_thread (void *arg)
+{
+  /* Wait for the SIGTIMER signal, allowing the setXid signal, and
+     none else.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+  __sigaddset (&ss, SIGTIMER);
+
+  /* Endless loop of waiting for signals.  The loop is only ended when
+     the thread is canceled.  */
+  while (1)
+    {
+      siginfo_t si;
+
+      /* sigwaitinfo cannot be used here, since it deletes
+	 SIGCANCEL == SIGTIMER from the set.  */
+
+      int oldtype = LIBC_CANCEL_ASYNC ();
+
+      /* XXX The size argument hopefully will have to be changed to the
+	 real size of the user-level sigset_t.  */
+      int result = sigtimedwait (&ss, &si, NULL);
+
+      LIBC_CANCEL_RESET (oldtype);
+
+      if (result > 0)
+	{
+	  if (si.si_code == SI_TIMER)
+	    {
+	      struct timer *tk = (struct timer *) si.si_value.sival_ptr;
+
+	      /* Check the timer is still used and will not go away
+		 while we are reading the values here.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+
+	      struct timer *runp = __active_timer_sigev_thread;
+	      while (runp != NULL)
+		if (runp == tk)
+		  break;
+		else
+		  runp = runp->next;
+
+	      if (runp != NULL)
+		{
+		  struct thread_start_data *td = malloc (sizeof (*td));
+
+		  /* There is not much we can do if the allocation fails.  */
+		  if (td != NULL)
+		    {
+		      /* This is the signal we are waiting for.  */
+		      td->thrfunc = tk->thrfunc;
+		      td->sival = tk->sival;
+
+		      pthread_t th;
+		      (void) pthread_create (&th, &tk->attr,
+					     timer_sigev_thread, td);
+		    }
+		}
+
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+	  else if (si.si_code == SI_LWP
+		   /* Backward compatibility (see rev 211732 in -CURRENT).  */
+		   || si.si_code == SI_USER)
+	    /* The thread is canceled.  */
+	    pthread_exit (NULL);
+	}
+    }
+}
+
+
+/* Control variable for helper thread creation.  */
+pthread_once_t __helper_once attribute_hidden;
+
+
+/* TID of the helper thread.  */
+__lwpid_t __helper_tid attribute_hidden;
+
+
+/* Reset variables so that after a fork a new helper thread gets started.  */
+static void
+reset_helper_control (void)
+{
+  __helper_once = PTHREAD_ONCE_INIT;
+  __helper_tid = 0;
+}
+
+
+void
+attribute_hidden
+__start_helper_thread (void)
+{
+  /* The helper thread needs only very little resources
+     and should go away automatically when canceled.  */
+  pthread_attr_t attr;
+  (void) pthread_attr_init (&attr);
+  (void) pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN);
+
+  /* Block all signals in the helper thread but SIGSETXID.  To do this
+     thoroughly we temporarily have to block all signals here.  The
+     helper can lose wakeups if SIGCANCEL is not blocked throughout,
+     but sigfillset omits it SIGSETXID.  So, we add SIGCANCEL back
+     explicitly here.  */
+  sigset_t ss;
+  sigset_t oss;
+  sigfillset (&ss);
+  __sigaddset (&ss, SIGCANCEL);
+  sigprocmask (SIG_SETMASK, &ss, &oss);
+
+  /* Create the helper thread for this timer.  */
+  pthread_t th;
+  int res = pthread_create (&th, &attr, timer_helper_thread, NULL);
+  if (res == 0)
+    /* We managed to start the helper thread.  */
+    __helper_tid = ((struct pthread *) th)->tid;
+
+  /* Restore the signal mask.  */
+  sigprocmask (SIG_SETMASK, &oss, NULL);
+
+  /* No need for the attribute anymore.  */
+  (void) pthread_attr_destroy (&attr);
+
+  /* We have to make sure that after fork()ing a new helper thread can
+     be created.  */
+  pthread_atfork (NULL, NULL, reset_helper_control);
+}
+#endif
+
+#ifndef __ASSUME_POSIX_TIMERS
+# include <nptl/sysdeps/pthread/timer_routines.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/nptl/timer_settime.c
@@ -0,0 +1,90 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+#ifdef SYS_ktimer_settime
+# ifndef __ASSUME_POSIX_TIMERS
+static int compat_timer_settime (timer_t timerid, int flags,
+				 const struct itimerspec *value,
+				 struct itimerspec *ovalue);
+#  define timer_settime static compat_timer_settime
+#  include <nptl/sysdeps/pthread/timer_settime.c>
+#  undef timer_settime
+# endif
+
+# ifdef timer_settime_alias
+#  define timer_settime timer_settime_alias
+# endif
+
+
+int
+timer_settime (timerid, flags, value, ovalue)
+     timer_t timerid;
+     int flags;
+     const struct itimerspec *value;
+     struct itimerspec *ovalue;
+{
+# undef timer_settime
+# ifndef __ASSUME_POSIX_TIMERS
+  if (__no_posix_timers >= 0)
+# endif
+    {
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_settime, 4, kt->ktimerid, flags,
+				value, ovalue);
+
+# ifndef __ASSUME_POSIX_TIMERS
+      if (res != -1 || errno != ENOSYS)
+	{
+	  /* We know the syscall support is available.  */
+	  __no_posix_timers = 1;
+# endif
+	  return res;
+# ifndef __ASSUME_POSIX_TIMERS
+	}
+# endif
+
+# ifndef __ASSUME_POSIX_TIMERS
+      __no_posix_timers = -1;
+# endif
+    }
+
+# ifndef __ASSUME_POSIX_TIMERS
+  return compat_timer_settime (timerid, flags, value, ovalue);
+# endif
+}
+#else
+# ifdef timer_settime_alias
+#  define timer_settime timer_settime_alias
+# endif
+/* The new system calls are not available.  Use the userlevel
+   implementation.  */
+# include <nptl/sysdeps/pthread/timer_settime.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ntp_gettime.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/timex.h>
+#include <sys/sysctl.h>
+#include <stddef.h>
+
+#ifndef ntptimeval
+#define ntptimeval ntptimeval4
+#endif
+
+int
+ntp_gettime (struct ntptimeval *ntv)
+{
+  /* Fetch sysctl value of "kern.ntp_pll.gettime".  */
+  /* The 'struct ntptimeval' has grown in size.  */
+  union
+    {
+      struct ntptimeval3 tv3;
+      struct ntptimeval4 tv4;
+    } tv;
+  size_t size = sizeof (tv);
+  int request[2] = { CTL_KERN, KERN_NTP_PLL };
+
+  if (__sysctl (request, 2, &tv, &size, NULL, 0) >= 0)
+    {
+      if (size == sizeof (struct ntptimeval3))
+	{
+	  if (ntv)
+	    {
+	      ntv->time = tv.tv3.time;
+	      ntv->maxerror = tv.tv3.maxerror;
+	      ntv->esterror = tv.tv3.esterror;
+	      ntv->tai = 0;
+	      ntv->time_state = tv.tv3.time_state;
+	    }
+	  return tv.tv3.time_state;
+	}
+      if (size == sizeof (struct ntptimeval4))
+	{
+	  if (ntv)
+	    *ntv = tv.tv4;
+	  return tv.tv4.time_state;
+	}
+    }
+  return TIME_ERROR;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c
@@ -0,0 +1,63 @@
+/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fcntl.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sysdep-cancel.h>
+
+int
+__libc_open (const char *file, int oflag, ...)
+{
+  int mode = 0;
+  int fd;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+
+  if (SINGLE_THREAD_P)
+  {
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+  }
+  else
+  {
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+    LIBC_CANCEL_RESET (oldtype);
+  }
+  return fd;
+}
+libc_hidden_def (__libc_open)
+
+weak_alias (__libc_open, __open)
+libc_hidden_weak (__open)
+
+weak_alias (__libc_open, open)
+
+strong_alias (__libc_open, __libc_open64)
+weak_alias (__libc_open64, __open64)
+weak_alias (__libc_open64, open64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c
@@ -0,0 +1,2 @@
+/* 'open64' is the same as 'open', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/open_2.c
@@ -0,0 +1,2 @@
+#include <sysdeps/unix/sysv/linux/open_2.c>
+strong_alias (__open_2, __open64_2)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat.c
@@ -0,0 +1,189 @@
+/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+extern int __syscall_openat (int fd, const char *path, int flag, mode_t mode);
+libc_hidden_proto (__syscall_openat)
+
+# ifndef __ASSUME_ATFCTS
+int __have_atfcts = 0;
+#endif
+
+/* Open FILE with access OFLAG.  Interpret relative paths relative to
+   the directory associated with FD.  If OFLAG includes O_CREAT, a
+   third argument is the file protection.  */
+int
+__openat_nocancel (fd, file, oflag, mode)
+     int fd;
+     const char *file;
+     int oflag;
+     mode_t mode;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (openat, 4, fd, file, oflag, mode);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+    }
+  return INLINE_SYSCALL (open, 3, file, oflag, mode);
+#endif
+}
+
+strong_alias (__openat_nocancel, __openat64_nocancel)
+
+/* Open FILE with access OFLAG.  Interpret relative paths relative to
+   the directory associated with FD.  If OFLAG includes O_CREAT, a
+   third argument is the file protection.  */
+int
+__openat (fd, file, oflag)
+     int fd;
+     const char *file;
+     int oflag;
+{
+  int mode = 0;
+  int result;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+  
+  if (SINGLE_THREAD_P)
+    return __openat_nocancel(fd, file, oflag, mode);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = __openat_nocancel(fd, file, oflag, mode);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+
+libc_hidden_def (__openat)
+weak_alias (__openat, openat)
+
+/* 'openat64' is the same as 'openat', because __off64_t == __off_t.  */
+strong_alias (__openat, __openat64)
+libc_hidden_def (__openat64)
+weak_alias (__openat64, openat64)
+
+int
+__openat_2 (fd, file, oflag)
+     int fd;
+     const char *file;
+     int oflag;
+{
+  if (oflag & O_CREAT)
+    __fortify_fail ("invalid openat call: O_CREAT without mode");
+
+  return __openat (fd, file, oflag);
+}
+
+strong_alias (__openat_2, __openat64_2)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat64.c
@@ -0,0 +1,2 @@
+/* 'openat64' is the same as 'openat', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define	_PATHS_H_
+
+/* Default search path. */
+#define	_PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_CSHELL	"/bin/csh"
+#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_DRUM	"/dev/drum"
+#define	_PATH_KLOG	"/dev/klog"
+#define	_PATH_KMEM	"/dev/kmem"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MEM	"/dev/mem"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/etc/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_PRESERVE	"/var/lib"
+#define	_PATH_RWHODIR	"/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define	_PATH_UNIX	"/kernel"
+#define _PATH_UTMP	"/var/run/utmp"
+#define	_PATH_VI	"/usr/bin/vi"
+#define _PATH_WTMP	"/var/log/wtmp"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/lib/misc/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#endif /* !_PATHS_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/powerpc/bits/elf.h
@@ -0,0 +1,39 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_ELF_H
+#define _BITS_ELF_H
+
+__BEGIN_DECLS
+
+#define	AT_DCACHEBSIZE	10	/* Data cache block size for the processor. */
+#define	AT_ICACHEBSIZE	11	/* Instruction cache block size for the uP. */
+#define	AT_UCACHEBSIZE	12	/* Cache block size, or `0' if cache not unified. */
+#define	AT_EXECPATH	13	/* Path to the executable. */
+#define	AT_CANARY	14	/* Canary for SSP */
+#define	AT_CANARYLEN	15	/* Length of the canary. */
+#define	AT_OSRELDATE	16	/* OSRELDATE. */
+#define	AT_NCPUS	17	/* Number of CPUs. */
+#define	AT_PAGESIZES	18	/* Pagesizes. */
+#define	AT_PAGESIZESLEN	19	/* Number of pagesizes. */
+#define	AT_STACKPROT	21	/* Initial stack protection. */
+
+__END_DECLS
+
+#endif	/* elf.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pread.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+extern ssize_t __syscall_pread (int __fd, void *__buf, size_t __nbytes,
+				__off_t __offset) __THROW;
+libc_hidden_proto(__syscall_pread)
+extern ssize_t __syscall_freebsd6_pread (int __fd, void *__buf, size_t __nbytes,
+				int __unused1, __off_t __offset) __THROW;
+libc_hidden_proto(__syscall_freebsd6_pread)
+
+ssize_t
+__libc_pread (int fd, void *buf, size_t nbytes, __off_t offset)
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+
+      /* First try the new syscall. */
+      result = INLINE_SYSCALL (pread, 4, fd, buf, nbytes, offset);
+#ifndef __ASSUME_PREAD_PWRITE_SYSCALLS
+      if (result == -1 && errno == ENOSYS)
+	/* New syscall not available, us the old one. */
+	result = INLINE_SYSCALL (freebsd6_pread, 5, fd, buf, nbytes, 0, offset);
+#endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  /* First try the new syscall. */
+  result = INLINE_SYSCALL (pread, 4, fd, buf, nbytes, offset);
+#ifndef __ASSUME_PREAD_PWRITE_SYSCALLS
+  if (result == -1 && errno == ENOSYS)
+    /* New syscall not available, us the old one. */
+    result = INLINE_SYSCALL (freebsd6_pread, 5, fd, buf, nbytes, 0, offset);
+#endif
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__pread, pread)
+
+/* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
+strong_alias (__libc_pread, __libc_pread64)
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c
@@ -0,0 +1 @@
+/* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/preadv64.c
@@ -0,0 +1 @@
+/* 'preadv64' is the same as 'preadv', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <libc-internal.h>
+#include <stddef.h>
+#include <sys/sysctl.h>
+
+struct clockinfo
+{
+  int hz;		/* Clock frequency.  */
+  int tick;		/* Microseconds per hz tick, = 1000000 / hz.  */
+  int tickadj;		/* Clock skew rate for adjtime().  */
+  int stathz;		/* Statistics clock frequency.  */
+  int profhz;		/* Profiling clock frequency.  */
+};
+
+int
+__profile_frequency (void)
+{
+  /* Fetch the "kern.clockrate" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_CLOCKRATE };
+  struct clockinfo result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  /* Yes, hz, not profhz.  On i386, the value is 100, not 1024.  */
+  return result.hz;
+}
+libc_hidden_def (__profile_frequency)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pselect.c
@@ -0,0 +1,72 @@
+/* Copyright (C) 2006, 2007, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/poll.h>
+#include <kernel-features.h>
+#include <sysdep-cancel.h>
+
+
+#ifndef __ASSUME_PSELECT
+static int __generic_pselect (int nfds, fd_set *readfds, fd_set *writefds,
+			      fd_set *exceptfds,
+			      const struct timespec *timeout,
+			      const sigset_t *sigmask);
+#endif
+
+extern int __syscall_pselect (int nfds, fd_set *readfds, fd_set *writefds,
+			      fd_set *exceptfds,
+			      const struct timespec *timeout,
+			      const sigset_t *sigmask) __THROW;
+
+int 
+__pselect (int nfds, fd_set *readfds, fd_set *writefds,
+			      fd_set *exceptfds,
+			      const struct timespec *timeout,
+			      const sigset_t *sigmask)
+{
+  int result;
+
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (pselect, 6, nfds, readfds, writefds, exceptfds, 
+			     timeout, sigmask);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (pselect, 6, nfds, readfds, writefds, exceptfds, 
+  			       timeout, sigmask);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+
+#ifndef __ASSUME_PSELECT
+  if (result == -1 && errno == ENOSYS)
+    return __generic_pselect (nfds, readfds, writefds, exceptfds,
+                                timeout, sigmask);
+#endif
+
+  return result;
+}
+weak_alias (__pselect, pselect)
+strong_alias (__pselect, __libc_pselect)
+
+#ifndef __ASSUME_PSELECT
+# define __pselect static __generic_pselect
+# include <misc/pselect.c>
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c
@@ -0,0 +1,111 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <paths.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <sys/sysctl.h>
+#include <unistd.h>
+
+
+/* Static buffer for `ptsname'.  */
+static char buffer[sizeof (_PATH_TTY) + 2];
+
+
+/* Return the pathname of the pseudo terminal slave associated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+char *
+ptsname (int fd)
+{
+  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;
+}
+
+/* The are declared in getpt.c.  */
+extern const char __libc_ptyname1[] attribute_hidden;
+extern const char __libc_ptyname2[] attribute_hidden;
+
+
+int
+__ptsname_internal (int fd, char *buf, size_t buflen, struct stat64 *stp)
+{
+  int saved_errno = errno;
+  char *p;
+
+  if (buf == NULL)
+    {
+      __set_errno (EINVAL);
+      return EINVAL;
+    }
+
+  /* Don't call isatty (fd) - it usually fails with errno = EAGAIN.  */
+
+  if (__fxstat64 (_STAT_VER, fd, stp) < 0)
+    return errno;
+
+  /* Check if FD really is a master pseudo terminal.  */
+  if (!(S_ISCHR (stp->st_mode)))
+    {
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
+  if (buflen < sizeof (_PATH_TTY) + 2)
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
+
+  /* Construct the slave's pathname.  */
+  /* instead of strlen(_PATH_DEV) we use (sizeof (_PATH_DEV) - 1)  */
+  p = __mempcpy (buf, _PATH_DEV, sizeof (_PATH_DEV) - 1);
+  buflen -= (sizeof (_PATH_DEV) - 1);
+  if(__sysctlbyname("kern.devname", p, &buflen, &stp->st_rdev, sizeof (stp->st_rdev)) < 0)
+    return errno;
+  p[0] = 't';
+
+  if (__xstat64 (_STAT_VER, buf, stp) < 0)
+    return errno;
+
+  /* Check if the pathname we're about to return might be
+     slave pseudo terminal of the given master pseudo terminal.  */
+  if (!(S_ISCHR (stp->st_mode)))
+    {
+      /* This really is a configuration problem.  */
+      __set_errno (ENOTTY);
+      return ENOTTY;
+    }
+
+  __set_errno (saved_errno);
+  return 0;
+}
+
+
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+int
+__ptsname_r (int fd, char *buf, size_t buflen)
+{
+  struct stat64 st;
+  return __ptsname_internal (fd, buf, buflen, &st);
+}
+weak_alias (__ptsname_r, ptsname_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+#include <errno.h>
+
+extern ssize_t __syscall_pwrite (int __fd, const void *__buf, size_t __nbytes,
+				 __off_t __offset) __THROW;
+libc_hidden_proto(__syscall_pwrite)
+extern ssize_t __syscall_freebsd6_pwrite (int __fd, const void *__buf, size_t __nbytes,
+				 int __unused1, __off_t __offset) __THROW;
+libc_hidden_proto(__syscall_freebsd6_pwrite)
+
+ssize_t
+__libc_pwrite (int fd, const void *buf, size_t nbytes, __off_t offset)
+{
+  ssize_t result;
+
+  if (SINGLE_THREAD_P)
+    {
+      /* First try the new syscall. */
+      result = INLINE_SYSCALL (pwrite, 4, fd, buf, nbytes, offset);
+#ifndef __ASSUME_PREAD_PWRITE_SYSCALLS
+      if (result == -1 && errno == ENOSYS)
+        /* New syscall not available, us the old one. */
+        result = INLINE_SYSCALL (freebsd6_pwrite, 5, fd, buf, nbytes, 0, offset);
+#endif
+      return result;
+    }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  /* First try the new syscall. */
+  result = INLINE_SYSCALL (pwrite, 4, fd, buf, nbytes, offset);
+#ifndef __ASSUME_PREAD_PWRITE_SYSCALLS
+  if (result == -1 && errno == ENOSYS)
+    /* New syscall not available, us the old one. */
+    result = INLINE_SYSCALL (freebsd6_pwrite, 5, fd, buf, nbytes, 0, offset);
+#endif
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__pwrite, pwrite)
+
+/* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
+strong_alias (__libc_pwrite, __libc_pwrite64)
+weak_alias (__libc_pwrite64, __pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c
@@ -0,0 +1 @@
+/* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwritev64.c
@@ -0,0 +1 @@
+/* 'pwritev64' is the same as 'pwritev', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c
@@ -0,0 +1,11 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64 __no_readdir64_decl
+#define __readdir64 __no___readdir64_decl
+#include <sysdeps/unix/readdir.c>
+#undef __readdir64
+#undef readdir64
+
+strong_alias (__readdir, __readdir64)
+weak_alias (__readdir64, readdir64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c
@@ -0,0 +1,2 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c
@@ -0,0 +1,2 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c
@@ -0,0 +1,11 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64_r __no_readdir64_r_decl
+#define __readdir64_r __no___readdir64_r_decl
+#include <sysdeps/unix/readdir_r.c>
+#undef __readdir64_r
+#undef readdir64_r
+
+strong_alias (__readdir_r, __readdir64_r)
+weak_alias (__readdir64_r, readdir64_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readlinkat.c
@@ -0,0 +1,130 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_readlinkat (int fd, const char *path, char *buf, 
+				 size_t bufsize);
+libc_hidden_proto (__syscall_readlinkat)
+
+/* Read the contents of the symbolic link PATH relative to FD into no
+   more than LEN bytes of BUF.  */
+ssize_t
+readlinkat (fd, path, buf, len)
+     int fd;
+     const char *path;
+     char *buf;
+     size_t len;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (readlinkat, 4, fd, path, buf, len);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (fd != AT_FDCWD && path[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t pathlen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      pathlen = strlen (path);
+      if (__builtin_expect (pathlen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + pathlen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, path);
+	      path = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  return __readlink (path, buf, len);
+#endif
+}
+
+libc_hidden_def (readlinkat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readonly-area.c
@@ -0,0 +1,96 @@
+/* Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include "libio/libioP.h"
+
+/* Return 1 if the whole area PTR .. PTR+SIZE is not writable.
+   Return -1 if it is writable.  */
+
+int
+__readonly_area (const char *ptr, size_t size)
+{
+  const void *ptr_end = ptr + size;
+
+  int mib[4];
+  size_t kve_len = 0;
+  char *kve_buf, *kve_bufp;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_VMMAP;
+  mib[3] = __getpid ();
+
+  if (__sysctl (mib, 4, NULL, &kve_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return 1;
+    }
+
+  kve_buf = alloca (kve_len);
+  if (__sysctl (mib, 4, kve_buf, &kve_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return 1;
+    }
+
+  kve_bufp = kve_buf;
+  while (kve_bufp < kve_buf + kve_len)
+    {
+      struct kinfo_vmentry *kve = (struct kinfo_vmentry *) (uintptr_t) kve_bufp;
+      kve_bufp += kve->kve_structsize;
+
+      uintptr_t from = kve->kve_start;
+      uintptr_t to = kve->kve_end;
+
+      if (from < (uintptr_t) ptr_end && to > (uintptr_t) ptr)
+	{
+	  /* Found an entry that at least partially covers the area.  */
+	  if (!(kve->kve_protection & KVME_PROT_READ)
+	      || (kve->kve_protection & KVME_PROT_WRITE))
+	    break;
+
+	  if (from <= (uintptr_t) ptr && to >= (uintptr_t) ptr_end)
+	    {
+	      size = 0;
+	      break;
+	    }
+	  else if (from <= (uintptr_t) ptr)
+	    size -= to - (uintptr_t) ptr;
+	  else if (to >= (uintptr_t) ptr_end)
+	    size -= (uintptr_t) ptr_end - from;
+	  else
+	    size -= to - from;
+
+	  if (!size)
+	    break;
+	}
+    }
+
+  /* If the whole area between ptr and ptr_end is covered by read-only
+     VMAs, return 1.  Otherwise return -1.  */
+  return size == 0 ? 1 : -1;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c
@@ -0,0 +1,57 @@
+/* readv for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_readv (int, __const struct iovec *__unbounded, int);
+libc_hidden_proto(__syscall_readv)
+
+static ssize_t __atomic_readv_replacement (int, __const struct iovec *,
+					   int) internal_function;
+
+ssize_t
+__libc_readv (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (readv, 3, fd, CHECK_N (vector, count), count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result = INLINE_SYSCALL (readv, 3, fd, CHECK_N (vector, count), count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_readv_replacement (fd, vector, count);
+}
+strong_alias (__libc_readv, __readv)
+weak_alias (__libc_readv, readv)
+
+#define __libc_readv static internal_function __atomic_readv_replacement
+#include <sysdeps/posix/readv.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* The real syscall's name.  See sysdeps/unix/inet/syscalls.list.  */
+#define __syscall_recvfrom __libc_recvfrom
+ssize_t __libc_recvfrom(int s, void *buf, size_t len, int flags,
+                        struct sockaddr *from, socklen_t *fromlen);
+libc_hidden_proto (__libc_recvfrom)
+
+/* Read N bytes into BUF from socket FD.
+   Return the number of bytes read or -1 for error.  */
+
+ssize_t
+__libc_recv (int fd, void *buf, size_t n, int flags)
+{
+  return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
+}
+
+weak_alias (__libc_recv, __recv)
+weak_alias (__libc_recv, recv)
+
+LIBC_CANCEL_HANDLED (); /* in __libc_recvfrom */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/remove.c
@@ -0,0 +1,40 @@
+/* ANSI C `remove' function to delete a file or directory.  POSIX.1 version.
+   Copyright (C) 1995,96,97,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+int
+remove (file)
+     const char *file;
+{
+  /* First try to unlink since this is more frequently the necessary action. */
+  if (__unlink (file) != 0
+      /* If it is indeed a directory...  */
+      /* Linux returns EISDIR, POSIX mandates EPERM */
+      && (((errno != EISDIR) && (errno != EPERM))
+	  /* ...try to remove it.  */
+	  || __rmdir (file) != 0))
+    /* Cannot remove the object for whatever reason.  */
+    return -1;
+
+  return 0;
+}
+libc_hidden_def (remove)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/renameat.c
@@ -0,0 +1,174 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <stdio.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+libc_hidden_proto (rename)
+
+extern int __syscall_renameat (int oldfd, const char *old, int newfd,
+			       const char *new);
+libc_hidden_proto (__syscall_renameat)
+
+/* Rename the file OLD relative to OLDFD to NEW relative to NEWFD.  */
+int renameat (oldfd, old, newfd, new)
+     int oldfd;
+     const char *old;
+     int newfd;
+     const char *new;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (renameat, 4, oldfd, old, newfd, new);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if ((oldfd != AT_FDCWD && old[0] != '/')
+      || (newfd != AT_FDCWD && new[0] != '/'))
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t old_filelen, new_filelen;
+
+      if ((oldfd < 0) || (newfd < 0))
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      old_filelen = strlen (old);
+      new_filelen = strlen (new);
+      if (__builtin_expect (old_filelen == 0, 0)
+	  || __builtin_expect (new_filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      if (oldfd != AT_FDCWD && old[0] != '/')
+	{
+	  kf_bufp = kf_buf;
+	  while (kf_bufp < kf_buf + kf_len)
+	    {
+	      struct kinfo_file *kf =
+		(struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	      if (kf->kf_fd == oldfd)
+		{
+		  char *buf;
+		  if (kf->kf_type != KF_TYPE_VNODE ||
+		      kf->kf_vnode_type != KF_VTYPE_VDIR)
+		    {
+		      __set_errno (ENOTDIR);
+		      return -1;
+		    }
+
+		  buf = alloca (strlen (kf->kf_path) + old_filelen + 2);
+		  strcpy(buf, kf->kf_path);
+		  strcat (buf, "/");
+		  strcat (buf, old);
+		  old = buf;
+		  break;
+		}
+	      kf_bufp += kf->kf_structsize;
+	    }
+
+	  if (kf_bufp >= kf_buf + kf_len)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+	}
+
+      if (newfd != AT_FDCWD && new[0] != '/')
+	{
+	  kf_bufp = kf_buf;
+	  while (kf_bufp < kf_buf + kf_len)
+	    {
+	      struct kinfo_file *kf =
+		(struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	      if (kf->kf_fd == newfd)
+		{
+		  char *buf;
+		  if (kf->kf_type != KF_TYPE_VNODE ||
+		      kf->kf_vnode_type != KF_VTYPE_VDIR)
+		    {
+		      __set_errno (ENOTDIR);
+		      return -1;
+		    }
+
+		  buf = alloca (strlen (kf->kf_path) + new_filelen + 2);
+		  strcpy(buf, kf->kf_path);
+		  strcat (buf, "/");
+		  strcat (buf, new);
+		  new = buf;
+		  break;
+		}
+	      kf_bufp += kf->kf_structsize;
+	    }
+
+	  if (kf_bufp >= kf_buf + kf_len)
+	    {
+	      __set_errno (EBADF);
+	      return -1;
+	    }
+	}
+    }
+
+#define __rename rename /* there is no __rename */
+  return __rename (old, new);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/rtld-lowlevel.h
@@ -0,0 +1,131 @@
+/* Definitions for lowlevel handling in ld.so, FreeBSD variant
+   Copyright (C) 2006-2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RTLD_LOWLEVEL_H
+#define  _RTLD_LOWLEVEL_H 1
+
+#include <atomic.h>
+#include <lowlevellock.h>
+
+/* Special multi-reader lock used in ld.so.  */
+#define __RTLD_MRLOCK_WRITER 1
+#define __RTLD_MRLOCK_RWAIT 2
+#define __RTLD_MRLOCK_WWAIT 4
+#define __RTLD_MRLOCK_RBITS \
+  ~(__RTLD_MRLOCK_WRITER | __RTLD_MRLOCK_RWAIT | __RTLD_MRLOCK_WWAIT)
+#define __RTLD_MRLOCK_INC 8
+#define __RTLD_MRLOCK_TRIES 5
+
+#define __rtld_mrlock_define(CLASS,NAME) \
+  CLASS __rtld_mrlock_t NAME;
+
+
+#define _RTLD_MRLOCK_INITIALIZER 0
+#define __rtld_mrlock_initialize(NAME) \
+  (void) ((NAME).lv = 0)
+
+
+#define __rtld_mrlock_lock(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = (lock).iv;						      \
+	    while (__builtin_expect ((oldval				      \
+				      & (__RTLD_MRLOCK_WRITER		      \
+					 | __RTLD_MRLOCK_WWAIT))	      \
+				     == 0, 1))				      \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RBITS)		      \
+			      + __RTLD_MRLOCK_INC);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	if ((oldval & __RTLD_MRLOCK_RWAIT) == 0)			      \
+	  {								      \
+	    atomic_or (&(lock.iv), __RTLD_MRLOCK_RWAIT);			      \
+	    oldval |= __RTLD_MRLOCK_RWAIT;				      \
+	  }								      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_unlock(lock) \
+  do {									      \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_INC);	      \
+    if (__builtin_expect ((oldval					      \
+			   & (__RTLD_MRLOCK_RBITS | __RTLD_MRLOCK_WWAIT))     \
+			  == (__RTLD_MRLOCK_INC | __RTLD_MRLOCK_WWAIT), 0))   \
+      /* We have to wake all threads since there might be some queued	      \
+	 readers already.  */						      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+/* There can only ever be one thread trying to get the exclusive lock.  */
+#define __rtld_mrlock_change(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = lock.iv;						      \
+	    while (__builtin_expect ((oldval & __RTLD_MRLOCK_RBITS) == 0, 1)) \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RWAIT)		      \
+			      + __RTLD_MRLOCK_WRITER);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	atomic_or (&(lock.iv), __RTLD_MRLOCK_WWAIT);			      \
+	oldval |= __RTLD_MRLOCK_WWAIT;					      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_done(lock) \
+  do {				 \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_WRITER);    \
+    if (__builtin_expect ((oldval & __RTLD_MRLOCK_RWAIT) != 0, 0))	      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sa_len.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+
+#include <netatalk/at.h>
+#include <netinet/in.h>
+#include <netipx/ipx.h>
+#include <sys/un.h>
+
+int
+__libc_sa_len (sa_family_t af)
+{
+  switch (af)
+    {
+    case AF_APPLETALK:
+      return sizeof (struct sockaddr_at);
+    case AF_INET:
+      return sizeof (struct sockaddr_in);
+    case AF_INET6:
+      return sizeof (struct sockaddr_in6);
+    case AF_IPX:
+      return sizeof (struct sockaddr_ipx);
+    case AF_LOCAL:
+      return __SOCKADDR_COMMON_SIZE + sizeof(((struct sockaddr_un *) 0)->sun_path);
+    }
+  return 0;
+}
+INTDEF(__libc_sa_len)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sbrk.c
@@ -0,0 +1 @@
+#include <misc/sbrk.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getaffinity.c
@@ -0,0 +1,64 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+/* From <sys/cpuset.h> */
+#define CPU_LEVEL_WHICH         3       /* Actual mask/id for which. */
+#define CPU_WHICH_PID           2       /* Specifies a process id. */
+
+extern int __syscall_cpuset_getaffinity(int level, int which, int64_t id,
+					size_t setsize, cpu_set_t *mask);
+libc_hidden_proto(__syscall_cpuset_getaffinity)
+
+int
+__libc_sched_getaffinity (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)
+{
+  int res;
+
+  if (pid == 0)
+    {
+      pid = __getpid();
+    }
+
+  if (cpusetsize > sizeof(cpu_set_t))
+    {
+      /* Clean the rest of the memory the kernel won't do.  */
+      memset ((char *) cpuset + sizeof(cpu_set_t), '\0', cpusetsize - sizeof(cpu_set_t));
+
+      cpusetsize = sizeof(cpu_set_t);
+    }
+
+  res = INLINE_SYSCALL (cpuset_getaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_PID, pid, cpusetsize, cpuset);
+
+  if (errno == ERANGE)
+    {
+      __set_errno(EINVAL);
+    }
+
+  return res;
+}
+
+strong_alias (__libc_sched_getaffinity, __sched_getaffinity)
+weak_alias (__sched_getaffinity, sched_getaffinity)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/rtprio.h>
+
+/* Retrieve scheduling parameters for a particular process.  */
+int
+__sched_getparam (pid_t pid, struct sched_param *param)
+{
+  /* kFreeBSD return bogus values for SYS_sched_param (see PR kern/76485);
+     fortunately the same information can be retrieved through the rtprio()
+     system call.  */
+  struct rtprio rtp;
+
+  if (__rtprio (RTP_LOOKUP, pid, &rtp) >= 0)
+    {
+      if (RTP_PRIO_IS_REALTIME (rtp.type))
+        param->sched_priority = RTP_PRIO_MAX - rtp.prio;
+      else
+        param->sched_priority = 0;
+    }
+
+  return 0;
+}
+
+weak_alias (__sched_getparam, sched_getparam)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_setaffinity.c
@@ -0,0 +1,57 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+/* From <sys/cpuset.h> */
+#define CPU_LEVEL_WHICH         3       /* Actual mask/id for which. */
+#define CPU_WHICH_PID           2       /* Specifies a process id. */
+
+extern int __syscall_cpuset_setaffinity(int level, int which, int64_t id,
+					size_t setsize, const cpu_set_t *mask);
+libc_hidden_proto(__syscall_cpuset_setaffinity)
+
+int
+__libc_sched_setaffinity (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
+{
+  int res;
+
+  if (pid == 0)
+    {
+      pid = __getpid();
+    }
+
+
+  res = INLINE_SYSCALL (cpuset_setaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_PID, pid, cpusetsize, cpuset);
+
+  if (errno == ERANGE || errno == EDEADLK)
+    {
+      __set_errno(EINVAL);
+    }
+
+  return res;
+}
+
+strong_alias (__libc_sched_setaffinity, __sched_setaffinity)
+weak_alias (__sched_setaffinity, sched_setaffinity)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/unix/seekdir.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c
@@ -0,0 +1,89 @@
+/* Copyright (C) 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*-
+ * Copyright (c) 2002 Doug Rabson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sysdep.h>
+#include <sys/sem.h>
+#include <stdarg.h> /* va_list */
+#include <stdlib.h> /* NULL */
+#include <unistd.h>
+
+/* union semun from FreeBSD <sys/sem.h> */
+/*
+ * semctl's arg parameter structure
+ */
+union semun
+{
+  int val;			/* value for SETVAL */
+  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  unsigned short *array;	/* array for GETALL & SETALL */
+};
+
+extern int __syscall_semctl (int semid, int semnum,
+                             int cmd, union semun *arg);
+libc_hidden_proto (__syscall_semctl)
+
+int
+semctl (int semid, int semnum, int cmd, ...)
+{
+  va_list ap;
+  union semun semun;
+  union semun *semun_ptr;
+
+  va_start (ap, cmd);
+  if (cmd == IPC_SET || cmd == IPC_STAT || cmd == GETALL
+      || cmd == SETVAL || cmd == SETALL)
+    {
+      semun = va_arg (ap, union semun);
+      semun_ptr = &semun;
+    }
+  else
+    {
+      semun_ptr = NULL;
+    }
+  va_end (ap);
+
+  return INLINE_SYSCALL (semctl, 4, semid, semnum, cmd, semun_ptr);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_sendto (int fd, __const __ptr_t buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF to socket FD.
+   Return the number of bytes sent or -1.  */
+
+ssize_t
+__libc_send (int fd, const void *buf, size_t n, int flags)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_send, __send)
+libc_hidden_weak (__send)
+
+weak_alias (__send, send)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sendto.c
@@ -0,0 +1,73 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+extern int __libc_sa_len_internal (sa_family_t __af);
+
+extern ssize_t __syscall_sendto (int fd, __const void * buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+ *    ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.  */
+
+
+ssize_t
+__libc_sendto (int fd, __const void * buf, size_t n, int flags,
+	       __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+  if (addr.__sockaddr__)
+  {
+#ifndef NOT_IN_libc
+  new_addrlen = INTUSE(__libc_sa_len) ((addr.__sockaddr__)->sa_family);
+#else
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+#endif
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if ((new_addrlen != 0) && (new_addrlen < addrlen))
+    addrlen = new_addrlen;
+  }
+
+  /* We pass 6 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr.__sockaddr__, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr.__sockaddr__, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_sendto, __sendto)
+weak_alias (__libc_sendto, sendto)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the name of the current domain to NAME, which is LEN bytes long
+   (excluding a possible trailing NUL byte).  This call is restricted to
+   the super-user.  */
+
+int
+setdomainname (const char *name, size_t len)
+{
+  /* Set the "kern.domainname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
+
+  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the current machine's Internet number to ID.
+   This call is restricted to the super-user.  */
+
+int
+sethostid (long int id)
+{
+  /* Set the "kern.hostid" sysctl value.  */
+  int value = id;
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+
+  if (__sysctl (request, 2, NULL, NULL, &value, sizeof (value)) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the name of the current host to NAME, which is LEN bytes long
+   (excluding a possible trailing NUL byte).  This call is restricted to
+   the super-user.  */
+
+int
+sethostname (const char *name, size_t len)
+{
+  /* Set the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+
+  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+
+extern int __syscall_setlogin (const char *__name);
+
+int
+setlogin (const char *name)
+{
+  /* FIXME: Not multithread-safe.  */
+  __getlogin_cache = NULL;
+  return INLINE_SYSCALL (setlogin, 1, name);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c
@@ -0,0 +1 @@
+/* 'setrlimit64' is the same as 'setrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/shm_open.c
@@ -0,0 +1,65 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern int __syscall_shm_open (const char *path, int flags, mode_t mode);
+libc_hidden_proto (__syscall_shm_open);
+
+/* Open shared memory object.   */
+int
+shm_open (const char *name, int oflag, mode_t mode)
+{
+  /* First try the new syscall. */
+  int fd = INLINE_SYSCALL (shm_open, 3, name, oflag, mode);
+
+#ifndef __ASSUME_POSIXSHM_SYSCALL
+  /* New syscall not available, use fallback code.  */
+  if (fd == -1 && errno == ENOSYS)
+    {
+      struct stat stab;
+
+      if ((oflag & O_ACCMODE) == O_WRONLY)
+	return (EINVAL);
+
+      fd = __open (name, oflag, mode);
+      if (fd != -1)
+	{
+	  if (__fstat (fd, &stab) != 0 || !S_ISREG (stab.st_mode))
+	    {
+	      __close (fd);
+	      __set_errno (EINVAL);
+	      return -1;
+	    }
+
+	  if (__fcntl (fd, F_SETFL, (int) FPOSIXSHM) != 0)
+	    {
+	      __close (fd);
+	      return -1;
+	    }
+	}
+    }
+#endif
+
+  return fd;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/shm_unlink.c
@@ -0,0 +1,48 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern int __syscall_shm_unlink (const char *name);
+libc_hidden_proto (__syscall_shm_unlink)
+
+libc_hidden_proto (__unlink)
+
+/* Unlink a shared memory object.  */
+int
+shm_unlink (const char *name)
+{
+  /* First try the new syscall. */
+  int result = INLINE_SYSCALL (shm_unlink, 1, name);
+
+#ifndef __ASSUME_POSIXSHM_SYSCALL
+  /* New syscall not available, simply unlink the file. */
+  if (result == -1 && errno == ENOSYS)
+# ifdef NOT_IN_libc
+    return unlink (name);
+# else
+    return __unlink (name);
+# endif
+#endif
+
+  return result;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 1991,1995,1996,1997,2002,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+#include <stddef.h>
+#include <signal.h>
+
+extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
+libc_hidden_proto (__syscall_sigaction)
+
+int
+__libc_sigaction (sig, act, oact)
+     int sig;
+     const struct sigaction *act;
+     struct sigaction *oact;
+{
+  if (sig <= 0 || sig >= NSIG)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (sigaction, 3, sig, act, oact);
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c
@@ -0,0 +1,3 @@
+/* The sigreturn syscall cannot be explicitly called on FreeBSD, only
+   implicitly by returning from a signal handler.  */
+#include <signal/sigreturn.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h
@@ -0,0 +1,36 @@
+/* Convert between lowlevel sigmask and libc representation of sigset_t.
+   FreeBSD version.
+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+static inline int __attribute__ ((unused))
+sigset_set_old_mask (sigset_t *set, int mask)
+{
+  set->__sigbits[0] = (unsigned int) mask;
+  set->__sigbits[1] = 0;
+  set->__sigbits[2] = 0;
+  set->__sigbits[3] = 0;
+
+  return 0;
+}
+
+static inline int __attribute__ ((unused))
+sigset_get_old_mask (const sigset_t *set)
+{
+  return (unsigned int) set->__sigbits[0];
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c
@@ -0,0 +1,3 @@
+/* We can reuse the Linux implementation with some tricks.  */
+#define __NR_sigaltstack 1
+#include <sysdeps/unix/sysv/linux/sigstack.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c
@@ -0,0 +1,44 @@
+/* Implementation of the POSIX sleep function using nanosleep.
+   Copyright (C) 1996-1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+
+/* The default implementation of sleep() in sysdeps/posix/sleep.c, based on
+   SIGALRM, does not mix well with threads.  Therefore we use the nanosleep()
+   system call.  */
+unsigned int
+__sleep (unsigned int seconds)
+{
+  struct timespec ts = { tv_sec: seconds, tv_nsec: 0 };
+  int ret;
+
+  /* This is not necessary but some buggy programs depend on this.  */
+  if (seconds == 0)
+    return 0;
+
+  ret = __nanosleep (&ts, &ts);
+
+  if (ret == 0)
+    return 0;
+
+  /* Round remaining time.  */
+  return (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
+}
+
+weak_alias (__sleep, sleep)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/socket/sys/un.h
@@ -0,0 +1,2 @@
+/* kludge to satisfy $SRC/include/sys/un.h */
+#include <kfreebsd/sys/un.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c
@@ -0,0 +1,84 @@
+/* Convert between different 'struct stat' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <sys/mount.h>
+#include <bits/stat16.h>
+
+extern int __syscall_fhstat (const fhandle_t *fhp, struct stat16 *buf);
+extern int __syscall_fstat (int, struct stat16 *__unbounded);
+extern int __syscall_lstat (const char *__unbounded, struct stat16 *__unbounded);
+extern int __syscall_stat (const char *__unbounded, struct stat16 *__unbounded);
+libc_hidden_proto (__syscall_fhstat)
+libc_hidden_proto (__syscall_fstat)
+libc_hidden_proto (__syscall_lstat)
+libc_hidden_proto (__syscall_stat)
+
+/* Convert a 'struct stat16' to 'struct stat'.  */
+static inline void
+stat16_to_stat (const struct stat16 *p16, struct stat *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->__pad_mode = 0;
+  q->st_nlink = p16->st_nlink;
+  q->__pad_nlink = 0;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
+
+/* Convert a 'struct stat16' to 'struct stat64'.  */
+static inline void
+stat16_to_stat64 (const struct stat16 *p16, struct stat64 *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->__pad_mode = 0;
+  q->st_nlink = p16->st_nlink;
+  q->__pad_nlink = 0;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (__statfs)
+weak_alias (__statfs, statfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c
@@ -0,0 +1,37 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statfs64 (const char *file, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c
@@ -0,0 +1,203 @@
+/* Convert between different 'struct statfs' and 'struct statvfs' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <stdint.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/syslimits.h>
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+/*
+ * filesystem statistics
+ */
+
+#define MFSNAMELEN	16		/* length of type name including null */
+#define MNAMELEN	88		/* size of on/from name bufs */
+
+struct statfs_fbsd5 {
+	uint32_t f_version;		/* structure version number */
+	uint32_t f_type;		/* type of filesystem */
+	uint64_t f_flags;		/* copy of mount exported flags */
+	uint64_t f_bsize;		/* filesystem fragment size */
+	uint64_t f_iosize;		/* optimal transfer block size */
+	uint64_t f_blocks;		/* total data blocks in filesystem */
+	uint64_t f_bfree;		/* free blocks in filesystem */
+	int64_t	 f_bavail;		/* free blocks avail to non-superuser */
+	uint64_t f_files;		/* total file nodes in filesystem */
+	int64_t	 f_ffree;		/* free nodes avail to non-superuser */
+	uint64_t f_syncwrites;		/* count of sync writes since mount */
+	uint64_t f_asyncwrites;		/* count of async writes since mount */
+	uint64_t f_syncreads;		/* count of sync reads since mount */
+	uint64_t f_asyncreads;		/* count of async reads since mount */
+	uint64_t f_spare[10];		/* unused spare */
+	uint32_t f_namemax;		/* maximum filename length */
+	__uid_t	 f_owner;		/* user that mounted the filesystem */
+	__fsid_t f_fsid;		/* filesystem id */
+	char	 f_charspare[80];	   /* spare string space */
+	char	 f_fstypename[MFSNAMELEN]; /* filesystem type name */
+	char	 f_mntfromname[MNAMELEN];  /* mounted filesystem */
+	char	 f_mntonname[MNAMELEN];	   /* directory on which mounted */
+};
+
+extern int __syscall_getfsstat(struct statfs_fbsd5 *buf, long bufsize, int flags);
+extern int __syscall_statfs(const char *path, struct statfs_fbsd5 *buf);
+extern int __syscall_fstatfs(int fd, struct statfs_fbsd5 *buf);
+extern int __syscall_fhstatfs(const struct fhandle *u_fhp, struct statfs_fbsd5 *buf);
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs structure.
+ */
+
+static inline void
+statfs5_to_statfs(const struct statfs_fbsd5 *pk, struct statfs *p32)
+{
+  memset(p32, 0, sizeof(*p32));
+
+  p32->f_version	= pk->f_version;
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+
+  p32->f_fsid		= pk->f_fsid;
+  p32->f_owner		= pk->f_owner;
+  p32->f_type		= pk->f_type;
+  p32->f_flags		= pk->f_flags;
+
+  p32->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p32->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p32->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p32->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p32->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p32->f_fstypename, pk->f_fstypename, sizeof (p32->f_fstypename));
+  memcpy(p32->f_mntonname,  pk->f_mntonname,  sizeof (p32->f_mntonname));
+  memcpy(p32->f_mntfromname,pk->f_mntfromname,sizeof (p32->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs64 structure.
+ */
+
+static inline void
+statfs5_to_statfs64(const struct statfs_fbsd5 *pk, struct statfs64 *p64)
+{
+  memset(p64, 0, sizeof(*p64));
+
+  p64->f_version	= pk->f_version;
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+
+  p64->f_fsid		= pk->f_fsid;
+  p64->f_owner		= pk->f_owner;
+  p64->f_type		= pk->f_type;
+  p64->f_flags		= pk->f_flags;
+
+  p64->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p64->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p64->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p64->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p64->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p64->f_fstypename, pk->f_fstypename, sizeof (p64->f_fstypename));
+  memcpy(p64->f_mntonname,  pk->f_mntonname,  sizeof (p64->f_mntonname));
+  memcpy(p64->f_mntfromname,pk->f_mntfromname,sizeof (p64->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs structure.
+ */
+
+static inline void
+statfs5_to_statvfs (const struct statfs_fbsd5 *pk, struct statvfs *p32)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+  p32->f_favail		= MIN(pk->f_ffree,  ULONG_MAX); /* Hmm.	 May be filesystem dependent.  */
+
+  memcpy(&(p32->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p32->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0)
+    | (pk->f_flags & MNT_NOATIME ? ST_NOATIME : 0);
+  p32->f_namemax	= pk->f_namemax;
+
+  memset (p32->f_spare, '\0', sizeof (p32->f_spare));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs64 structure.
+ */
+
+static inline void
+statfs5_to_statvfs64 (const struct statfs_fbsd5 *pk, struct statvfs64 *p64)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+  p64->f_favail		= pk->f_ffree; /* Hmm.	May be filesystem dependent.  */
+
+  memcpy(&(p64->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p64->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0)
+    | (pk->f_flags & MNT_NOATIME ? ST_NOATIME : 0);
+  p64->f_namemax	= pk->f_namemax;
+
+  memset (p64->f_spare, '\0', sizeof (p64->f_spare));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statvfs (const char *file, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_weak (statvfs)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statvfs64 (const char *file, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__statvfs64, statvfs64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/stty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/stty.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/symlinkat.c
@@ -0,0 +1,126 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_symlinkat (const char *path1, int fd,
+				const char *path2);
+libc_hidden_proto (__syscall_symlinkat)
+
+/* Make a symbolic link to FROM named TO relative to TOFD.  */
+int
+symlinkat (from, tofd, to)
+     const char *from;
+     int tofd;
+     const char *to;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (symlinkat, 3, from, tofd, to);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (tofd != AT_FDCWD && to[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t tolen;
+
+      if (tofd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      tolen = strlen (to);
+      if (__builtin_expect (tolen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + tolen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == tofd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, to);
+	      to = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  return __symlink (from, to);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h
@@ -0,0 +1,25 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_KD_H
+#define _SYS_KD_H	1
+
+#include <sys/consio.h>
+#include <sys/kbio.h>
+
+#endif	/* sys/kd.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h
@@ -0,0 +1,521 @@
+/* Header file for handling mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H	1
+
+#include <features.h>
+
+/* Retrieving the list of mounted filesystems.  */
+
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/ucred.h>
+#include <sys/queue.h>
+
+/* For getvfsbyname.  */
+#include <stddef.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * File identifier.
+ * These are unique per filesystem on a single machine.
+ */
+#define	MAXFIDSZ	16
+
+struct fid {
+	__u_short	fid_len;		/* length of data in bytes */
+	__u_short	fid_reserved;		/* force longword alignment */
+	char		fid_data[MAXFIDSZ];	/* data (variable length) */
+};
+
+/*
+ * filesystem statistics
+ */
+#define	MFSNAMELEN	16		/* length of type name including null */
+#define	MNAMELEN	88		/* size of on/from name bufs */
+#define	STATFS_VERSION	0x20030518	/* current version number */
+
+
+/*
+ * User specifiable flags.
+ */
+#define	MNT_RDONLY	0x0000000000000001ULL /* read only filesystem */
+#define	MNT_SYNCHRONOUS	0x0000000000000002ULL /* fs written synchronously */
+#define	MNT_NOEXEC	0x0000000000000004ULL /* can't exec from filesystem */
+#define	MNT_NOSUID	0x0000000000000008ULL /* don't honor setuid fs bits */
+#define	MNT_NFS4ACLS	0x0000000000000010ULL /* enable NFS version 4 ACLs */
+#define	MNT_UNION	0x0000000000000020ULL /* union with underlying fs */
+#define	MNT_ASYNC	0x0000000000000040ULL /* fs written asynchronously */
+#define	MNT_SUIDDIR	0x0000000000100000ULL /* special SUID dir handling */
+#define	MNT_SOFTDEP	0x0000000000200000ULL /* using soft updates */
+#define	MNT_NOSYMFOLLOW	0x0000000000400000ULL /* do not follow symlinks */
+#define	MNT_GJOURNAL	0x0000000002000000ULL /* GEOM journal support enabled */
+#define	MNT_MULTILABEL	0x0000000004000000ULL /* MAC support for objects */
+#define	MNT_ACLS	0x0000000008000000ULL /* ACL support enabled */
+#define	MNT_NOATIME	0x0000000010000000ULL /* dont update file access time */
+#define	MNT_NOCLUSTERR	0x0000000040000000ULL /* disable cluster read */
+#define	MNT_NOCLUSTERW	0x0000000080000000ULL /* disable cluster write */
+#define	MNT_SUJ		0x0000000100000000ULL /* using journaled soft updates */
+
+/*
+ * NFS export related mount flags.
+ */
+#define	MNT_EXRDONLY	0x0000000000000080ULL	/* exported read only */
+#define	MNT_EXPORTED	0x0000000000000100ULL	/* filesystem is exported */
+#define	MNT_DEFEXPORTED	0x0000000000000200ULL	/* exported to the world */
+#define	MNT_EXPORTANON	0x0000000000000400ULL	/* anon uid mapping for all */
+#define	MNT_EXKERB	0x0000000000000800ULL	/* exported with Kerberos */
+#define	MNT_EXPUBLIC	0x0000000020000000ULL	/* public export (WebNFS) */
+
+/*
+ * Flags set by internal operations,
+ * but visible to the user.
+ * XXX some of these are not quite right.. (I've never seen the root flag set)
+ */
+#define	MNT_LOCAL	0x0000000000001000ULL /* filesystem is stored locally */
+#define	MNT_QUOTA	0x0000000000002000ULL /* quotas are enabled on fs */
+#define	MNT_ROOTFS	0x0000000000004000ULL /* identifies the root fs */
+#define	MNT_USER	0x0000000000008000ULL /* mounted by a user */
+#define	MNT_IGNORE	0x0000000000800000ULL /* do not show entry in df */
+
+/*
+ * Mask of flags that are visible to statfs().
+ * XXX I think that this could now become (~(MNT_CMDFLAGS))
+ * but the 'mount' program may need changing to handle this.
+ */
+#define	MNT_VISFLAGMASK	(MNT_RDONLY	| MNT_SYNCHRONOUS | MNT_NOEXEC	| \
+			MNT_NOSUID	| MNT_UNION	| MNT_SUJ	| \
+			MNT_ASYNC	| MNT_EXRDONLY	| MNT_EXPORTED	| \
+			MNT_DEFEXPORTED	| MNT_EXPORTANON| MNT_EXKERB	| \
+			MNT_LOCAL	| MNT_USER	| MNT_QUOTA	| \
+			MNT_ROOTFS	| MNT_NOATIME	| MNT_NOCLUSTERR| \
+			MNT_NOCLUSTERW	| MNT_SUIDDIR	| MNT_SOFTDEP	| \
+			MNT_IGNORE	| MNT_EXPUBLIC	| MNT_NOSYMFOLLOW | \
+			MNT_GJOURNAL	| MNT_MULTILABEL | MNT_ACLS	| \
+			MNT_NFS4ACLS)
+
+/* Mask of flags that can be updated. */
+#define	MNT_UPDATEMASK (MNT_NOSUID	| MNT_NOEXEC	| \
+			MNT_SYNCHRONOUS	| MNT_UNION	| MNT_ASYNC	| \
+			MNT_NOATIME | \
+			MNT_NOSYMFOLLOW	| MNT_IGNORE	| \
+			MNT_NOCLUSTERR	| MNT_NOCLUSTERW | MNT_SUIDDIR	| \
+			MNT_ACLS	| MNT_USER | MNT_NFS4ACLS)
+
+/*
+ * External filesystem command modifier flags.
+ * Unmount can use the MNT_FORCE flag.
+ * XXX These are not STATES and really should be somewhere else.
+ */
+#define	MNT_UPDATE	0x00010000	/* not a real mount, just an update */
+#define	MNT_DELEXPORT	0x00020000	/* delete export host lists */
+#define	MNT_RELOAD	0x00040000	/* reload filesystem data */
+#define	MNT_FORCE	0x00080000	/* force unmount or readonly change */
+#define	MNT_SNAPSHOT	0x01000000	/* snapshot the filesystem */
+#define	MNT_BYFSID	0x08000000	/* specify filesystem by ID. */
+#define MNT_CMDFLAGS   (MNT_UPDATE	| MNT_DELEXPORT	| MNT_RELOAD	| \
+			MNT_FORCE	| MNT_SNAPSHOT	| MNT_BYFSID)
+/*
+ * Internal filesystem control flags stored in mnt_kern_flag.
+ *
+ * MNTK_UNMOUNT locks the mount entry so that name lookup cannot proceed
+ * past the mount point.  This keeps the subtree stable during mounts
+ * and unmounts.
+ *
+ * MNTK_UNMOUNTF permits filesystems to detect a forced unmount while
+ * dounmount() is still waiting to lock the mountpoint. This allows
+ * the filesystem to cancel operations that might otherwise deadlock
+ * with the unmount attempt (used by NFS).
+ */
+#define MNTK_UNMOUNTF	0x00000001	/* forced unmount in progress */
+#define MNTK_ASYNC      0x00000002      /* filtered async flag */
+#define MNTK_SOFTDEP    0x00000004      /* async disabled by softdep */
+#define MNTK_NOINSMNTQ  0x00000008      /* insmntque is not allowed */
+#define MNTK_UNMOUNT	0x01000000	/* unmount in progress */
+#define	MNTK_MWAIT	0x02000000	/* waiting for unmount to finish */
+#define MNTK_WANTRDWR	0x04000000	/* upgrade to read/write requested */
+#define MNTK_SUSPEND2   0x04000000      /* block secondary writes */
+#define	MNTK_SUSPEND	0x08000000	/* request write suspension */
+#define	MNTK_SUSPENDED	0x10000000	/* write operations are suspended */
+#define MNTK_MPSAFE     0x20000000      /* Filesystem is MPSAFE. */
+#define MNTK_NOKNOTE    0x80000000      /* Don't send KNOTEs from VOP hooks */
+#define MNTK_LOOKUP_SHARED      0x40000000 /* FS supports shared lock lookups */
+
+/*
+ * Sysctl CTL_VFS definitions.
+ *
+ * Second level identifier specifies which filesystem. Second level
+ * identifier VFS_VFSCONF returns information about all filesystems.
+ * Second level identifier VFS_GENERIC is non-terminal.
+ */
+#define	VFS_VFSCONF		0	/* get configured filesystems */
+#define	VFS_GENERIC		0	/* generic filesystem information */
+/*
+ * Third level identifiers for VFS_GENERIC are given below; third
+ * level identifiers for specific filesystems are given in their
+ * mount specific header files.
+ */
+#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
+#define VFS_CONF	2	/* struct: vfsconf for filesystem given
+				   as next argument */
+
+/*
+ * Flags for various system call interfaces.
+ *
+ * waitfor flags to vfs_sync() and getfsstat()
+ */
+#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
+#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
+#define MNT_LAZY	3	/* push data not written by filesystem syncer */
+#define	MNT_SUSPEND	4	/* Suspend file system after sync */
+
+/*
+ * Generic file handle
+ */
+struct fhandle {
+	__fsid_t	fh_fsid;	/* Filesystem id of mount point */
+	struct		fid fh_fid;	/* Filesys specific id */
+};
+typedef struct fhandle	fhandle_t;
+
+/*
+ * Old export arguments without security flavor list
+ */
+struct oexport_args {
+	int	ex_flags;		/* export related flags */
+	uid_t	ex_root;		/* mapping for root uid */
+	struct	xucred ex_anon;		/* mapping for anonymous user */
+	struct	sockaddr *ex_addr;	/* net address to which exported */
+	__u_char ex_addrlen;		/* and the net address length */
+	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
+	__u_char ex_masklen;		/* and the smask length */
+	char	*ex_indexfile;		/* index file for WebNFS URLs */
+};
+
+/*
+ * Export arguments for local filesystem mount calls.
+ */
+#define	MAXSECFLAVORS	5
+struct export_args {
+	int		ex_flags;		/* export related flags */
+	uid_t		ex_root;		/* mapping for root uid */
+	struct		xucred ex_anon;		/* mapping for anonymous user */
+	struct		sockaddr *ex_addr;	/* net address to which exported */
+	__u_char	ex_addrlen;		/* and the net address length */
+	struct		sockaddr *ex_mask;	/* mask of valid bits in saddr */
+	__u_char	ex_masklen;		/* and the smask length */
+	char		*ex_indexfile;		/* index file for WebNFS URLs */
+	int		ex_numsecflavors;	/* security flavor count */
+	int		ex_secflavors[MAXSECFLAVORS]; /* list of security flavors */
+};
+
+/*
+ * Structure holding information for a publicly exported filesystem
+ * (WebNFS). Currently the specs allow just for one such filesystem.
+ */
+struct nfs_public {
+	int		np_valid;	/* Do we hold valid information */
+	fhandle_t	np_handle;	/* Filehandle for pub fs (internal) */
+	struct mount	*np_mount;	/* Mountpoint of exported fs */
+	char		*np_index;	/* Index file */
+};
+
+/*
+ * Filesystem configuration information. One of these exists for each
+ * type of filesystem supported by the kernel. These are searched at
+ * mount time to identify the requested filesystem.
+ *
+ * XXX: Never change the first two arguments!
+ */
+struct vfsconf {
+	__u_int	vfc_version;		/* ABI version number */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsoptdecl *vfc_opts;	/* mount options */
+	TAILQ_ENTRY(vfsconf) vfc_list;	/* list of vfscons */
+};
+
+/* Userland version of the struct vfsconf. */
+struct xvfsconf {
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsconf *vfc_next;	/* next in list */
+};
+
+#ifndef BURN_BRIDGES
+struct ovfsconf {
+	void	*vfc_vfsops;
+	char	vfc_name[32];
+	int	vfc_index;
+	int	vfc_refcount;
+	int	vfc_flags;
+};
+#endif
+
+/*
+ * NB: these flags refer to IMPLEMENTATION properties, not properties of
+ * any actual mounts; i.e., it does not make sense to change the flags.
+ */
+#define	VFCF_STATIC	0x00010000	/* statically compiled into kernel */
+#define	VFCF_NETWORK	0x00020000	/* may get data over the network */
+#define	VFCF_READONLY	0x00040000	/* writes are not implemented */
+#define VFCF_SYNTHETIC	0x00080000	/* data does not represent real files */
+#define	VFCF_LOOPBACK	0x00100000	/* aliases some other mounted FS */
+#define	VFCF_UNICODE	0x00200000	/* stores file names as Unicode*/
+#define VFCF_JAIL       0x00400000      /* can be mounted from within a jail */
+
+typedef u_int32_t fsctlop_t;
+
+struct vfsidctl {
+	int		vc_vers;	/* should be VFSIDCTL_VERS1 (below) */
+	__fsid_t	vc_fsid;	/* fsid to operate on. */
+	char		vc_fstypename[MFSNAMELEN];
+					/* type of fs 'nfs' or '*' */
+	fsctlop_t	vc_op;		/* operation VFS_CTL_* (below) */
+	void		*vc_ptr;	/* pointer to data structure. */
+	size_t		vc_len;		/* sizeof said structure. */
+	u_int32_t	vc_spare[12];	/* spare (must be zero). */
+};
+
+/* vfsidctl API version. */
+#define VFS_CTL_VERS1	0x01
+
+/*
+ * New style VFS sysctls, do not reuse/conflict with the namespace for
+ * private sysctls.
+ * All "global" sysctl ops have the 33rd bit set:
+ * 0x...1....
+ * Private sysctl ops should have the 33rd bit unset.
+ */
+#define VFS_CTL_QUERY	0x00010001	/* anything wrong? (vfsquery) */
+#define VFS_CTL_TIMEO	0x00010002	/* set timeout for vfs notification */
+#define VFS_CTL_NOLOCKS	0x00010003	/* disable file locking */
+
+struct vfsquery {
+	u_int32_t	vq_flags;
+	u_int32_t	vq_spare[31];
+};
+
+/* vfsquery flags */
+#define VQ_NOTRESP	0x0001	/* server down */
+#define VQ_NEEDAUTH	0x0002	/* server bad auth */
+#define VQ_LOWDISK	0x0004	/* we're low on space */
+#define VQ_MOUNT	0x0008	/* new filesystem arrived */
+#define VQ_UNMOUNT	0x0010	/* filesystem has left */
+#define VQ_DEAD		0x0020	/* filesystem is dead, needs force unmount */
+#define VQ_ASSIST	0x0040	/* filesystem needs assistance from external
+				   program */
+#define VQ_NOTRESPLOCK	0x0080	/* server lockd down */
+#define VQ_FLAG0100	0x0100	/* placeholder */
+#define VQ_FLAG0200	0x0200	/* placeholder */
+#define VQ_FLAG0400	0x0400	/* placeholder */
+#define VQ_FLAG0800	0x0800	/* placeholder */
+#define VQ_FLAG1000	0x1000	/* placeholder */
+#define VQ_FLAG2000	0x2000	/* placeholder */
+#define VQ_FLAG4000	0x4000	/* placeholder */
+#define VQ_FLAG8000	0x8000	/* placeholder */
+
+
+struct iovec;
+struct uio;
+
+__BEGIN_DECLS
+
+/* Mounting and unmounting filesystems.  */
+int	mount(const char *, const char *, int, void *);
+int	nmount(struct iovec *, unsigned int, int);
+int	unmount(const char *, int);
+
+/*
+ * Copyright (c) 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Given a filesystem name, determine if it is resident in the kernel,
+ * and if it is resident, return its xvfsconf structure.
+ */
+static __inline int
+getvfsbyname(const char *fsname, struct xvfsconf *vfcp)
+{
+	struct xvfsconf *xvfsp;
+	size_t buflen;
+	int cnt, i;
+
+	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0)
+		return (-1);
+	xvfsp = (struct xvfsconf *) malloc(buflen);
+	if (xvfsp == NULL)
+		return (-1);
+	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
+		free(xvfsp);
+		return (-1);
+	}
+	cnt = buflen / sizeof(struct xvfsconf);
+	for (i = 0; i < cnt; i++) {
+		if (strcmp(fsname, xvfsp[i].vfc_name) == 0) {
+			memcpy(vfcp, xvfsp + i, sizeof(struct xvfsconf));
+			free(xvfsp);
+			return (0);
+		}
+	}
+	free(xvfsp);
+	errno = ENOENT;
+	return (-1);
+}
+
+/* getfsstat() appears in BSD 4.4.  A variant of this API is found on OSF/1,
+   but on that system the user also needs to include <sys/fs_types.h>.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getfsstat (struct statfs *__buf, long __bufsize,
+		      int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getfsstat,
+		       (struct statfs *__buf, long __bufsize, int __flags),
+		       getfsstat64);
+# else
+#  define getfsstat getfsstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getfsstat64 (struct statfs64 *__buf, long __bufsize,
+			int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getfsstat (struct statfs *__buf, long __bufsize, int __flags);
+extern int __getfsstat64 (struct statfs64 *__buf, long __bufsize, int __flags);
+#endif
+
+/* getmntinfo() appears in BSD 4.4.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getmntinfo (struct statfs **__mntbufp, int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getmntinfo,
+		       (struct statfs **__mntbufp, int __flags),
+		       getmntinfo64);
+# else
+#  define getmntinfo getmntinfo64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getmntinfo64 (struct statfs64 **__mntbufp, int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getmntinfo (struct statfs **__mntbufp, int __flags);
+#endif
+
+__END_DECLS
+
+
+/* Opening files on specified mounted filesystems.
+   These system calls are reserved to the superuser, for security reasons.  */
+
+__BEGIN_DECLS
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int getfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int lgetfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Open a file handle *FHP, using the open() like FLAGS.  Return the
+   new file descriptor.  */
+extern int fhopen (__const fhandle_t *__fhp, int __flags) __THROW;
+
+/* Get file attributes for the file whose handle is *FHP, and return them
+   in *BUF.  Like fhopen + fstat + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstat (__const fhandle_t *__fhp, struct stat *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstat,
+		       (__const fhandle_t *__fhp, struct stat *__buf),
+		       fhstat64);
+# else
+#  define fhstat fhstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstat64 (__const fhandle_t *__fhp, struct stat64 *__buf) __THROW;
+#endif
+
+/* Return information about the filesystem on which the file resides whose
+   handle is *FHP.  Like fhopen + fstatfs + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstatfs (__const fhandle_t *__fhp, struct statfs *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstatfs,
+		       (__const fhandle_t *__fhp, struct statfs *__buf),
+		       fhstatfs64);
+# else
+#  define fhstatfs fhstatfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstatfs64 (__const fhandle_t *__fhp,
+		       struct statfs64 *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_MOUNT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/param.h
@@ -0,0 +1,242 @@
+/* Copyright (C) 1995,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PARAM_H
+#define _SYS_PARAM_H	1
+
+#include <limits.h>
+#include <sys/syslimits.h>
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/*
+ * __FreeBSD_version numbers are documented in the Porter's Handbook.
+ * If you bump the version for any reason, you should update the documentation
+ * there.
+ * Currently this lives here:
+ *
+ *      doc/en_US.ISO8859-1/books/porters-handbook/book.sgml
+ *
+ * scheme is:  <major><two digit minor><0 if release branch, otherwise 1>xx
+ */
+#include <osreldate.h>
+
+/* Some inet code expects that this file defines the 'u_int32_t' type.  */
+#include <sys/types.h>
+#include <stdint.h>
+
+/* FreeBSD code expects that this file implicitly defines SIG* macros.  */
+#include <signal.h>
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be == UT_NAMESIZE+1 (see <utmp.h>)
+ */
+
+#define MAXCOMLEN       19              /* max command name remembered */
+#define MAXINTERP       32              /* max interpreter file name length */
+#define MAXLOGNAME      17              /* max login name length (incl. NUL) */
+#define MAXUPRC         CHILD_MAX       /* max simultaneous processes */
+#define NCARGS          ARG_MAX         /* max bytes for an exec function */
+#define NGROUPS         NGROUPS_MAX     /* max number groups */
+#define NOGROUP         65535           /* marker for empty group set member */
+#define MAXHOSTNAMELEN  256             /* max hostname size */
+#define SPECNAMELEN     63              /* max length of devicename */
+#define TTY_NAME_MAX	SPECNAMELEN
+
+/* BSD names for some <limits.h> values.  */
+
+#define	NBBY		CHAR_BIT
+#ifndef	NGROUPS
+# define NGROUPS	NGROUPS_MAX
+#endif
+#define	MAXSYMLINKS	32
+#define	CANBSIZ		MAX_CANON
+#define	NCARGS		ARG_MAX
+#define MAXPATHLEN	PATH_MAX
+
+/* The following is not really correct but it is a value we used for a
+   long time and which seems to be usable.  People should not use NOFILE
+   anyway.  */
+#define NOFILE		OPEN_MAX
+
+/* Bit map related macros.  */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding.  */
+#ifndef howmany
+# define howmany(x, y)	(((x) + ((y) - 1)) / (y))
+#endif
+#ifdef __GNUC__
+# define roundup(x, y)	(__builtin_constant_p (y) && powerof2 (y)	      \
+			 ? (((x) + (y) - 1) & ~((y) - 1))		      \
+			 : ((((x) + ((y) - 1)) / (y)) * (y)))
+#else
+# define roundup(x, y)	((((x) + ((y) - 1)) / (y)) * (y))
+#endif
+#define	roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define powerof2(x)	((((x) - 1) & (x)) == 0)
+
+/* Macros for min/max.  */
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+
+#ifndef DEV_BSHIFT
+#define DEV_BSHIFT	9               /* log2(DEV_BSIZE) */
+#endif
+#define DEV_BSIZE	(1<<DEV_BSHIFT)
+
+#ifndef BLKDEV_IOSIZE
+#define BLKDEV_IOSIZE	PAGE_SIZE        /* default block device I/O size */
+#endif
+#ifndef DFLTPHYS
+#define DFLTPHYS	(64 * 1024)     /* default max raw I/O transfer size */
+#endif
+#ifndef MAXPHYS
+#define MAXPHYS		(128 * 1024)    /* max raw I/O transfer size */
+#endif
+#ifndef MAXDUMPPGS
+#define MAXDUMPPGS	(DFLTPHYS/PAGE_SIZE)
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN 64 /* XXX */
+#endif /* No MAXHOSTNAMELEN.  */
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than PAGE_SIZE.
+ */
+#ifndef	MSIZE
+#define MSIZE		256		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to mbuf clusters */
+#endif	/* MCLSHIFT */
+
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an mbuf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#ifndef ctob
+#define ctob(x)	((x)<<PAGE_SHIFT)
+#endif
+
+/* bytes to clicks */
+#ifndef btoc
+#define btoc(x)	(((vm_offset_t)(x)+PAGE_MASK)>>PAGE_SHIFT)
+#endif
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#ifndef btodb
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+#endif
+
+#ifndef dbtob
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+#endif
+
+#endif /* _NO_NAMESPACE_POLLUTION */
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+#define	PDROP	0x200	/* OR'd with pri to stop re-entry of interlock mutex */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
+ *		per block.  MAXBSIZE may be made larger without effecting
+ *		any existing filesystems as long as it does not exceed MAXPHYS,
+ *		and may be made smaller at the risk of not being able to use
+ *		filesystems which require a block size exceeding MAXBSIZE.
+ *
+ * BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
+ *		minimum KVM memory reservation the kernel is willing to make.
+ *		Filesystems can of course request smaller chunks.  Actual
+ *		backing memory uses a chunk size of a page (PAGE_SIZE).
+ *
+ *		If you make BKVASIZE too small you risk seriously fragmenting
+ *		the buffer KVM map which may slow things down a bit.  If you
+ *		make it too big the kernel will not be able to optimally use
+ *		the KVM memory reserved for the buffer cache and will wind
+ *		up with too-few buffers.
+ *
+ *		The default is 16384, roughly 2x the block size used by a
+ *		normal UFS filesystem.
+ */
+#define MAXBSIZE	65536	/* must be power of 2 */
+#define BKVASIZE	16384	/* must be power of 2 */
+#define BKVAMASK	(BKVASIZE-1)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#define dbtoc(db)			/* calculates devblks to pages */ \
+	((db + (ctodb(1) - 1)) >> (PAGE_SHIFT - DEV_BSHIFT))
+
+#define ctodb(db)			/* calculates pages to devblks */ \
+	((db) << (PAGE_SHIFT - DEV_BSHIFT))
+
+#endif	/* _SYS_PARAM_H_ */
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h
@@ -0,0 +1,113 @@
+/*-
+ * Copyright (c) 1984, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ptrace.h	8.2 (Berkeley) 1/4/94
+ * $FreeBSD: src/sys/sys/ptrace.h,v 1.28.10.1.2.1 2009/10/25 01:10:29 kensmith Exp $
+ */
+ 
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+#define	PT_TRACE_ME	0	/* child declares it's being traced */
+#define	PT_READ_I	1	/* read word in child's I space */
+#define	PT_READ_D	2	/* read word in child's D space */
+/* was	PT_READ_U	3	 * read word in child's user structure */
+#define	PT_WRITE_I	4	/* write word in child's I space */
+#define	PT_WRITE_D	5	/* write word in child's D space */
+/* was	PT_WRITE_U	6	 * write word in child's user structure */
+#define	PT_CONTINUE	7	/* continue the child */
+#define	PT_KILL		8	/* kill the child process */
+#define	PT_STEP		9	/* single step the child */
+
+#define	PT_ATTACH	10	/* trace some running process */
+#define	PT_DETACH	11	/* stop tracing a process */
+#define PT_IO		12	/* do I/O to/from stopped process. */
+
+#if 0				/* our threading libray is different */
+#define	PT_LWPINFO	13	/* Info about the LWP that stopped. */
+#define PT_GETNUMLWPS	14	/* get total number of threads */
+#define PT_GETLWPLIST	15	/* get thread list */
+#endif
+
+#define PT_CLEARSTEP	16	/* turn off single step */
+#define PT_SETSTEP	17	/* turn on single step */
+#define PT_SUSPEND	18	/* suspend a thread */
+#define PT_RESUME	19	/* resume a thread */
+
+#define	PT_TO_SCE	20
+#define	PT_TO_SCX	21
+#define	PT_SYSCALL	22
+
+#define PT_GETREGS      33	/* get general-purpose registers */
+#define PT_SETREGS      34	/* set general-purpose registers */
+#define PT_GETFPREGS    35	/* get floating-point registers */
+#define PT_SETFPREGS    36	/* set floating-point registers */
+#define PT_GETDBREGS    37	/* get debugging registers */
+#define PT_SETDBREGS    38	/* set debugging registers */
+#define PT_FIRSTMACH    64	/* for machine-specific requests */
+
+struct ptrace_io_desc {
+	int	piod_op;	/* I/O operation */
+	void	*piod_offs;	/* child offset */
+	void	*piod_addr;	/* parent offset */
+	size_t	piod_len;	/* request length */
+};
+
+/*
+ * Operations in piod_op.
+ */
+#define PIOD_READ_D	1	/* Read from D space */
+#define PIOD_WRITE_D	2	/* Write to D space */
+#define PIOD_READ_I	3	/* Read from I space */
+#define PIOD_WRITE_I	4	/* Write to I space */
+
+#if 0
+/* Argument structure for PT_LWPINFO. */
+struct ptrace_lwpinfo {
+	lwpid_t	pl_lwpid;	/* LWP described. */
+	int	pl_event;	/* Event that stopped the LWP. */
+#define	PL_EVENT_NONE	0
+#define	PL_EVENT_SIGNAL	1
+	int	pl_flags;	/* LWP flags. */
+#define	PL_FLAG_SA	0x01	/* M:N thread */
+#define	PL_FLAG_BOUND	0x02	/* M:N bound thread */
+	sigset_t	pl_sigmask;	/* LWP signal mask */
+	sigset_t	pl_siglist;	/* LWP pending signal */
+};
+#endif
+
+extern int ptrace(int _request, pid_t _pid, caddr_t _addr, int _data) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/reboot.h
@@ -0,0 +1,81 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)reboot.h	8.3 (Berkeley) 12/13/94
+ * $FreeBSD: src/sys/sys/reboot.h,v 1.26.18.1 2008/11/25 02:59:29 kensmith Exp $
+ */
+
+#ifndef _SYS_REBOOT_H_
+#define	_SYS_REBOOT_H_	1
+
+#include <features.h>
+
+/*
+ * Arguments to reboot system call.  These are passed to
+ * the boot program and on to init.
+ */
+#define	RB_AUTOBOOT	0	/* flags for system auto-booting itself */
+
+#define	RB_ASKNAME	0x001	/* ask for file name to reboot from */
+#define	RB_SINGLE	0x002	/* reboot to single user only */
+#define	RB_NOSYNC	0x004	/* dont sync before reboot */
+#define	RB_HALT		0x008	/* don't reboot, just halt */
+#define	RB_INITNAME	0x010	/* name given for /etc/init (unused) */
+#define	RB_DFLTROOT	0x020	/* use compiled-in rootdev */
+#define	RB_KDB		0x040	/* give control to kernel debugger */
+#define	RB_RDONLY	0x080	/* mount root fs read-only */
+#define	RB_DUMP		0x100	/* dump kernel memory before reboot */
+#define	RB_MINIROOT	0x200	/* mini-root present in memory at boot time */
+#define	RB_VERBOSE	0x800	/* print all potentially useful info */
+#define	RB_SERIAL	0x1000	/* use serial port as console */
+#define	RB_CDROM	0x2000	/* use cdrom as root */
+#define	RB_POWEROFF	0x4000	/* turn the power off if possible */
+#define	RB_GDB		0x8000	/* use GDB remote debugger instead of DDB */
+#define	RB_MUTE		0x10000	/* start up with the console muted */
+#define	RB_SELFTEST	0x20000	/* don't complete the boot; do selftest */
+#define	RB_RESERVED1	0x40000	/* reserved for internal use of boot blocks */
+#define	RB_RESERVED2	0x80000	/* reserved for internal use of boot blocks */
+#define	RB_PAUSE	0x100000 /* pause after each output line during probe */
+#define	RB_MULTIPLE	0x20000000	/* use multiple consoles */
+
+#define	RB_BOOTINFO	0x80000000	/* have `struct bootinfo *' arg */
+
+/* 
+ * Compatibility with Linux
+ */
+#define RB_HALT_SYSTEM	RB_HALT
+#define RB_POWER_OFF	RB_POWEROFF
+
+__BEGIN_DECLS
+
+/* Reboot or halt the system.  */
+extern int reboot (int __howto) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h
@@ -0,0 +1,98 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
+ * $FreeBSD: src/sys/sys/unistd.h,v 1.22.2.1 2000/03/18 23:20:12 jasone Exp $
+ */
+
+#ifndef _SYS_RFORK_H
+#define _SYS_RFORK_H
+
+#include <features.h>
+
+/*
+ * rfork() options.
+ *
+ * XXX currently, operations without RFPROC set are not supported.
+ */
+#define RFNAMEG		(1<<0)  /* UNIMPL new plan9 `name space' */
+#define RFENVG		(1<<1)  /* UNIMPL copy plan9 `env space' */
+#define RFFDG		(1<<2)  /* copy fd table */
+#define RFNOTEG		(1<<3)  /* UNIMPL create new plan9 `note group' */
+#define RFPROC		(1<<4)  /* change child (else changes curproc) */
+#define RFMEM		(1<<5)  /* share `address space' */
+#define RFNOWAIT	(1<<6)  /* parent need not wait() on child */
+#define RFCNAMEG	(1<<10) /* UNIMPL zero plan9 `name space' */
+#define RFCENVG		(1<<11) /* UNIMPL zero plan9 `env space' */
+#define RFCFDG		(1<<12) /* zero fd table */
+#define RFTHREAD	(1<<13)	/* enable kernel thread support */
+#define RFSIGSHARE	(1<<14)	/* share signal handlers */
+#define RFLINUXTHPN     (1<<16) /* do linux clone exit parent notification */
+#define	RFSTOPPED	(1<<17) /* leave child in a stopped state */
+#define	RFHIGHPID	(1<<18) /* use a pid higher than 10 (idleproc) */
+#define	RFTSIGZMB	(1<<19) /* select signal for exit parent notification */
+#define	RFTSIGSHIFT	20      /* selected signal number is in bits 20-27  */
+#define	RFTSIGMASK	0xFF
+#define	RFTSIGNUM(flags)	(((flags) >> RFTSIGSHIFT) & RFTSIGMASK)
+#define	RFTSIGFLAGS(signum)	((signum) << RFTSIGSHIFT)
+#define RFPPWAIT	(1<<31) /* parent sleeps until child exits (vfork) */
+
+#define RFTHPNSHIFT	24	/* reserve bits 24-30 */
+#define RFTHPNMASK	0x7F    /* for compatibility with linuxthreads/clone()   */
+				/* allow to specify  "clone exit parent notification" signal */
+#define RFTHPNSIGNUM(flags)	(((flags) >> RFTHPNSHIFT) & RFTHPNMASK)
+
+__BEGIN_DECLS
+
+extern int rfork (int __flags) __THROW;
+
+#ifdef _LIBC
+extern int __rfork (int __flags);
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_RFORK_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/socketvar.h
@@ -0,0 +1,189 @@
+/* This header is used on many systems but for GNU we have 
+   almost everything defined in the standard header.  */
+
+#include <sys/socket.h>
+
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)socketvar.h	8.3 (Berkeley) 2/19/95
+ *
+ * $FreeBSD: src/sys/sys/socketvar.h,v 1.171.2.1.2.1 2009/10/25 01:10:29 kensmith Exp $
+ */
+
+#ifndef _SYS_SOCKETVAR_H_
+#define _SYS_SOCKETVAR_H_
+
+#include <sys/queue.h>			/* for TAILQ macros */
+#include <sys/selinfo.h>		/* for struct selinfo */
+#include <sys/_lock.h>
+#include <sys/_mutex.h>
+#include <sys/_sx.h>
+
+struct socket;
+struct vnet;
+
+struct	xsockbuf {
+	u_int	sb_cc;
+	u_int	sb_hiwat;
+	u_int	sb_mbcnt;
+	u_int   sb_mcnt;
+	u_int   sb_ccnt;
+	u_int	sb_mbmax;
+	int	sb_lowat;
+	int	sb_timeo;
+	short	sb_flags;
+};
+
+/*
+ * Variables for socket buffering.
+ */
+struct	sockbuf {
+	struct	selinfo sb_sel;	/* process selecting read/write */
+	struct	mtx sb_mtx;	/* sockbuf lock */
+	struct	sx sb_sx;	/* prevent I/O interlacing */
+	short	sb_state;	/* (c/d) socket state on sockbuf */
+#define	sb_startzero	sb_mb
+	struct	mbuf *sb_mb;	/* (c/d) the mbuf chain */
+	struct	mbuf *sb_mbtail; /* (c/d) the last mbuf in the chain */
+	struct	mbuf *sb_lastrecord;	/* (c/d) first mbuf of last
+					 * record in socket buffer */
+	struct	mbuf *sb_sndptr; /* (c/d) pointer into mbuf chain */
+	u_int	sb_sndptroff;	/* (c/d) byte offset of ptr into chain */
+	u_int	sb_cc;		/* (c/d) actual chars in buffer */
+	u_int	sb_hiwat;	/* (c/d) max actual char count */
+	u_int	sb_mbcnt;	/* (c/d) chars of mbufs used */
+	u_int   sb_mcnt;        /* (c/d) number of mbufs in buffer */
+	u_int   sb_ccnt;        /* (c/d) number of clusters in buffer */
+	u_int	sb_mbmax;	/* (c/d) max chars of mbufs to use */
+	u_int	sb_ctl;		/* (c/d) non-data chars in buffer */
+	int	sb_lowat;	/* (c/d) low water mark */
+	int	sb_timeo;	/* (c/d) timeout for read/write */
+	short	sb_flags;	/* (c/d) flags, see below */
+	int	(*sb_upcall)(struct socket *, void *, int); /* (c/d) */
+	void	*sb_upcallarg;	/* (c/d) */
+};
+
+
+/*
+ * Kernel structure per socket.
+ * Contains send and receive buffer queues,
+ * handle on protocol and pointer to protocol
+ * private data and error information.
+ */
+typedef	u_quad_t so_gen_t;
+
+
+/*-
+ * Locking key to struct socket:
+ * (a) constant after allocation, no locking required.
+ * (b) locked by SOCK_LOCK(so).
+ * (c) locked by SOCKBUF_LOCK(&so->so_rcv).
+ * (d) locked by SOCKBUF_LOCK(&so->so_snd).
+ * (e) locked by ACCEPT_LOCK().
+ * (f) not locked since integer reads/writes are atomic.
+ * (g) used only as a sleep/wakeup address, no value.
+ * (h) locked by global mutex so_global_mtx.
+ */
+struct socket {
+	int	so_count;		/* (b) reference count */
+	short	so_type;		/* (a) generic type, see socket.h */
+	short	so_options;		/* from socket call, see socket.h */
+	short	so_linger;		/* time to linger while closing */
+	short	so_state;		/* (b) internal state flags SS_* */
+	int	so_qstate;		/* (e) internal state flags SQ_* */
+	void	*so_pcb;		/* protocol control block */
+	struct	vnet *so_vnet;		/* network stack instance */
+	struct	protosw *so_proto;	/* (a) protocol handle */
+/*
+ * Variables for connection queuing.
+ * Socket where accepts occur is so_head in all subsidiary sockets.
+ * If so_head is 0, socket is not related to an accept.
+ * For head socket so_incomp queues partially completed connections,
+ * while so_comp is a queue of connections ready to be accepted.
+ * If a connection is aborted and it has so_head set, then
+ * it has to be pulled out of either so_incomp or so_comp.
+ * We allow connections to queue up based on current queue lengths
+ * and limit on number of queued connections for this socket.
+ */
+	struct	socket *so_head;	/* (e) back pointer to listen socket */
+	TAILQ_HEAD(, socket) so_incomp;	/* (e) queue of partial unaccepted connections */
+	TAILQ_HEAD(, socket) so_comp;	/* (e) queue of complete unaccepted connections */
+	TAILQ_ENTRY(socket) so_list;	/* (e) list of unaccepted connections */
+	u_short	so_qlen;		/* (e) number of unaccepted connections */
+	u_short	so_incqlen;		/* (e) number of unaccepted incomplete
+					   connections */
+	u_short	so_qlimit;		/* (e) max number queued connections */
+	short	so_timeo;		/* (g) connection timeout */
+	u_short	so_error;		/* (f) error affecting connection */
+	struct	sigio *so_sigio;	/* [sg] information for async I/O or
+					   out of band data (SIGURG) */
+	u_long	so_oobmark;		/* (c) chars to oob mark */
+	TAILQ_HEAD(, aiocblist) so_aiojobq; /* AIO ops waiting on socket */
+
+	struct sockbuf so_rcv, so_snd;
+
+	struct	ucred *so_cred;		/* (a) user credentials */
+	struct	label *so_label;	/* (b) MAC label for socket */
+	struct	label *so_peerlabel;	/* (b) cached MAC label for peer */
+	/* NB: generation count must not be first. */
+	so_gen_t so_gencnt;		/* (h) generation count */
+	void	*so_emuldata;		/* (b) private data for emulators */
+ 	struct so_accf {
+		struct	accept_filter *so_accept_filter;
+		void	*so_accept_filter_arg;	/* saved filter args */
+		char	*so_accept_filter_str;	/* saved user args */
+	} *so_accf;
+	int so_fibnum;		/* routing domain for this socket */
+};
+
+/*
+ * Externalized form of struct socket used by the sysctl(3) interface.
+ */
+struct xsocket {
+	size_t	xso_len;	/* length of this structure */
+	struct	socket *xso_so;	/* makes a convenient handle sometimes */
+	short	so_type;
+	short	so_options;
+	short	so_linger;
+	short	so_state;
+	caddr_t	so_pcb;		/* another convenient handle */
+	int	xso_protocol;
+	int	xso_family;
+	u_short	so_qlen;
+	u_short	so_incqlen;
+	u_short	so_qlimit;
+	short	so_timeo;
+	u_short	so_error;
+	pid_t	so_pgid;
+	u_long	so_oobmark;
+	struct xsockbuf so_rcv, so_snd;
+	uid_t	so_uid;		/* XXX */
+};
+
+#endif /* !_SYS_SOCKETVAR_H_ */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h
@@ -0,0 +1,37 @@
+/* Calls to enable swapping on specified locations.  FreeBSD version.
+   Copyright (C) 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __SYS_SWAP_H
+
+#define __SYS_SWAP_H	1
+#include <features.h>
+
+
+__BEGIN_DECLS
+
+/* Make the block special device PATH available to the system for swapping.
+   This call is restricted to the super-user.  */
+extern int swapon (__const char *__path) __THROW;
+
+/* Stop using block special device PATH for swapping.  */
+extern int swapoff (__const char *__path) __THROW;
+
+__END_DECLS
+
+#endif /* sys/swap.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h
@@ -0,0 +1,486 @@
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/*
+ * System call numbers.
+ *
+ * DO NOT EDIT-- this file is automatically generated.
+ * $FreeBSD$
+ * created from FreeBSD: head/sys/kern/syscalls.master 224987 2011-08-18 22:51:30Z jonathan 
+ */
+
+#define	SYS_syscall	0
+#define	SYS_exit	1
+#define	SYS_fork	2
+#define	SYS_read	3
+#define	SYS_write	4
+#define	SYS_open	5
+#define	SYS_close	6
+#define	SYS_wait4	7
+				/* 8 is old creat */
+#define	SYS_link	9
+#define	SYS_unlink	10
+				/* 11 is obsolete execv */
+#define	SYS_chdir	12
+#define	SYS_fchdir	13
+#define	SYS_mknod	14
+#define	SYS_chmod	15
+#define	SYS_chown	16
+#define	SYS_break	17
+#define	SYS_freebsd4_getfsstat	18
+				/* 19 is old lseek */
+#define	SYS_getpid	20
+#define	SYS_mount	21
+#define	SYS_unmount	22
+#define	SYS_setuid	23
+#define	SYS_getuid	24
+#define	SYS_geteuid	25
+#define	SYS_ptrace	26
+#define	SYS_recvmsg	27
+#define	SYS_sendmsg	28
+#define	SYS_recvfrom	29
+#define	SYS_accept	30
+#define	SYS_getpeername	31
+#define	SYS_getsockname	32
+#define	SYS_access	33
+#define	SYS_chflags	34
+#define	SYS_fchflags	35
+#define	SYS_sync	36
+#define	SYS_kill	37
+				/* 38 is old stat */
+#define	SYS_getppid	39
+				/* 40 is old lstat */
+#define	SYS_dup	41
+#define	SYS_pipe	42
+#define	SYS_getegid	43
+#define	SYS_profil	44
+#define	SYS_ktrace	45
+				/* 46 is old sigaction */
+#define	SYS_getgid	47
+				/* 48 is old sigprocmask */
+#define	SYS_getlogin	49
+#define	SYS_setlogin	50
+#define	SYS_acct	51
+				/* 52 is old sigpending */
+#define	SYS_sigaltstack	53
+#define	SYS_ioctl	54
+#define	SYS_reboot	55
+#define	SYS_revoke	56
+#define	SYS_symlink	57
+#define	SYS_readlink	58
+#define	SYS_execve	59
+#define	SYS_umask	60
+#define	SYS_chroot	61
+				/* 62 is old fstat */
+				/* 63 is old getkerninfo */
+				/* 64 is old getpagesize */
+#define	SYS_msync	65
+#define	SYS_vfork	66
+				/* 67 is obsolete vread */
+				/* 68 is obsolete vwrite */
+#define	SYS_sbrk	69
+#define	SYS_sstk	70
+				/* 71 is old mmap */
+#define	SYS_vadvise	72
+#define	SYS_munmap	73
+#define	SYS_mprotect	74
+#define	SYS_madvise	75
+				/* 76 is obsolete vhangup */
+				/* 77 is obsolete vlimit */
+#define	SYS_mincore	78
+#define	SYS_getgroups	79
+#define	SYS_setgroups	80
+#define	SYS_getpgrp	81
+#define	SYS_setpgid	82
+#define	SYS_setitimer	83
+				/* 84 is old wait */
+#define	SYS_swapon	85
+#define	SYS_getitimer	86
+				/* 87 is old gethostname */
+				/* 88 is old sethostname */
+#define	SYS_getdtablesize	89
+#define	SYS_dup2	90
+#define	SYS_fcntl	92
+#define	SYS_select	93
+#define	SYS_fsync	95
+#define	SYS_setpriority	96
+#define	SYS_socket	97
+#define	SYS_connect	98
+				/* 99 is old accept */
+#define	SYS_getpriority	100
+				/* 101 is old send */
+				/* 102 is old recv */
+				/* 103 is old sigreturn */
+#define	SYS_bind	104
+#define	SYS_setsockopt	105
+#define	SYS_listen	106
+				/* 107 is obsolete vtimes */
+				/* 108 is old sigvec */
+				/* 109 is old sigblock */
+				/* 110 is old sigsetmask */
+				/* 111 is old sigsuspend */
+				/* 112 is old sigstack */
+				/* 113 is old recvmsg */
+				/* 114 is old sendmsg */
+				/* 115 is obsolete vtrace */
+#define	SYS_gettimeofday	116
+#define	SYS_getrusage	117
+#define	SYS_getsockopt	118
+#define	SYS_readv	120
+#define	SYS_writev	121
+#define	SYS_settimeofday	122
+#define	SYS_fchown	123
+#define	SYS_fchmod	124
+				/* 125 is old recvfrom */
+#define	SYS_setreuid	126
+#define	SYS_setregid	127
+#define	SYS_rename	128
+				/* 129 is old truncate */
+				/* 130 is old ftruncate */
+#define	SYS_flock	131
+#define	SYS_mkfifo	132
+#define	SYS_sendto	133
+#define	SYS_shutdown	134
+#define	SYS_socketpair	135
+#define	SYS_mkdir	136
+#define	SYS_rmdir	137
+#define	SYS_utimes	138
+				/* 139 is obsolete 4.2 sigreturn */
+#define	SYS_adjtime	140
+				/* 141 is old getpeername */
+				/* 142 is old gethostid */
+				/* 143 is old sethostid */
+				/* 144 is old getrlimit */
+				/* 145 is old setrlimit */
+				/* 146 is old killpg */
+#define	SYS_setsid	147
+#define	SYS_quotactl	148
+				/* 149 is old quota */
+				/* 150 is old getsockname */
+#define	SYS_nlm_syscall	154
+#define	SYS_nfssvc	155
+				/* 156 is old getdirentries */
+#define	SYS_freebsd4_statfs	157
+#define	SYS_freebsd4_fstatfs	158
+#define	SYS_lgetfh	160
+#define	SYS_getfh	161
+#define	SYS_freebsd4_getdomainname	162
+#define	SYS_freebsd4_setdomainname	163
+#define	SYS_freebsd4_uname	164
+#define	SYS_sysarch	165
+#define	SYS_rtprio	166
+#define	SYS_semsys	169
+#define	SYS_msgsys	170
+#define	SYS_shmsys	171
+#define	SYS_freebsd6_pread	173
+#define	SYS_freebsd6_pwrite	174
+#define	SYS_setfib	175
+#define	SYS_ntp_adjtime	176
+#define	SYS_setgid	181
+#define	SYS_setegid	182
+#define	SYS_seteuid	183
+#define	SYS_stat	188
+#define	SYS_fstat	189
+#define	SYS_lstat	190
+#define	SYS_pathconf	191
+#define	SYS_fpathconf	192
+#define	SYS_getrlimit	194
+#define	SYS_setrlimit	195
+#define	SYS_getdirentries	196
+#define	SYS_freebsd6_mmap	197
+#define	SYS___syscall	198
+#define	SYS_freebsd6_lseek	199
+#define	SYS_freebsd6_truncate	200
+#define	SYS_freebsd6_ftruncate	201
+#define	SYS___sysctl	202
+#define	SYS_mlock	203
+#define	SYS_munlock	204
+#define	SYS_undelete	205
+#define	SYS_futimes	206
+#define	SYS_getpgid	207
+#define	SYS_poll	209
+#define	SYS_freebsd7___semctl	220
+#define	SYS_semget	221
+#define	SYS_semop	222
+#define	SYS_freebsd7_msgctl	224
+#define	SYS_msgget	225
+#define	SYS_msgsnd	226
+#define	SYS_msgrcv	227
+#define	SYS_shmat	228
+#define	SYS_freebsd7_shmctl	229
+#define	SYS_shmdt	230
+#define	SYS_shmget	231
+#define	SYS_clock_gettime	232
+#define	SYS_clock_settime	233
+#define	SYS_clock_getres	234
+#define	SYS_ktimer_create	235
+#define	SYS_ktimer_delete	236
+#define	SYS_ktimer_settime	237
+#define	SYS_ktimer_gettime	238
+#define	SYS_ktimer_getoverrun	239
+#define	SYS_nanosleep	240
+#define	SYS_ntp_gettime	248
+#define	SYS_minherit	250
+#define	SYS_rfork	251
+#define	SYS_openbsd_poll	252
+#define	SYS_issetugid	253
+#define	SYS_lchown	254
+#define	SYS_aio_read	255
+#define	SYS_aio_write	256
+#define	SYS_lio_listio	257
+#define	SYS_getdents	272
+#define	SYS_lchmod	274
+#define	SYS_netbsd_lchown	275
+#define	SYS_lutimes	276
+#define	SYS_netbsd_msync	277
+#define	SYS_nstat	278
+#define	SYS_nfstat	279
+#define	SYS_nlstat	280
+#define	SYS_preadv	289
+#define	SYS_pwritev	290
+#define	SYS_freebsd4_fhstatfs	297
+#define	SYS_fhopen	298
+#define	SYS_fhstat	299
+#define	SYS_modnext	300
+#define	SYS_modstat	301
+#define	SYS_modfnext	302
+#define	SYS_modfind	303
+#define	SYS_kldload	304
+#define	SYS_kldunload	305
+#define	SYS_kldfind	306
+#define	SYS_kldnext	307
+#define	SYS_kldstat	308
+#define	SYS_kldfirstmod	309
+#define	SYS_getsid	310
+#define	SYS_setresuid	311
+#define	SYS_setresgid	312
+				/* 313 is obsolete signanosleep */
+#define	SYS_aio_return	314
+#define	SYS_aio_suspend	315
+#define	SYS_aio_cancel	316
+#define	SYS_aio_error	317
+#define	SYS_oaio_read	318
+#define	SYS_oaio_write	319
+#define	SYS_olio_listio	320
+#define	SYS_yield	321
+				/* 322 is obsolete thr_sleep */
+				/* 323 is obsolete thr_wakeup */
+#define	SYS_mlockall	324
+#define	SYS_munlockall	325
+#define	SYS___getcwd	326
+#define	SYS_sched_setparam	327
+#define	SYS_sched_getparam	328
+#define	SYS_sched_setscheduler	329
+#define	SYS_sched_getscheduler	330
+#define	SYS_sched_yield	331
+#define	SYS_sched_get_priority_max	332
+#define	SYS_sched_get_priority_min	333
+#define	SYS_sched_rr_get_interval	334
+#define	SYS_utrace	335
+#define	SYS_freebsd4_sendfile	336
+#define	SYS_kldsym	337
+#define	SYS_jail	338
+#define	SYS_nnpfs_syscall	339
+#define	SYS_sigprocmask	340
+#define	SYS_sigsuspend	341
+#define	SYS_freebsd4_sigaction	342
+#define	SYS_sigpending	343
+#define	SYS_freebsd4_sigreturn	344
+#define	SYS_sigtimedwait	345
+#define	SYS_sigwaitinfo	346
+#define	SYS___acl_get_file	347
+#define	SYS___acl_set_file	348
+#define	SYS___acl_get_fd	349
+#define	SYS___acl_set_fd	350
+#define	SYS___acl_delete_file	351
+#define	SYS___acl_delete_fd	352
+#define	SYS___acl_aclcheck_file	353
+#define	SYS___acl_aclcheck_fd	354
+#define	SYS_extattrctl	355
+#define	SYS_extattr_set_file	356
+#define	SYS_extattr_get_file	357
+#define	SYS_extattr_delete_file	358
+#define	SYS_aio_waitcomplete	359
+#define	SYS_getresuid	360
+#define	SYS_getresgid	361
+#define	SYS_kqueue	362
+#define	SYS_kevent	363
+#define	SYS_extattr_set_fd	371
+#define	SYS_extattr_get_fd	372
+#define	SYS_extattr_delete_fd	373
+#define	SYS___setugid	374
+#define SYS_nfsclnt	375
+#define	SYS_eaccess	376
+#define	SYS_afs3_syscall	377
+#define	SYS_nmount	378
+#define	SYS___mac_get_proc	384
+#define	SYS___mac_set_proc	385
+#define	SYS___mac_get_fd	386
+#define	SYS___mac_get_file	387
+#define	SYS___mac_set_fd	388
+#define	SYS___mac_set_file	389
+#define	SYS_kenv	390
+#define	SYS_lchflags	391
+#define	SYS_uuidgen	392
+#define	SYS_sendfile	393
+#define	SYS_mac_syscall	394
+#define	SYS_getfsstat	395
+#define	SYS_statfs	396
+#define	SYS_fstatfs	397
+#define	SYS_fhstatfs	398
+#define	SYS_ksem_close	400
+#define	SYS_ksem_post	401
+#define	SYS_ksem_wait	402
+#define	SYS_ksem_trywait	403
+#define	SYS_ksem_init	404
+#define	SYS_ksem_open	405
+#define	SYS_ksem_unlink	406
+#define	SYS_ksem_getvalue	407
+#define	SYS_ksem_destroy	408
+#define	SYS___mac_get_pid	409
+#define	SYS___mac_get_link	410
+#define	SYS___mac_set_link	411
+#define	SYS_extattr_set_link	412
+#define	SYS_extattr_get_link	413
+#define	SYS_extattr_delete_link	414
+#define	SYS___mac_execve	415
+#define	SYS_sigaction	416
+#define	SYS_sigreturn	417
+#define	SYS_getcontext	421
+#define	SYS_setcontext	422
+#define	SYS_swapcontext	423
+#define	SYS_swapoff	424
+#define	SYS___acl_get_link	425
+#define	SYS___acl_set_link	426
+#define	SYS___acl_delete_link	427
+#define	SYS___acl_aclcheck_link	428
+#define	SYS_sigwait	429
+#define	SYS_thr_create	430
+#define	SYS_thr_exit	431
+#define	SYS_thr_self	432
+#define	SYS_thr_kill	433
+#define	SYS__umtx_lock	434
+#define	SYS__umtx_unlock	435
+#define	SYS_jail_attach	436
+#define	SYS_extattr_list_fd	437
+#define	SYS_extattr_list_file	438
+#define	SYS_extattr_list_link	439
+#define	SYS_ksem_timedwait	441
+#define	SYS_thr_suspend	442
+#define	SYS_thr_wake	443
+#define	SYS_kldunloadf	444
+#define	SYS_audit	445
+#define	SYS_auditon	446
+#define	SYS_getauid	447
+#define	SYS_setauid	448
+#define	SYS_getaudit	449
+#define	SYS_setaudit	450
+#define	SYS_getaudit_addr	451
+#define	SYS_setaudit_addr	452
+#define	SYS_auditctl	453
+#define	SYS__umtx_op	454
+#define	SYS_thr_new	455
+#define	SYS_sigqueue	456
+#define	SYS_kmq_open	457
+#define	SYS_kmq_setattr	458
+#define	SYS_kmq_timedreceive	459
+#define	SYS_kmq_timedsend	460
+#define	SYS_kmq_notify	461
+#define	SYS_kmq_unlink	462
+#define	SYS_abort2	463
+#define	SYS_thr_set_name	464
+#define	SYS_aio_fsync	465
+#define	SYS_rtprio_thread	466
+#define	SYS_sctp_peeloff	471
+#define	SYS_sctp_generic_sendmsg	472
+#define	SYS_sctp_generic_sendmsg_iov	473
+#define	SYS_sctp_generic_recvmsg	474
+#define	SYS_pread	475
+#define	SYS_pwrite	476
+#define	SYS_mmap	477
+#define	SYS_lseek	478
+#define	SYS_truncate	479
+#define	SYS_ftruncate	480
+#define	SYS_thr_kill2	481
+#define	SYS_shm_open	482
+#define	SYS_shm_unlink	483
+#define	SYS_cpuset	484
+#define	SYS_cpuset_setid	485
+#define	SYS_cpuset_getid	486
+#define	SYS_cpuset_getaffinity	487
+#define	SYS_cpuset_setaffinity	488
+#define	SYS_faccessat	489
+#define	SYS_fchmodat	490
+#define	SYS_fchownat	491
+#define	SYS_fexecve	492
+#define	SYS_fstatat	493
+#define	SYS_futimesat	494
+#define	SYS_linkat	495
+#define	SYS_mkdirat	496
+#define	SYS_mkfifoat	497
+#define	SYS_mknodat	498
+#define	SYS_openat	499
+#define	SYS_readlinkat	500
+#define	SYS_renameat	501
+#define	SYS_symlinkat	502
+#define	SYS_unlinkat	503
+#define	SYS_posix_openpt	504
+#define	SYS_gssd_syscall	505
+#define	SYS_jail_get	506
+#define	SYS_jail_set	507
+#define	SYS_jail_remove	508
+#define	SYS_closefrom	509
+#define	SYS___semctl	510
+#define	SYS_msgctl	SYS_freebsd7_msgctl
+#define	SYS_shmctl	SYS_freebsd7_shmctl
+#define	SYS_lpathconf	513
+#define	SYS_cap_new	514
+#define	SYS_cap_getrights	515
+#define	SYS_cap_enter	516
+#define	SYS_cap_getmode	517
+#define	SYS_pdfork	518
+#define	SYS_pdkill	519
+#define	SYS_pdgetpid	520
+#define	SYS_pselect	522
+#define	SYS_getloginclass	523
+#define	SYS_setloginclass	524
+#define	SYS_rctl_get_racct	525
+#define	SYS_rctl_get_rules	526
+#define	SYS_rctl_get_limits	527
+#define	SYS_rctl_add_rule	528
+#define	SYS_rctl_remove_rule	529
+#define SYS_posix_fallocate	530
+#define SYS_posix_fadvise	531
+#define	SYS_MAXSYSCALL	532
+
+#define SYS_obreak	SYS_break
+#define SYS_sysctl	SYS___sysctl
+#define SYS_getcwd	SYS___getcwd
+#define SYS_setugid	SYS___setugid
+#define SYS_semctl	SYS_freebsd7___semctl
+
+#define SYS_acl_get_file	SYS___acl_get_file
+#define SYS_acl_set_file	SYS___acl_set_file
+#define SYS_acl_get_fd		SYS___acl_get_fd
+#define SYS_acl_set_fd		SYS___acl_set_fd
+#define SYS_acl_delete_file	SYS___acl_delete_file
+#define SYS_acl_delete_fd	SYS___acl_delete_fd
+#define SYS_acl_aclcheck_file	SYS___acl_aclcheck_file
+#define SYS_acl_aclcheck_fd	SYS___acl_aclcheck_fd
+#define SYS_acl_get_link	SYS___acl_get_link
+#define SYS_acl_set_link	SYS___acl_set_link
+#define SYS_acl_delete_link	SYS___acl_delete_link
+#define SYS_acl_aclcheck_link	SYS___acl_aclcheck_link
+
+#define SYS_mac_get_proc	SYS___mac_get_proc
+#define SYS_mac_set_proc	SYS___mac_set_proc
+#define SYS_mac_get_fd		SYS___mac_get_fd
+#define SYS_mac_get_file	SYS___mac_get_file
+#define SYS_mac_set_fd		SYS___mac_set_fd
+#define SYS_mac_set_file	SYS___mac_set_file
+#define SYS_mac_get_pid		SYS___mac_get_pid
+#define SYS_mac_get_link	SYS___mac_get_link
+#define SYS_mac_set_link	SYS___mac_set_link
+#define SYS_mac_execve		SYS___mac_execve
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h
@@ -0,0 +1,36 @@
+/* Definitions of macros to access `dev_t' values.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+/* For compatibility we provide alternative names.
+
+   The problem here is that compilers other than GCC probably don't
+   have the `long long' type and so `dev_t' is actually an array.  */
+#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
+#define minor(dev) ((int)((dev) & 0xffff00ff))
+#define makedev(major, minor) (((major) << 8) | (minor))
+
+/* Access the functions with their new names.  */
+#define gnu_dev_major(dev) major (dev)
+#define gnu_dev_minor(dev) minor (dev)
+#define gnu_dev_makedev(maj, min) makedev (maj, min)
+
+#endif /* sys/sysmacros.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
+ */
+
+/*
+ * System wide defaults for terminal state.  FreeBSD version.
+ */
+#ifndef _SYS_TTYDEFAULTS_H_
+#define _SYS_TTYDEFAULTS_H_
+
+/*
+ * Defaults on "first" open.
+ */
+#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG	(OPOST | ONLCR)
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
+#define TTYDEF_SPEED	(B9600)
+
+/*
+ * Control Character Defaults
+ */
+#define CTRL(x)	(x&037)
+#define CEOF		CTRL('d')
+#ifdef _POSIX_VDISABLE
+# define CEOL		_POSIX_VDISABLE
+#else
+# define CEOL		((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define CERASE		0177
+#define CERASE2		CTRL('h')
+#define CINTR		CTRL('c')
+#define CSTATUS		CTRL('t')
+#define CKILL		CTRL('u')
+#define CMIN		1
+#define CQUIT		034		/* FS, ^\ */
+#define CSUSP		CTRL('z')
+#define CTIME		0
+#define CDSUSP		CTRL('y')
+#define CSTART		CTRL('q')
+#define CSTOP		CTRL('s')
+#define CLNEXT		CTRL('v')
+#define CDISCARD 	CTRL('o')
+#define CWERASE 	CTRL('w')
+#define CREPRINT 	CTRL('r')
+#define CEOT		CEOF
+/* compat */
+#define CBRK		CEOL
+#define CRPRNT		CREPRINT
+#define CFLUSH		CDISCARD
+
+/* PROTECTED INCLUSION ENDS HERE */
+#endif /* !_SYS_TTYDEFAULTS_H_ */
+
+/*
+ * #define TTYDEFCHARS to include an array of default control characters.
+ */
+#ifdef TTYDEFCHARS
+cc_t	ttydefchars[NCCS] = {
+	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
+	CERASE2, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
+	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
+};
+#undef TTYDEFCHARS
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h
@@ -0,0 +1,48 @@
+/* Data structures for user-level context switching.  Generic version.
+   Copyright (C) 1997-1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file's definitions suffice for any platform where all
+   the machine-specific state is described in `struct sigcontext'.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* This include file defines the type 'mcontext_t'.  */
+#include <bits/mcontext.h>
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    __sigset_t uc_sigmask;
+    mcontext_t uc_mcontext;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    int     uc_flags;
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+    int __unused1[4];
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/un.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 1991, 1995, 1996, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_UN_H
+#define	_SYS_UN_H	1
+
+#include <sys/cdefs.h>
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+__BEGIN_DECLS
+
+/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
+struct sockaddr_un
+  {
+    __SOCKADDR_COMMON (sun_);
+    char sun_path[104];		/* Path name, the kernel restrict it to 104, */
+#if defined(__i386__) || defined(__amd64__)
+    char __sun_user_compat[4];  /* but former user header used 108 */
+#endif    
+  };
+
+
+#ifdef __USE_MISC
+# include <string.h>		/* For prototype of `strlen'.  */
+
+/* Evaluate to actual length of the `sockaddr_un' structure.  */
+# define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)	      \
+		      + strlen ((ptr)->sun_path))
+#endif
+
+__END_DECLS
+
+#endif	/* sys/un.h  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls-inline.h
@@ -0,0 +1,59 @@
+/* prototypes of generally used "inline syscalls"
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INLINE_SYSCALLS_H
+#define KFREEBSD_INLINE_SYSCALLS_H
+
+#include <sys/types.h>
+#define __need_sigset_t
+#include <signal.h>
+
+#include <syscalls-internal.h>
+
+struct iovec;
+struct rusage;
+struct timespec;
+
+int __syscall_open(const char *path, int flags, ...);
+int __syscall_close(int fd);
+libc_hidden_proto (__syscall_open)
+libc_hidden_proto (__syscall_close)
+
+ssize_t __syscall_read(int fd, void *buf, size_t nbyte);
+ssize_t __syscall_write(int fd, const void *buf, size_t nbyte);
+ssize_t __syscall_writev(int fd, const struct iovec *iovp, int iovcnt);
+libc_hidden_proto (__syscall_read)
+libc_hidden_proto (__syscall_write)
+libc_hidden_proto (__syscall_writev)
+
+ssize_t __syscall_readlink(const char *path, char *buf, size_t bufsiz);
+libc_hidden_proto (__syscall_readlink)
+
+int __syscall_fcntl(int fd, int cmd, ...);
+int __syscall_fork(void);
+int __syscall_wait4(int pid, int *status, int options, struct rusage *rusage);
+int __syscall_sigsuspend (const sigset_t *set);
+int __syscall_nanosleep (const struct timespec *requested_time, struct timespec *remaining);
+libc_hidden_proto (__syscall_fcntl)
+libc_hidden_proto (__syscall_fork)
+libc_hidden_proto (__syscall_wait4)
+libc_hidden_proto (__syscall_sigsuspend)
+libc_hidden_proto (__syscall_nanosleep)
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls.list
@@ -0,0 +1,199 @@
+# File name		Caller	Syscall name		# args		Strong name	Weak names
+sys_access		-	access			i:si		__syscall_access
+acl_aclcheck_fd		-	acl_aclcheck_fd		i:iip		__acl_aclcheck_fd
+acl_aclcheck_file	-	acl_aclcheck_file	i:sip		__acl_aclcheck_file
+acl_delete_fd		-	acl_delete_fd		i:ii		__acl_delete_fd
+acl_delete_file		-	acl_delete_file		i:si		__acl_delete_file
+acl_get_fd		-	acl_get_fd		i:iip		__acl_get_fd
+acl_get_file		-	acl_get_file		i:sip		__acl_get_file
+acl_set_fd		-	acl_set_fd		i:iip		__acl_set_fd
+acl_set_file		-	acl_set_file		i:sip		__acl_set_file
+sys_aio_cancel		-	aio_cancel		i:ip		__syscall_aio_cancel
+sys_aio_error		-	aio_error		i:p		__syscall_aio_error
+sys_aio_read		-	aio_read		i:p		__syscall_aio_read
+sys_aio_return		-	aio_return		i:p		__syscall_aio_return
+sys_aio_suspend		-	aio_suspend		i:bnP		__syscall_aio_suspend
+sys_aio_waitcomplete	-	aio_waitcomplete	i:pp		__syscall_aio_waitcomplete
+sys_aio_write		-	aio_write		i:p		__syscall_aio_write
+sys_clock_getres	-	clock_getres		i:ip		__syscall_clock_getres
+sys_clock_gettime	-	clock_gettime		i:ip		__syscall_clock_gettime
+sys_clock_settime	-	clock_settime		i:ip		__syscall_clock_settime
+sys_ktimer_create	-	ktimer_create		i:iPp		__syscall_ktimer_create
+sys_ktimer_gettime	-	ktimer_gettime		i:ip		__syscall_ktimer_gettime
+sys_ktimer_settime	-	ktimer_settime		i:iipp		__syscall_ktimer_settime
+sys_ktimer_getoverrun	-	ktimer_getoverrun	i:i		__syscall_ktimer_getoverrun
+sys_ktimer_delete	-	ktimer_delete		i:i		__syscall_ktimer_delete
+sys_execve		-	execve			i:ppp		__syscall_execve
+extattrctl		-	extattrctl		i:sisI		extattrctl
+extattr_delete_file	-	extattr_delete_file	i:ss		extattr_delete_file
+extattr_get_file	-	extattr_get_file	i:ssbn		extattr_get_file
+extattr_set_file	-	extattr_set_file	i:ssbn		extattr_set_file
+fhopen			-	fhopen			i:pi		fhopen
+sys_fork		-	fork			i:		__syscall_fork	fork
+sys_fhstat		-	fhstat			i:pp		__syscall_fhstat
+sys_getfsstat		-	getfsstat		i:pii		__syscall_getfsstat
+sys_statfs		-	statfs			i:sp		__syscall_statfs
+sys_fstatfs		-	fstatfs			i:ip		__syscall_fstatfs
+sys_fhstatfs		-	fhstatfs		i:pp		__syscall_fhstatfs
+sys_fstat		-	fstat			i:ip		__syscall_fstat
+sys_ftruncate		-	ftruncate		i:ii		__syscall_ftruncate
+sys_freebsd6_ftruncate	-	freebsd6_ftruncate	i:iii		__syscall_freebsd6_ftruncate
+futimes			-	futimes			i:ip		__futimes futimes
+sys_getcwd		-	getcwd			i:bn		__syscall_getcwd
+sys_getdents		-	getdents		i:ibn		__syscall_getdents
+sys_getdirentries	-	getdirentries		i:ibnP		__syscall_getdirentries
+getfh			-	getfh			i:sp		getfh
+sys_getlogin		-	getlogin		i:bn		__syscall_getlogin
+getpgid			-	getpgid			i:i		__getpgid __getpgid_internal getpgid
+getpgrp			-	getpgrp			i:		getpgrp
+getresgid		-	getresgid		i:ppp		getresgid
+getresuid		-	getresuid		i:ppp		getresuid
+getrlimit		-	getrlimit		i:ip		__getrlimit getrlimit getrlimit64
+getsid			-	getsid			i:i		getsid
+issetugid		-	issetugid		i:		issetugid
+jail			-	jail			i:p		jail
+jail_attach		-	jail_attach		i:i		jail_attach
+jail_remove		-	jail_remove		i:i		jail_remove
+jail_get		-	jail_get		i:pii		jail_get
+jail_set		-	jail_set		i:pii		jail_set
+kenv			-	kenv			i:issi		kenv
+kldfind			-	kldfind			i:s		kldfind
+kldfirstmod		-	kldfirstmod		i:i		kldfirstmod
+kldload			-	kldload			i:s		kldload
+kldnext			-	kldnext			i:i		kldnext
+kldstat			-	kldstat			i:ip		kldstat
+kldsym			-	kldsym			i:iip		kldsym
+kldunload		-	kldunload		i:i		kldunload
+kldunloadf		-	kldunloadf		i:ii		kldunloadf
+ktrace			-	ktrace			i:siii		ktrace
+lchflags		-	lchflags		i:si		lchflags
+lchmod			-	lchmod			i:si		__lchmod lchmod
+lchown			-	lchown			i:sii		__lchown lchown
+sys_lio_listio		-	lio_listio		i:ibnP		__syscall_lio_listio
+sys_lseek		-	lseek			i:iii		__syscall_lseek
+sys_freebsd6_lseek	-	freebsd6_lseek		i:iiii		__syscall_freebsd6_lseek
+sys_lstat		-	lstat			i:sp		__syscall_lstat
+lutimes			-	lutimes			i:sp		__lutimes lutimes
+posix_madvise		-	madvise			i:pii		posix_madvise
+minherit		-	minherit		i:aii		minherit
+mincore			-	mincore			i:anV		mincore
+mlock			-	mlock			i:bn		mlock
+mlockall		-	mlockall		i:i		mlockall
+mkfifo			-	mkfifo			i:si		__mkfifo mkfifo
+sys_mknod		-	mknod			i:sii		__syscall_mknod
+sys_mmap		-	mmap			b:aniiii	__syscall_mmap
+sys_freebsd6_mmap	-	freebsd6_mmap		b:aniiiii	__syscall_freebsd6_mmap
+sys_munmap		-	munmap			i:pi		__syscall_munmap
+modfind			-	modfind			i:s		modfind
+modfnext		-	modfnext		i:i		modfnext
+modnext			-	modnext			i:i		modnext
+modstat			-	modstat			i:ip		modstat
+mount			-	mount			i:ssiP		mount
+msgctl			-	msgctl			i:iip		msgctl
+msgget			-	msgget			i:ii		msgget
+msgrcv			-	msgrcv			Ci:ibnii	__libc_msgrcv msgrcv
+msgsnd			-	msgsnd			Ci:ibni		__libc_msgsnd msgsnd
+munlock			-	munlock			i:ai		munlock
+munlockall		-	munlockall		i:		munlockall
+nanosleep		-	nanosleep		Ci:pp		__libc_nanosleep __nanosleep nanosleep
+nfssvc			-	nfssvc			i:ip		nfssvc
+nlm_syscall		-	nlm_syscall		i:iiip		nlm_syscall
+nmount			-	nmount			i:pii		nmount
+sys_nfstat		-	nfstat			i:ip		__syscall_nfstat
+sys_nlstat		-	nlstat			i:sp		__syscall_nlstat
+sys_nstat		-	nstat			i:sp		__syscall_nstat
+ntp_adjtime		-	ntp_adjtime		i:p		ntp_adjtime
+obreak			-	obreak			i:a		__syscall_obreak
+sys_open		-	open			i:siv		__syscall_open
+poll			-	poll			Ci:pii		__poll poll
+sys_pread		-	pread			i:ibni		__syscall_pread
+sys_freebsd6_pread	-	freebsd6_pread		i:ibnii		__syscall_freebsd6_pread
+sys_pwrite		-	pwrite			i:ibni		__syscall_pwrite
+sys_freebsd6_pwrite	-	freebsd6_pwrite		i:ibnii		__syscall_freebsd6_pwrite
+preadv			-	preadv			Ci:ipii		__preadv  preadv  __preadv64  preadv64 
+pwritev			-	pwritev			Ci:ipii		__pwritev pwritev __pwritev64 pwritev64 
+quotactl		-	quotactl		i:siip		quotactl
+sys_readv		-	readv			i:ipi		__syscall_readv
+rfork			-	rfork			i:i		__rfork rfork
+rtprio			-	rtprio			i:iip		__rtprio rtprio
+sched_gets		-	sched_getscheduler	i:i		__sched_getscheduler sched_getscheduler
+sched_primax		-	sched_get_priority_max	i:i		__sched_get_priority_max sched_get_priority_max
+sched_primin		-	sched_get_priority_min	i:i		__sched_get_priority_min sched_get_priority_min
+sched_rr_gi		-	sched_rr_get_interval	i:ip		__sched_rr_get_interval sched_rr_get_interval
+sched_setp		-	sched_setparam		i:ip		__sched_setparam sched_setparam
+sched_sets		-	sched_setscheduler	i:iip		__sched_setscheduler sched_setscheduler
+sched_yield		-	sched_yield		i:		__sched_yield sched_yield
+semget			-	semget			i:iii		semget
+semop			-	semop			i:ipi		semop
+sys_semctl		-	semctl			i:iiip		__syscall_semctl
+bsd_sendfile		-	sendfile		i:iiiippi	bsd_sendfile
+setegid			-	setegid			i:i		setegid
+seteuid			-	seteuid			i:i		seteuid
+setgid			-	setgid			i:i		__setgid setgid
+sys_setlogin		-	setlogin		i:s		__syscall_setlogin
+setpgid			-	setpgid			i:ii		__setpgid setpgid
+setresgid		-	setresgid		i:iii		setresgid
+setresuid		-	setresuid		i:iii		setresuid
+setrlimit		-	setrlimit		i:ip		__setrlimit setrlimit setrlimit64
+setsid			-	setsid			i:		__setsid setsid
+setuid			-	setuid			i:i		__setuid setuid
+shmat			-	shmat			i:iai		shmat
+shmctl			-	shmctl			i:iip		shmctl
+shmdt			-	shmdt			i:a		shmdt
+shmget			-	shmget			i:iii		shmget
+sys_sigaction		-	sigaction		i:ipp		__syscall_sigaction
+sigpending		-	sigpending		i:p		sigpending
+sigprocmask		-	sigprocmask		i:iPP		__sigprocmask sigprocmask
+sigsuspend		-	sigsuspend		Ci:p		__sigsuspend sigsuspend
+sigwaitinfo		-	sigwaitinfo		Ci:pp		__sigwaitinfo sigwaitinfo
+sigtimedwait		-	sigtimedwait		Ci:ppP		__sigtimedwait sigtimedwait
+sigqueue		-	sigqueue		i:iii		__sigqueue sigqueue
+sys_stat		-	stat			i:sp		__syscall_stat
+sysarch			-	sysarch			i:ip		__sysarch sysarch
+sysctl			-	sysctl			i:pibNbn	__sysctl sysctl
+sys_truncate		-	truncate		i:sii		__syscall_truncate
+sys_freebsd6_truncate	-	freebsd6_truncate	i:si		__syscall_freebsd6_truncate
+undelete		-	undelete		i:s		undelete
+unmount			-	unmount			i:si		unmount
+utrace			-	utrace			i:bn		utrace
+sys_writev		-	writev			i:ipi		__syscall_writev
+yield			-	yield			i:		__syscall_yield
+wait4			-	wait4			i:iWiP		__syscall_wait4 __wait4	wait4
+sys_close		-	close			i:i		__syscall_close
+sys_fcntl		-	fcntl			i:iiF		__syscall_fcntl
+sys_write		-	write			i:ibn		__syscall_write
+sys_read		-	read			i:ibn		__syscall_read
+sys_connect		-	connect			i:ipi		__syscall_connect
+sys_bind		-	bind			i:ipi		__syscall_bind
+sys_sendto		-	sendto			i:ibnibn	__syscall_sendto
+sys_nanosleep		EXTRA	nanosleep		i:pp		__syscall_nanosleep
+sys_sigsuspend		EXTRA	sigsuspend		i:p		__syscall_sigsuspend
+swapcontext		-	swapcontext		i:pp		__swapcontext swapcontext
+swapon			-	swapon			i:s		swapon
+swapoff			-	swapoff			i:s		swapoff
+getcontext		-	getcontext		i:p		__getcontext getcontext
+setcontext		-	setcontext		i:p		__setcontext setcontext
+kqueue			EXTRA	kqueue			i:		__kqueue kqueue
+kevent			EXTRA	kevent			i:ipipip	__kevent kevent
+sys_umtx		-	_umtx_op		i:piipp		__syscall__umtx_op
+sys_cpuset_getaffinity	-	cpuset_getaffinity	i:iiiip		__syscall_cpuset_getaffinity
+sys_cpuset_setaffinity	-	cpuset_setaffinity	i:iiiip		__syscall_cpuset_setaffinity
+sys_faccessat		-	faccessat		i:isii		__syscall_faccessat
+sys_fchmodat		-	fchmodat		i:isii		__syscall_fchmodat
+sys_fchownat		-	fchownat		i:isiii		__syscall_fchownat
+sys_fexecve		-	fexecve			i:ipp		__syscall_fexecve
+sys_fstatat		-	fstatat			i:ispi		__syscall_fstatat
+sys_futimesat		-	futimesat		i:isp		__syscall_futimesat
+sys_linkat		-	linkat			i:isisi		__syscall_linkat
+sys_mkdirat		-	mkdirat			i:isi		__syscall_mkdirat
+sys_mkfifoat		-	mkfifoat		i:isi		__syscall_mkfifoat
+sys_mknodat		-	mknodat			i:isii		__syscall_mknodat
+sys_openat		-	openat			i:isii		__syscall_openat
+sys_readlinkat		-	readlinkat		i:issi		__syscall_readlinkat
+sys_renameat		-	renameat		i:isis		__syscall_renameat
+sys_symlinkat		-	symlinkat		i:sis		__syscall_symlinkat
+sys_unlinkat		-	unlinkat		i:isi		__syscall_unlinkat
+sys_shm_open		-	shm_open		i:sii		__syscall_shm_open
+sys_shm_unlink		-	shm_unlink		i:s		__syscall_shm_unlink
+readlink		-	readlink       		i:spi   	__syscall_readlink __readlink readlink
+sys_pselect		-	pselect			i:iPPPPP	__syscall_pselect
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysconf.c
@@ -0,0 +1,69 @@
+/* Get file-specific information about a file.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+#include <hp-timing.h>
+#include <sys/sysctl.h>
+
+static long int posix_sysconf (int name);
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  int request[2];
+  int value;
+  size_t len = sizeof(value);
+
+  switch(name)
+    {
+      case _SC_CPUTIME:
+      case _SC_THREAD_CPUTIME:
+#if HP_TIMING_AVAIL
+	// XXX We can add  here test for machines which cannot support a
+	// XXX usable TSC.
+	return 200809L;
+#else
+	return -1;
+#endif
+      case _SC_NGROUPS_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_NGROUPS;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return NGROUPS_MAX;
+	return (long)value;
+      case _SC_ARG_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_ARGMAX;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return ARG_MAX;
+	return (long)value;
+    }
+  return posix_sysconf (name);
+}
+
+/* Now the POSIX version.  */
+#undef __sysconf
+#define __sysconf static posix_sysconf
+#include <sysdeps/posix/sysconf.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <string.h>
+
+/* Read or write system parameters.  */
+int
+__sysctlbyname (const char *name, void *oldval, size_t *oldlenp, const void *newval, size_t newlen)
+{
+  int request[CTL_MAXNAME+2];
+  size_t requestlen = CTL_MAXNAME+2;
+
+  if (__sysctlnametomib(name, request, &requestlen) < 0)
+    return -1;
+
+  /* Now call sysctl using the binary encoded request.  */
+  return __sysctl (request, requestlen,
+		   oldval, oldlenp, newval, newlen);
+}
+
+weak_alias (__sysctlbyname, sysctlbyname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlnametomib.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <string.h>
+
+int
+__sysctlnametomib (const char *name, int *mibp, size_t *sizep)
+{
+  /* Convert the string NAME to a binary encoded request.  The kernel
+     contains a routine for doing this, called "name2oid".  But the way
+     to call it is a little bit strange.  */
+  int name2oid_request[2] = { 0, 3 };
+  int retval;
+  
+  *sizep *= sizeof (int);
+  retval = __sysctl (name2oid_request, 2, mibp, sizep, (void *) name, strlen (name));
+  *sizep /= sizeof (int);
+  return retval;
+}
+
+weak_alias (__sysctlnametomib, sysctlnametomib)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcdrain.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sysdep-cancel.h>
+#include <stddef.h>
+
+/* Wait for pending output to be written on FD.  */
+int
+__libc_tcdrain (int fd)
+{
+  if (SINGLE_THREAD_P)
+    return __ioctl (fd, TIOCDRAIN);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __ioctl (fd, TIOCDRAIN);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_tcdrain, tcdrain)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcflow.c
@@ -0,0 +1,4 @@
+/* just use internal functions */
+#define tcgetattr __tcgetattr
+#define write __write
+#include <sysdeps/unix/bsd/tcflow.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/unix/telldir.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/testrtsig.h
@@ -0,0 +1,37 @@
+/* Test whether RT signals are really available.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <string.h>
+
+#include <kernel-features.h>
+#include <getosreldate.h>
+
+static int
+kernel_has_rtsig (void)
+{
+#if __ASSUME_REALTIME_SIGNALS
+  return 1;
+#else
+  if (__kernel_getosreldate () < 700050) /* FreeBSD 7.0 is 700055 */
+      return 0;
+  return 1;
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <errno.h>
+
+extern int __syscall_truncate (const char *__file, __off_t __length) __THROW;
+libc_hidden_proto (__syscall_truncate)
+extern int __syscall_freebsd6_truncate (const char *__file, int __unused1,
+			       __off_t __length) __THROW;
+libc_hidden_proto (__syscall_freebsd6_truncate)
+
+int
+__truncate (const char *file, __off_t length)
+{
+  int result;
+
+  /* First try the new syscall. */
+  result = INLINE_SYSCALL (truncate, 2, file, length);
+
+#ifndef __ASSUME_TRUNCATE_SYSCALL
+  if (result == -1 && errno == ENOSYS)
+    /* New syscall not available, us the old one. */
+    result = INLINE_SYSCALL (freebsd6_truncate, 3, file, 0, length);
+#endif
+
+  return result;
+}
+
+weak_alias (__truncate, truncate)
+
+/* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
+strong_alias (__truncate, __truncate64)
+weak_alias (__truncate64, truncate64)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c
@@ -0,0 +1 @@
+/* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ttyname.c
@@ -0,0 +1,71 @@
+/* Copyright (C) 1991,92,93,96,97,98,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* Static buffer in `ttyname'.  */
+libc_freeres_ptr (static char *ttyname_buf);
+
+static const char dev[] = "/dev";
+
+/* Return the pathname of the terminal FD is open on, or NULL on errors.
+   The returned storage is good only until the next call to this function.  */
+char *
+ttyname (fd)
+     int fd;
+{
+  static size_t buflen;
+  struct fiodgname_arg fgn;
+
+  /* isatty check, tcgetattr is used because it sets the correct
+     errno (EBADF resp. ENOTTY) on error.  */
+  struct termios term;
+  if (__builtin_expect (__tcgetattr (fd, &term) < 0, 0))
+    return NULL;
+
+  if (buflen == 0)
+    {
+      buflen = 4095;
+      ttyname_buf = (char *) malloc (buflen + 1);
+      if (ttyname_buf == NULL)
+	{
+	  buflen = 0;
+	  return NULL;
+	}
+    }
+
+  /* Prepare the result buffer.  */
+  memcpy (ttyname_buf, dev, sizeof (dev) - 1);
+  ttyname_buf[sizeof (dev) - 1] = '/';
+
+  fgn.buf = ttyname_buf + sizeof (dev);
+  fgn.len = buflen - sizeof (dev);
+
+  if (__ioctl(fd, FIODGNAME, &fgn) == -1)
+    {
+      return NULL; 
+    }
+
+  return ttyname_buf;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ttyname_r.c
@@ -0,0 +1,78 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+static const char dev[] = "/dev";
+
+/* Store at most BUFLEN character of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success,  otherwise an error number.  */
+int
+__ttyname_r (fd, buf, buflen)
+     int fd;
+     char *buf;
+     size_t buflen;
+{
+  int ret;
+  struct fiodgname_arg fgn;
+
+  /* Test for the absolute minimal size.  This makes life easier inside
+     the loop.  */
+  if (!buf)
+    {
+      __set_errno (EINVAL);
+      return EINVAL;
+    }
+
+  if (buflen < (int) (sizeof (dev) + 1))
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
+
+  /* isatty check, tcgetattr is used because it sets the correct
+     errno (EBADF resp. ENOTTY) on error.  */
+  struct termios term;
+  if (__builtin_expect (__tcgetattr (fd, &term) < 0, 0))
+    return errno;
+
+  /* Prepare the result buffer.  */
+  memcpy (buf, dev, sizeof (dev) - 1);
+  buf[sizeof (dev) - 1] = '/';
+
+  fgn.buf = buf + sizeof (dev);
+  fgn.len = buflen - sizeof (dev);
+
+  ret = __ioctl(fd, FIODGNAME, &fgn);
+  if (ret == -1)
+    {
+      __set_errno (EBADF);
+      return EBADF;
+    }
+
+  return 0;
+}
+
+weak_alias (__ttyname_r, ttyname_r)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ulimit.c
@@ -0,0 +1,2 @@
+/* just use linux variant */
+#include <sysdeps/unix/sysv/linux/ulimit.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c
@@ -0,0 +1,110 @@
+/* Copyright (C) 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/utsname.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <string.h>
+
+#define SYSNAME                "GNU/kFreeBSD"
+#define SYSNAME_LEN    13
+
+/* Check for bounds in pre-processor */
+#if SYSNAME_LEN > _UTSNAME_SYSNAME_LENGTH
+#error
+#endif
+
+/* Put information about the system in NAME.  */
+int
+__uname (struct utsname *name)
+{
+  int request[2] = { CTL_KERN };
+  size_t len;
+
+  /* Fill sysname: "uname -s". */
+  strcpy (name->sysname, SYSNAME);
+
+  /* Fill nodename: "uname -n".  Fetch sysctl "kern.hostname".  */
+  request[1] = KERN_HOSTNAME;
+  len = sizeof (name->nodename);
+  if (__sysctl (request, 2, name->nodename, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->nodename))
+	name->nodename[len] = '\0';
+    }
+
+  /* Fill release: "uname -r".  Fetch sysctl "kern.osrelease".  */
+  request[1] = KERN_OSRELEASE;
+  len = sizeof (name->release);
+  if (__sysctl (request, 2, name->release, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->release))
+        name->release[len] = '\0';
+    }
+
+  /* Fill version: "uname -v".  Fetch sysctl "kern.version".  */
+  request[1] = KERN_VERSION;
+  len = sizeof (name->version);
+  if (__sysctl (request, 2, name->version, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->version))
+        name->version[len] = '\0';
+    }
+
+  /* Remove trailing whitespace.  Turn non-trailing whitespace to
+     spaces.  */
+  {
+    char *p0 = name->version;
+    char *p = p0 + __strnlen (p0, sizeof (name->version));
+
+    while (p > p0 && (p[-1] == '\t' || p[-1] == '\n' || p[-1] == ' '))
+      *--p = '\0';
+
+    while (p > p0)
+      {
+        --p;
+        if (*p == '\t' || *p == '\n')
+          *p = ' ';
+      }
+  }
+
+#ifdef __x86_64__
+  /* Check for bounds in pre-processor */
+# if 7 > _UTSNAME_MACHINE_LENGTH
+#  error
+# endif
+  /* Pristine FreeBSD kernel would return "amd64".  Avoid that.  */
+  strcpy (name->machine, "x86_64");
+#else
+  /* Fill machine: "uname -m".  Fetch sysctl "hw.machine".  */
+  request[0] = CTL_HW;
+  request[1] = HW_MACHINE;
+  len = sizeof (name->machine);
+  if (__sysctl (request, 2, name->machine, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->machine))
+        name->machine[len] = '\0';
+    }
+#endif
+
+  return 0;
+}
+libc_hidden_def (__uname)
+weak_alias (__uname, uname)
+libc_hidden_def (uname)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/unlinkat.c
@@ -0,0 +1,135 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_unlinkat (int fd, const char *file, int flag);
+libc_hidden_proto (__syscall_unlinkat)
+
+libc_hidden_proto (__unlink)
+
+/* Remove the link named NAME.  */
+int
+unlinkat (fd, file, flag)
+     int fd;
+     const char *file;
+     int flag;
+{
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result = INLINE_SYSCALL (unlinkat, 3, fd, file, flag);
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (flag & ~AT_REMOVEDIR)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+  if (flag & AT_REMOVEDIR)
+    return __rmdir (file);
+  else
+    return __unlink (file);
+#endif
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/unlockpt.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+int
+__unlockpt (int fd)
+{
+  struct stat64 st;
+
+  /* there is no need/way to do unlocking of slave pseudo-terminal device,
+     just check whether fd might be valid master pseudo-terminal device */
+
+  if (__fxstat64 (_STAT_VER, fd, &st) < 0)
+    return -1;
+
+  if (!(S_ISCHR (st.st_mode)))
+  {
+    __set_errno (ENOTTY);
+    return -1;
+  }
+
+  return 0;
+}
+
+weak_alias (__unlockpt, unlockpt)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c
@@ -0,0 +1,50 @@
+/* Implementation of the BSD usleep function using nanosleep.
+   Copyright (C) 1996-1997, 1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+#include <unistd.h>
+
+int
+usleep (useconds_t useconds)
+{
+  unsigned int sec;
+  unsigned int usec;
+  struct timespec ts;
+
+  /* POSIX:2001 says that useconds >= 1000000 is invalid; nevertheless let's
+     be forgiving.  */
+  if (__builtin_expect (useconds < 1000000, 1))
+    {
+      sec = 0;
+      usec = useconds;
+    }
+  else
+    {
+      sec = useconds / 1000000;
+      usec = useconds % 1000000;
+    }
+
+  ts.tv_sec = sec;
+  ts.tv_nsec = usec * 1000;	/* Multiply as 32-bit integers.  */
+
+  /* Note the usleep() is a cancellation point.  But since we call
+     nanosleep() which itself is a cancellation point we do not have
+     to do anything here.  */
+  return __nanosleep (&ts, NULL);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c
@@ -0,0 +1,66 @@
+/* Return info on filesystem.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ustat.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+int
+ustat (dev_t dev, struct ustat *ubuf)
+{
+  int mntcount;
+  struct statfs *mntlist;
+
+  /* Search for the device among the f_mntfromname fields of all mounted
+     filesystems.  */
+  mntcount = __getmntinfo (&mntlist, 0);
+  if (mntcount == 0 && errno != 0)
+    return -1;
+  if (mntcount > 0)
+    {
+      int i;
+
+      for (i = 0; i < mntcount; i++)
+	{
+	  struct statfs *mnt = &mntlist[i];
+	  struct stat statbuf;
+
+	  if ((__strnlen (mnt->f_mntfromname, sizeof (mnt->f_mntfromname))
+	       < sizeof (mnt->f_mntfromname))
+	      && __xstat (_STAT_VER, mnt->f_mntfromname, &statbuf) >= 0
+	      && S_ISBLK (statbuf.st_mode)
+	      && statbuf.st_rdev == dev)
+	    {
+	      /* Found the device.  Now produce the result.  */
+	      memset (ubuf, '\0', sizeof (struct ustat));
+	      ubuf->f_tfree = mnt->f_bfree;
+	      ubuf->f_tinode = mnt->f_ffree;
+	      return 0;
+	    }
+	}
+    }
+
+  /* DEV is not among the mounted devices.  */
+  __set_errno (EINVAL);
+  return -1;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile
@@ -0,0 +1,6 @@
+# Additional functions:
+
+ifeq ($(subdir),login)
+# For <utmpx.h>.
+sysdep_routines += utmpconv
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h
@@ -0,0 +1,50 @@
+/* The `struct utmp' type, describing entries in the utmp file.  For FreeBSD.
+   Copyright (C) 1993, 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <time.h>
+
+
+#define	UT_NAMESIZE	16
+#define	UT_LINESIZE	8
+#define	UT_HOSTSIZE	16
+
+
+struct lastlog
+  {
+    time_t ll_time;
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+struct utmp
+  {
+    char ut_line[UT_LINESIZE];
+    char ut_user[UT_NAMESIZE];
+#define ut_name ut_user
+    char ut_host[UT_HOSTSIZE];
+    __time_t ut_time;
+  };
+
+
+#define _HAVE_UT_HOST 1		/* We have the ut_host field.  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Copy the information in UTMPX to UTMP. */
+void
+getutmp (const struct utmpx *utmpx, struct utmp *utmp)
+{
+  if (__utmpx_to_utmp (utmpx, utmp) < 0)
+    memset (utmp, '\0', sizeof (struct utmp));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Copy the information in UTMP to UTMPX. */
+void
+getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
+{
+  if (__utmp_to_utmpx (utmp, utmpx) < 0)
+    memset (utmpx, '\0', sizeof (struct utmpx));
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+__getutxent (void)
+{
+  for (;;)
+    {
+      struct utmp *tmp = __getutent ();
+
+      if (tmp == NULL)
+	return NULL;
+
+      if (__utmp_to_utmpx (tmp, &buffer) >= 0)
+	return &buffer;
+
+      /* Skip entries that cannot be converted to utmpx.  */
+    }
+}
+
+weak_alias (__getutxent, getutxent)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxid (const struct utmpx *id)
+{
+  switch (id->ut_type)
+    {
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  switch (next->ut_type)
+	    {
+	    case INIT_PROCESS:
+	    case LOGIN_PROCESS:
+	    case USER_PROCESS:
+	    case DEAD_PROCESS:
+	      if (strncmp (next->ut_id, id->ut_id, sizeof (id->ut_id)) == 0)
+		return next;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+
+    default:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  if (next->ut_type == id->ut_type)
+	    return next;
+	}
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxline (const struct utmpx *line)
+{
+  for (;;)
+    {
+      struct utmpx *next = __getutxent ();
+
+      if (next == NULL)
+	return NULL;
+
+      if ((next->ut_type == LOGIN_PROCESS || next->ut_type == USER_PROCESS)
+	  && strncmp (next->ut_line, line->ut_line, __UT_LINESIZE) == 0)
+	return next;
+    }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+pututxline (const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    {
+      struct utmp *tmpres = __pututline (&tmp);
+
+      if (tmpres != NULL)
+	{
+	  if (__utmp_to_utmpx (tmpres, &buffer) >= 0)
+	    return &buffer;
+
+	  /* Hmm.  We wrote a 'struct utmp' that we cannot convert back
+	     to 'struct utmpx'.  Shouldn't happen that often.  */
+	  return NULL;
+	}
+    }
+  return NULL;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+void
+updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    __updwtmp (wtmpx_file, &tmp);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 1996-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <utmp.h>
+
+#include <utmp-private.h>
+
+/* Test whether two entries match.  */
+static int
+__utmp_equal (const struct utmp *entry, const struct utmp *match)
+{
+  /* This implementation is consistent with the __utmp_to_utmpx function.  */
+  return
+    (!((entry->ut_line[0] == '\0' && entry->ut_name[0] == '\0'
+	&& entry->ut_host[0] == '\0')
+       || ((entry->ut_line[0] == '~' || entry->ut_line[0] == '{'
+	    || entry->ut_line[0] == '|')
+	   && entry->ut_line[1] == '\0'))
+     &&
+     !((match->ut_line[0] == '\0' && match->ut_name[0] == '\0'
+	&& match->ut_host[0] == '\0')
+       || ((match->ut_line[0] == '~' || match->ut_line[0] == '{'
+	    || match->ut_line[0] == '|')
+	   && match->ut_line[1] == '\0'))
+     &&
+#if _HAVE_UT_ID - 0
+     (entry->ut_id[0] && match->ut_id[0]
+      ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
+      : strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0)
+#else
+     strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0
+#endif
+     );
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c
@@ -0,0 +1 @@
+#include <login/utmp_file.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c
@@ -0,0 +1,227 @@
+/* Convert between 'struct utmp' and 'struct utmx'.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* We reuse the 'struct utmp' file format also for 'struct utmpx' records.
+   The mapping from 'struct utmp' to 'struct utmpx' is injective; the
+   reverse mapping succeeds only when common conventions are respected.  */
+
+#include <utmp.h>
+#include <utmpx.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/* Compare two 'struct utmpx' records.  */
+int
+__utmpx_equal (const struct utmpx *u1, const struct utmpx *u2)
+{
+  return (u1->ut_type == u2->ut_type)
+	 && (u1->ut_pid == u2->ut_pid)
+	 && (strncmp (u1->ut_line, u2->ut_line, __UT_LINESIZE) == 0)
+	 && (strncmp (u1->ut_id, u2->ut_id, sizeof (u1->ut_id)) == 0)
+	 && (strncmp (u1->ut_user, u2->ut_user, __UT_NAMESIZE) == 0)
+	 && (strncmp (u1->ut_host, u2->ut_host, __UT_HOSTSIZE) == 0)
+	 && (u1->ut_exit.e_termination == u2->ut_exit.e_termination)
+	 && (u1->ut_exit.e_exit == u2->ut_exit.e_exit)
+	 && (u1->ut_session == u2->ut_session)
+	 && (u1->ut_tv.tv_sec == u2->ut_tv.tv_sec)
+	 && (u1->ut_tv.tv_usec == u2->ut_tv.tv_usec)
+	 && (memcmp (u1->ut_addr_v6, u2->ut_addr_v6, sizeof (u1->ut_addr_v6))
+	     == 0);
+}
+
+int
+__utmp_to_utmpx (const struct utmp *u, struct utmpx *ux)
+{
+  memset (ux, '\0', sizeof (struct utmpx));
+
+  if (u->ut_line[0] == '\0' && u->ut_name[0] == '\0' && u->ut_host[0] == '\0')
+    {
+      ux->ut_type = EMPTY;
+    }
+  else
+    {
+      if (u->ut_line[0] == '~' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "runlevel", UT_NAMESIZE) == 0)
+	    ux->ut_type = RUN_LVL;
+	  else if (strncmp (u->ut_name, "reboot", UT_NAMESIZE) == 0)
+	    ux->ut_type = BOOT_TIME;
+	  else if (strncmp (u->ut_name, "acct", UT_NAMESIZE) == 0)
+	    ux->ut_type = ACCOUNTING;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '{' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = NEW_TIME;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '|' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = OLD_TIME;
+	  else
+	    return -1;
+	}
+      else
+	{
+	  if (strncmp (u->ut_name, "INIT", UT_NAMESIZE) == 0)
+	    ux->ut_type = INIT_PROCESS;
+	  else if (strncmp (u->ut_name, "LOGIN", UT_NAMESIZE) == 0)
+	    ux->ut_type = LOGIN_PROCESS;
+	  else if (strncmp (u->ut_name, "", UT_NAMESIZE) == 0)
+	    ux->ut_type = DEAD_PROCESS;
+	  else
+	    ux->ut_type = USER_PROCESS;
+
+	  if (ux->ut_type == LOGIN_PROCESS || ux->ut_type == USER_PROCESS)
+	    strncpy (ux->ut_user, u->ut_name, UT_NAMESIZE);
+
+	  if (strncmp (u->ut_line, "tty", 3) == 0)
+	    {
+	      strncpy (ux->ut_line, u->ut_line, UT_LINESIZE);
+	      strncpy (ux->ut_id, u->ut_line + 3, sizeof (ux->ut_id));
+	    }
+	  else
+	    {
+	      strncpy (ux->ut_id, u->ut_line, sizeof (ux->ut_id));
+	    }
+	}
+
+      strncpy (ux->ut_host, u->ut_host, UT_HOSTSIZE);
+
+      /* Hack: Recover the ut_pid from the hidden place after the host.  */
+      if (__strnlen (u->ut_host, UT_HOSTSIZE) < UT_HOSTSIZE - 2)
+	{
+	  const char *hidden = u->ut_host + strlen (u->ut_host) + 1;
+
+	  if (hidden[0] != '\0')
+	    {
+	      size_t n = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+	      char buf[UT_HOSTSIZE];
+	      unsigned long pid;
+	      char *endp;
+
+	      strncpy (buf, hidden, n);
+	      buf[n] = '\0';
+
+	      pid = strtoul (buf, &endp, 10);
+	      if (endp != buf && *endp == '\0')
+		ux->ut_pid = pid;
+	    }
+	}
+
+      ux->ut_tv.tv_sec = u->ut_time;
+      ux->ut_tv.tv_usec = 0;
+    }
+
+  return 0;
+}
+
+int
+__utmpx_to_utmp (const struct utmpx *ux, struct utmp *u)
+{
+  char buf[10+1];
+
+  switch (ux->ut_type)
+    {
+    case EMPTY:
+      strncpy (u->ut_line, "", UT_LINESIZE);
+      strncpy (u->ut_name, "", UT_NAMESIZE);
+      strncpy (u->ut_host, "", UT_HOSTSIZE);
+      break;
+
+    case RUN_LVL:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "runlevel", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case BOOT_TIME:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "reboot", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case NEW_TIME:
+      strncpy (u->ut_line, "{", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case OLD_TIME:
+      strncpy (u->ut_line, "|", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      if (ux->ut_line[0] != '\0')
+	strncpy (u->ut_line, ux->ut_line, UT_LINESIZE);
+      else
+	strncpy (u->ut_line, ux->ut_id, sizeof (ux->ut_id));
+      switch (ux->ut_type)
+	{
+	case INIT_PROCESS:
+	  strncpy (u->ut_name, "INIT", UT_NAMESIZE);
+	  break;
+	case LOGIN_PROCESS:
+	  strncpy (u->ut_name, "LOGIN", UT_NAMESIZE);
+	  break;
+	case USER_PROCESS:
+	  strncpy (u->ut_name, ux->ut_user, UT_NAMESIZE);
+	  break;
+	case DEAD_PROCESS:
+	  strncpy (u->ut_name, "", UT_NAMESIZE);
+	  break;
+	}
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case ACCOUNTING:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "acct", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    default:
+      return -1;
+    }
+
+  u->ut_time = ux->ut_tv.tv_sec;
+
+  /* Hack: Put the ut_pid at a hidden place where there is likely room.  */
+  if (ux->ut_pid != 0)
+    {
+      size_t room = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+
+      sprintf (buf, "%lu", (unsigned long) ux->ut_pid);
+      if (strlen (buf) <= room)
+	strncpy (u->ut_host + strlen (u->ut_host) + 1, buf, room);
+    }
+
+  return 0;
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/utmp_file.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait3.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait3.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/waitpid.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 1991,95,96,97,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <stddef.h>
+#include <sysdep-cancel.h>
+
+/* Wait for a child matching PID to die.
+   If PID is greater than 0, match any process whose process ID is PID.
+   If PID is (pid_t) -1, match any process.
+   If PID is (pid_t) 0, match any process with the
+   same process group as the current process.
+   If PID is less than -1, match any process whose
+   process group is the absolute value of PID.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, return (pid_t) 0.  If successful,
+   return PID and store the dead child's status in STAT_LOC.
+   Return (pid_t) -1 for errors.  If the WUNTRACED bit is set in OPTIONS,
+   return status for stopped children; otherwise don't.  */
+pid_t
+__libc_waitpid (pid_t pid, int *stat_loc, int options)
+{
+  if (SINGLE_THREAD_P)
+  {
+      return INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+  }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_waitpid, __waitpid)
+libc_hidden_weak (__waitpid)
+weak_alias (__libc_waitpid, waitpid)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c
@@ -0,0 +1,57 @@
+/* writev for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_writev (int, const struct iovec *__unbounded, int);
+
+static ssize_t __atomic_writev_replacement (int, const struct iovec *,
+					    int) internal_function;
+
+ssize_t
+__libc_writev (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (writev, 3, fd, CHECK_N (vector, count), count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result =  INLINE_SYSCALL (writev, 3, fd, CHECK_N (vector, count), count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_writev_replacement (fd, vector, count);
+}
+strong_alias (__libc_writev, __writev)
+weak_alias (__libc_writev, writev)
+
+#define __libc_writev static internal_function __atomic_writev_replacement
+#include <sysdeps/posix/writev.c>
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Makefile
@@ -0,0 +1,17 @@
+32bit-predefine = __i386__
+64bit-predefine = __x86_64__
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += iopl ioperm
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Versions
@@ -0,0 +1,8 @@
+libc {
+  GLIBC_2.3.4 {
+    iopl;
+  }
+  GLIBC_2.10 {
+    ioperm;
+  }
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/____longjmp_chk.S
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include<__longjmp.S>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/mcontext.h
@@ -0,0 +1,167 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  x86_64 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 2003 Peter Wemm
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/amd64/include/ucontext.h,v 1.18 2003/11/08 04:39:22 peter Exp $
+ */
+
+#ifdef __i386__
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+#else
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+    long mc_onstack;		/* XXX - sigcontext compat. */
+    long mc_rdi;			/* machine state (struct trapframe) */
+    long mc_rsi;
+    long mc_rdx;
+    long mc_rcx;
+    long mc_r8;
+    long mc_r9;
+    long mc_rax;
+    long mc_rbx;
+    long mc_rbp;
+    long mc_r10;
+    long mc_r11;
+    long mc_r12;
+    long mc_r13;
+    long mc_r14;
+    long mc_r15;
+    long mc_trapno;
+    long mc_addr;
+    long mc_flags;
+    long mc_err;
+    long mc_rip;
+    long mc_cs;
+    long mc_rflags;
+    long mc_rsp;
+    long mc_ss;
+
+    long mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_XMM		0x10002
+    long mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    long mc_ownedfp;
+     /*
+      * See <machine/fpu.h> for the internals of mc_fpstate[].
+      */
+    long mc_fpstate[64] __attribute__((aligned(16)));
+    long mc_spare[8];
+} mcontext_t;
+
+#endif
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/sigcontext.h
@@ -0,0 +1,147 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+#ifdef __i386__
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#else
+
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    long 	sc_onstack;		/* Nonzero if running on sigstack.  */
+    union { long sc_rdi; long rdi;};
+    union { long sc_rsi; long rsi;};
+    union { long sc_rdx; long rdx;};
+    union { long sc_rcx; long rcx;};
+    union { long sc_r8; long r8;};
+    union { long sc_r9; long r9;};
+    union { long sc_rax; long rax;};
+    union { long sc_rbx; long rbx;};
+    union { long sc_rbp; long rbp;};
+    union { long sc_r10; long r10;};
+    union { long sc_r11; long r11;};
+    union { long sc_r12; long r12;};
+    union { long sc_r13; long r13;};
+    union { long sc_r14; long r14;};
+    union { long sc_r15; long r15;};
+    union { long sc_trapno; long trapno;};
+    union { long sc_addr; long addr;};
+    union { long sc_flags; long flags;};
+    union { long sc_err; long err;};
+    union { long sc_rip; long rip;};
+    union { long sc_cs; long cs;};
+    union { long sc_rflags; long rflags;};
+    union { long sc_rsp; long rsp;};
+    union { long sc_ss; long ss;};
+    long	sc_len;        /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/fpu.h> for
+     *       the following fields.
+     */
+    long	sc_fpformat;
+    long	sc_ownedfp;
+    long	sc_fpstate[64] __attribute__((aligned(16)));
+    long	sc_spare[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp           sc_rsp          /* Stack pointer.  */
+#define sc_fp           sc_rbp          /* Frame pointer.  */
+#define sc_pc           sc_rip          /* Process counter.  */
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-cache.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-cache.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-machine.h
@@ -0,0 +1,133 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  FreeBSD/amd64 version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-machine.h>
+
+#undef RTLD_START
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+#define RTLD_START asm ("\n\
+.text\n\
+	.align 16\n\
+.globl _start\n\
+# we dont use it: .globl _dl_start_user\n\
+_start:\n\
+	# align stack.\n\
+	andq $-16, %rsp\n\
+	# save argument pointer.\n\
+	movq %rdi, %r13\n\
+	call _dl_start\n\
+# we dont use it: _dl_start_user:\n\
+	# Save the user entry point address in %r12.\n\
+	movq %rax, %r12\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	movl _dl_skip_args(%rip), %eax\n\
+	# get the original argument count.\n\
+	movq 0(%r13), %rdx\n\
+	# Adjust the pointer to skip _dl_skip_args words.\n\
+	leaq (%r13,%rax,8), %r13\n\
+	# Subtract _dl_skip_args from argc.\n\
+	subl %eax, %edx\n\
+	# Put argc on adjusted place\n\
+	movq %rdx, 0(%r13)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
+	# argc -> rsi\n\
+	movq %rdx, %rsi\n\
+	# _dl_loaded -> rdi\n\
+	movq _rtld_local(%rip), %rdi\n\
+	# env -> rcx\n\
+	leaq 16(%r13,%rdx,8), %rcx\n\
+	# argv -> rdx\n\
+	leaq 8(%r13), %rdx\n\
+	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
+	xorl %ebp, %ebp\n\
+	# Call the function to run the initializers.\n\
+	call _dl_init_internal@PLT\n\
+	# Pass our finalizer function to the user in %rdx, as per ELF ABI draft.\n\
+	leaq _dl_fini(%rip), %rdx\n\
+	# And make sure %rdi points to argc stored on the stack.\n\
+	movq %r13, %rdi\n\
+	# Pass finalizer function also in %rsi, as per C calling convention.\n\
+	movq %rdx, %rsi\n\
+	# Jump to the user's entry point.\n\
+	jmp *%r12\n\
+.previous\n\
+");
+
+#if 0
+Under FreeBSD:
+#define AT_EXECPATH     15      /* Path to the executable. */
+
+Under Linux:
+#define AT_PLATFORM     15      /* String identifying platform.  */
+
+Filled entries from kernel:
+
+        if (args->execfd != -1)
+                AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
+        AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);    
+        AUXARGS_ENTRY(pos, AT_PHENT, args->phent);  
+        AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);  
+        AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
+        AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
+        AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
+        AUXARGS_ENTRY(pos, AT_BASE, args->base);
+        if (imgp->execpathp != 0)
+                AUXARGS_ENTRY(pos, AT_EXECPATH, imgp->execpathp);
+        AUXARGS_ENTRY(pos, AT_NULL, 0);
+                                                                                                                
+#endif
+
+#undef  DL_PLATFORM_INIT
+#define DL_PLATFORM_INIT dl_platform_kfreebsd_x86_64_init ()
+
+#ifndef _DL_MACHINE_KFREEBSD
+#define _DL_MACHINE_KFREEBSD
+
+static inline void cpuid(long op, long *rax, long *rdx)
+{
+    __asm__(
+	"push %%rbx\n\t"
+	"cpuid\n\t"
+	"pop %%rbx\n\t"
+	: "=a" (*rax),
+	  "=d" (*rdx)
+	: "0" (op)
+	: "rcx"
+    );
+}
+
+static inline void __attribute__ ((unused))
+dl_platform_kfreebsd_x86_64_init (void)
+{
+	/* we don't have reasonable AT_PLATFORM from kernel
+	   use cpuid to guess AT_HWCAP */
+
+	long val, hwcap;
+
+	cpuid(1, &val, &hwcap);
+	GLRO(dl_hwcap) = hwcap;
+	GLRO(dl_platform) = ELF_MACHINE_NAME;
+}
+
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-procinfo.h>
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/elf/start.S
@@ -0,0 +1,143 @@
+/* Startup code for FreeBSD/amd64 ABI.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2001.
+   FreeBSD modification by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for a few.
+   Blindly applied on amd64:
+
+   %rdx		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   %rsp		The stack contains the arguments and environment:
+		0(%rsp)			argc
+		8(%rsp)			argv[0]
+		...
+		(8*argc)(%rsp)		NULL
+		(8*(argc+1))(%rsp)	envp[0]
+		...
+					NULL
+
+   But on amd64 %rsp also have to be 16-byte aligned,
+   standard C calling convention already passes arguments in registers.
+
+   FreeBSD uses %edi as pointer to arguments and environment, %rsp is passed aligned.
+   On entry from kernel, %rsp=%rdi or %rsp=%rdi-8,
+   on entry from ld.so, glibc might set up it slightly differently.
+
+   On FreeBSD, we use %rsi for passing function pointer to rtld_fini().
+   On entry from FreeBSD kernel, %rsi is cleared, %rdx is not cleared,
+   on entry from ld.so, glibc sets both %rsi and %rdx to point to rtld_fini().
+
+   Used interface (via %rdi, %rsi) is equal to standard C calling interface for
+
+   void _start(void *arg, void *rtld_fini());
+
+*/
+
+#include "bp-sym.h"
+
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	/* Clear the frame pointer.  The ABI suggests this be done, to mark
+	   the outermost frame obviously.  */
+	xorl %ebp, %ebp		/* zero extending clears whole rbp */
+
+	/* Extract the arguments as encoded on the stack and set up
+	   the arguments for __libc_start_main (int (*main) (int, char **, char **),
+		   int argc, char *argv,
+		   void (*init) (void), void (*fini) (void),
+		   void (*rtld_fini) (void), void *stack_end).
+	   The arguments are passed via registers and on the stack:
+	main:		%rdi
+	argc:		%rsi
+	argv:		%rdx
+	init:		%rcx
+	fini:		%r8
+	rtld_fini:	%r9
+	stack_end:	stack.	*/
+
+	movq %rsi, %r9		/* Address of the shared library termination
+				   function.  */
+	movq 0(%rdi), %rsi	/* argument count.  */
+	leaq 8(%rdi), %rdx      /* argv starts just at above argc.  */
+
+	/* Align the stack to a 16 byte boundary to follow the ABI.  */
+	andq  $~15, %rsp
+
+	pushq %rax		/* Push garbage because we push 8 more bytes.  */
+
+	/* Provide the highest stack address to the user code (for stacks
+	   which grow downwards).  */
+	pushq %rsp
+
+#ifdef SHARED
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq __libc_csu_fini@GOTPCREL(%rip), %r8
+	movq __libc_csu_init@GOTPCREL(%rip), %rcx
+
+	movq BP_SYM (main)@GOTPCREL(%rip), %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call BP_SYM (__libc_start_main)@PLT
+#else
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq $__libc_csu_fini, %r8
+	movq $__libc_csu_init, %rcx
+
+	movq $BP_SYM (main), %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call BP_SYM (__libc_start_main)
+#endif
+
+	hlt			/* Crash if somehow `exit' does return.	 */
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/get_clockfreq.c
@@ -0,0 +1 @@
+#include "../i386/get_clockfreq.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movq 0(%rsp), %rsi	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addq $8, %rsp		/* remove stale return address */
+        jmp  *%rsi
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ioperm.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+  args.length = num;
+  args.enable = turn_on;
+
+  return __sysarch (I386_SET_IOPERM, &args);
+}
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/iopl.c
@@ -0,0 +1 @@
+#include "../i386/iopl.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldconfig.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/lib/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/lib64/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
@@ -0,0 +1,3 @@
+/LD_TRACE_LOADED_OBJECTS=1/a\
+add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\)\(-kfreebsd-x86-64\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \2\4\5\6"_
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/Makefile
@@ -0,0 +1,4 @@
+ifeq ($(subdir),linuxthreads)
+CFLAGS-pt-initfini.s = -g0 -fPIC -fno-inline-functions \
+		       -fno-asynchronous-unwind-tables $(fno-unit-at-a-time)
+endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/asm/prctl.h
@@ -0,0 +1 @@
+/* placeholder to make linuxthreads/sysdeps/x86_64/pt-machine.h happy */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/pt-machine.h
@@ -0,0 +1,51 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   x86-64 FreeBSD version.
+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_PT_MACHINE_H
+#define _FREEBSD_PT_MACHINE_H   1
+
+/*
+  almost all parts are common with linux version
+ */
+
+#include <linuxthreads/sysdeps/x86_64/pt-machine.h>
+
+#ifndef __ASSEMBLER__
+
+/* and only one FreeBSD specifics */
+
+#include <sysarch.h>
+
+/* Initialize the thread-unique value. */
+
+#undef INIT_THREAD_SELF
+#define INIT_THREAD_SELF(descr, nr)             \
+{                                               \
+  long tmp;                                     \
+  tmp = (long) descr;                           \
+  if (sysarch(AMD64_SET_FSBASE, &tmp)  != 0)    \
+  {                                             \
+    abort();                                    \
+  }                                             \
+}
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* pt-machine.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/sysdep-cancel.h
@@ -0,0 +1,145 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include <pt-machine.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+/* Syscalls with more than 6 arguments are not supported here.  */
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    /* Save registers that might get destroyed.  */			      \
+    SAVESTK_##args							      \
+    PUSHARGS_##args							      \
+    CENABLE								      \
+    /* Restore registers.  */						      \
+    POPARGS_##args							      \
+    RESTSTK_##args							      \
+    /* The return value from CENABLE is argument for CDISABLE.  */	      \
+    movq %rax, (%rsp);							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    syscall;								      \
+    popq %rdi; cfi_adjust_cfa_offset(-8);				      \
+    pushfq; cfi_adjust_cfa_offset(8);					      \
+    /* Save %rax since it's the return/error code from the syscall.  */	      \
+    movq %rax, 8(%rsp);							      \
+    CDISABLE								      \
+    popfq; cfi_adjust_cfa_offset(-8);                                         \
+    /* fetch the error code from the syscall.  */              		      \
+    popq %rax; cfi_adjust_cfa_offset(-8);                                     \
+    /* adjust rsp, do not change flags	*/				      \
+    popq %rdx; cfi_adjust_cfa_offset(-8);                                     \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+# define PUSHARGS_0	/* Nothing.  */
+# define PUSHARGS_1	PUSHARGS_0 movq %rdi, 8(%rsp);
+# define PUSHARGS_2	PUSHARGS_1 movq %rsi, 16(%rsp);
+# define PUSHARGS_3	PUSHARGS_2 movq %rdx, 24(%rsp);
+# define PUSHARGS_4	PUSHARGS_3 movq %rcx, 32(%rsp);
+# define PUSHARGS_5	PUSHARGS_4 movq %r8, 40(%rsp);
+# define PUSHARGS_6	PUSHARGS_5 movq %r9, 48(%rsp);
+
+# define POPARGS_0	/* Nothing.  */
+# define POPARGS_1	POPARGS_0 movq 8(%rsp), %rdi;
+# define POPARGS_2	POPARGS_1 movq 16(%rsp), %rsi;
+# define POPARGS_3	POPARGS_2 movq 24(%rsp), %rdx;
+# define POPARGS_4	POPARGS_3 movq 32(%rsp), %r10;
+# define POPARGS_5	POPARGS_4 movq 40(%rsp), %r8;
+# define POPARGS_6	POPARGS_5 movq 48(%rsp), %r9;
+
+/* We always have to align the stack before calling a function.  */
+# define SAVESTK_0	subq $24, %rsp;cfi_adjust_cfa_offset(24);
+# define SAVESTK_1	SAVESTK_0
+# define SAVESTK_2	SAVESTK_1
+# define SAVESTK_3	subq $40, %rsp;cfi_adjust_cfa_offset(40);
+# define SAVESTK_4	SAVESTK_3
+# define SAVESTK_5	subq $56, %rsp;cfi_adjust_cfa_offset(56);
+# define SAVESTK_6	SAVESTK_5
+
+# define RESTSTK_0	/* Nothing.  */
+# define RESTSTK_1	RESTSTK_0
+# define RESTSTK_2	RESTSTK_1
+# define RESTSTK_3	addq $16, %rsp;cfi_adjust_cfa_offset(-16);
+# define RESTSTK_4	RESTSTK_3
+# define RESTSTK_5	addq $32, %rsp;cfi_adjust_cfa_offset(-32);
+# define RESTSTK_6	RESTSTK_5
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel;
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel;
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  define CENABLE	call __librt_enable_asynccancel@plt;
+#  define CDISABLE	call __librt_disable_asynccancel@plt;
+# endif
+
+# if defined IS_IN_libpthread || !defined NOT_IN_libc
+#  ifndef __ASSEMBLER__
+extern int __local_multiple_threads attribute_hidden;
+#   define SINGLE_THREAD_P \
+  __builtin_expect (__local_multiple_threads == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads(%rip)
+#  endif
+
+# else
+
+#  ifndef __ASSEMBLER__
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   p_header.data.multiple_threads) == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, %fs:MULTIPLE_THREADS_OFFSET
+#  endif
+
+# endif
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+                                     p_header.data.multiple_threads) == 0, 1)
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/tls.h
@@ -0,0 +1,62 @@
+/* Definitions for thread-local data handling.  linuxthreads/x86-64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <linuxthreads/sysdeps/x86_64/tls.h>
+
+#ifdef HAVE_TLS_SUPPORT
+
+# ifndef __ASSEMBLER__
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+
+# undef TLS_INIT_TP
+# define TLS_INIT_TP(descr, secondcall)					      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+    long int _result;							      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    asm volatile ("syscall"						      \
+		  : "=a" (_result)					      \
+		  : "0" ((unsigned long int) SYS_sysarch),		      \
+		    "D" ((unsigned long int) AMD64_SET_FSBASE),		      \
+		    "S" (&_descr)					      \
+		  : "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11");    \
+									      \
+    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
+  })
+
+
+# endif	/* HAVE_TLS_SUPPORT */
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/linuxthreads/vfork.S
@@ -0,0 +1,67 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef SHARED
+	cmpq	$0, __libc_pthread_functions(%rip)
+#else
+	.weak	pthread_create
+	movq	$pthread_create, %rax
+	testq	%rax, %rax
+#endif
+	jne	HIDDEN_JUMPTARGET (__fork)
+
+	/* Pop the return PC value into ESI.  */
+	popq	%rsi
+	cfi_adjust_cfa_offset(-8)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %rdx == 0, %rax == child pid.  */
+	/* In the child process, %rdx == 1, %rax == parent pid.  */
+
+	/* Change %rax to be 0 in the child process.  */
+	decq	%rdx
+	andq	%rdx, %rax
+
+	/* Jump to the return PC.  */
+	jmp	*%rsi
+
+L(error):
+	/* Push back the return PC.  */
+	pushq	%rsi
+	cfi_adjust_cfa_offset(8)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/makecontext.S
@@ -0,0 +1,146 @@
+/* makecontext() for FreeBSD/amd64.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <ucontext_i.h>
+
+/*
+   void makecontext(ucontext_t *ucp, void *func(), int argc, ...);
+
+
+   input parameters:
+
+   rdi		ucp
+   rsi		func
+   edx		argc
+   rcx		arg1	-> ucp.rdi
+   r8		arg2	-> ucp.rsi
+   r9		arg3	-> ucp.rdx
+    8(%rsp)	arg4	-> ucp.rcx
+   16(%rsp)	arg5	-> ucp.r8
+   24(%rsp)	arg6	-> ucp.r9
+   i*8+24(%rsp) arg(6+i)-> future stack
+
+*/
+
+ENTRY(__makecontext)
+
+	/* Compute the address of the stack.
+	   The information comes from us_stack element. */
+	movq	oSS_SP(%rdi), %rax
+	addq	oSS_SIZE(%rdi), %rax
+
+	/* Put start addr into ucp */
+	movq	%rsi, oRIP(%rdi)
+
+	/* properly align future stack */
+	andq $-16, %rax
+	subq   $8, %rax
+
+	/* Put the next context into preserved ucp.rbx
+	   (from the uc_link element).  */
+	movq	oLINK(%rdi), %rsi
+	movq	%rsi, oRBX(%rdi)
+
+	/* save future registers arguments */
+
+	orl %edx, %edx
+	jz L(param_done)
+
+	decl %edx
+	movq %rcx, oRDI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r8,  oRSI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r9,  oRDX(%rdi)
+	jz L(param_done)
+
+	movq 8(%rsp), %rsi
+	decl %edx
+	movq %rsi, oRCX(%rdi)
+	jz L(param_done)
+
+	movq 16(%rsp), %rcx
+	decl %edx
+	movq %rcx, oR8(%rdi)
+	jz L(param_done)
+
+	movq 24(%rsp), %rsi
+	decl %edx
+	movq %rsi, oR9(%rdi)
+	jz L(param_done)
+
+	/* we have to copy some arguments also on the future stack */
+	movl %edx, %ecx
+	negq %rdx
+	leaq -16(%rax,%rdx,8), %rax /* we a litle bit waste stack space */
+	orq  $8, %rax
+
+1:	movq 24(%rsp,%rcx,8), %rsi
+	movq %rsi,(%rax,%rcx,8)
+	loop 1b
+
+L(param_done):
+
+	/* Store the future stack pointer and chain helper code. */
+	leaq	L(exitcode)(%rip), %rdx
+	movq	%rax, oRSP(%rdi)
+	movq	%rdx, (%rax)
+
+	/* 'makecontext' returns no value.  */
+	ret
+
+/***************************************************************************/
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+
+L(exitcode):
+	/* we don't bother with extra arguments left on the stack
+		- more than 6 arguments is rare
+		- setcontext changes stacks immediately
+		- exit will call _exit in near future
+	*/
+
+	testq %rbx, %rbx	/* If it is zero exit.  */
+	jz 2f
+
+	movq %rbx, %rdi
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+2:	movq %rax, %rdi
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/pipe.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY (__pipe)
+	DO_CALL (pipe, 1)
+	jb SYSCALL_ERROR_LABEL
+        movl %eax, 0(%rdi)
+        movl %edx, 4(%rdi)
+        xorl %eax, %eax
+L(pseudo_end):
+	ret
+PSEUDO_END (__pipe)
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/readelflib.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1999 and
+		  Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+int process_elf32_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+int process_elf64_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+
+/* Returns 0 if everything is ok, != 0 in case of error.  */
+int
+process_elf_file (const char *file_name, const char *lib, int *flag,
+		  unsigned int *osversion, char **soname, void *file_contents,
+		  size_t file_length)
+{
+  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
+  int ret;
+
+  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
+    return process_elf32_file (file_name, lib, flag, osversion, soname,
+			       file_contents, file_length);
+  else
+    {
+      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* x86-64 64bit libraries are always LIBC6.  */
+      if (!ret)
+	*flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
+      return ret;
+    }
+}
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf32_file
+#define __ELF_NATIVE_CLASS 32
+#include "elf/readelflib.c"
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf64_file
+#define __ELF_NATIVE_CLASS 64
+#include "elf/readelflib.c"
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into RSI */
+	movq 0(%rsp), %rsi;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decq %rdx
+	andq %rdx, %rax
+
+	popq %rdx
+	cfi_adjust_cfa_offset(-8)
+
+	jmp  *%rsi
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_rip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_rbp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_rsp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/start_thread.S
@@ -0,0 +1,196 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Modification for amd64 contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+/*
+   The parameters are passed in registers:
+   rdi: flags for rfork
+   rsi: child_stack
+   rdx: func
+   rcx: arg
+*/
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+
+#define SIG_SETMASK	3
+
+/* There is a window of a few instructions, right after the rfork
+   system call, where the handling of a signal would write garbage
+   into the stack shared by the parent and the child (assuming
+   RFMEM is set in flags).  To solve this: 1. We block all signals
+   around the rfork system call and unblock them afterwards in
+   the parent and in the child (but only after changing the stack
+   pointer).  2. The child accesses only values passed in registers
+   and on its own stack.  This way, if the parent is scheduled to
+   run first, and handles a signal, it will not affect the child;
+   and if the child runs first, and handles a signal, it will use
+   the child's stack and not affect the parent.
+*/
+
+	.text
+ENTRY (__start_thread)
+
+        /* Insert the argument onto the new aligned stack.  */
+        andq	$-16,%rsi
+        subq    $16,%rsi
+        movq    %rcx,8(%rsi)
+
+        /* Save the function pointer.  It will be popped off in the child */
+        movq    %rdx,0(%rsi)
+
+	testq	$32, %rdi	/* flags & RFMEM */
+	jnz	L(complex)
+
+        /* Do the system call.  */
+	movl    $SYS_ify(rfork),%eax
+        /* End FDE now, because in the child the unwind info will be
+           wrong.  */
+        cfi_endproc;
+        syscall			/* rdi and rsi are extra preserved */
+
+        jb SYSCALL_ERROR_LABEL
+
+	testq   %rdx,%rdx	/*  0 for the parent and 1 for the child */
+	jz     L(pseudo_end)	/* just return in parent */
+
+L(thread_start):
+
+	/* set up stack */
+	movq	%rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+L(thread_start2):
+
+        /* Set up arguments for the function call.  */
+        popq    %rax            /* Function to call.  */
+        popq    %rdi            /* Argument.  */
+        call    *%rax
+
+        /* Call exit with return value from function call. */
+        movq    %rax, %rdi
+        call    HIDDEN_JUMPTARGET (_exit)
+
+
+/******************************************************************************************************
+ *
+ * and now the complex one ...
+ *
+ ******************************************************************************************************/
+
+L(complex):
+
+        subq    $32, %rsp
+
+        /* save arguments - flags and stack */
+        movq    %rdi,0(%rsp)
+        movq    %rsi,8(%rsp)
+
+        /* Block all signals.  */
+        orq     $-1, %rax
+        movq    %rax, 16(%rsp)
+        movq    %rax, 24(%rsp)
+
+        leaq    16(%rsp), %rsi
+        movl    $SIG_SETMASK, %edi
+        movq    %rsi,%rdx
+        DO_CALL (sigprocmask, 3)
+        jb      L(error)
+
+        /* restore arguments - flags and stack */
+        movq    0(%rsp),%rdi
+        movq    8(%rsp),%rsi
+
+        /* Copy mask info into the child's stack.  */
+
+        subq    $16,%rsi
+        movq    16(%rsp),%rcx
+        movq    24(%rsp),%rdx
+        movq    %rcx, 0(%rsi)
+        movq    %rdx, 8(%rsi)
+
+        /* Perform the rfork system call.  */
+        DO_CALL (rfork, 1)
+        jb      L(error_unmask)
+
+        /* %rdx is now 0 for the parent and 1 for the child.  */
+        testq   %rdx, %rdx
+        jnz     L(child)
+
+        /* Save the child pid, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movl    $SIG_SETMASK, %edi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        /* Return the child pid, saved on stack.  */
+        movq    0(%rsp), %rax
+        addq    $32, %rsp
+L(pseudo_end):
+        ret
+
+L(error_unmask):
+
+        /* Save the error code, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+        movq    0(%rsp), %rax
+
+L(error):
+        addq    $32, %rsp
+        jmp     SYSCALL_ERROR_LABEL
+
+L(child):/* Here we are in the child thread.  */
+
+        /* set up stack */
+        movq    %rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        addq    $16, %rsp
+        jmp     L(thread_start2)
+
+        cfi_startproc;
+
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/io.h
@@ -0,0 +1,184 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#ifdef _MACHINE_CPUFUNC_H_
+#error "This header must not be used in combination with <machine/cpufunc.h>."
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all kFreeBSD platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however. */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/perm.h
@@ -0,0 +1,36 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set port input/output permissions.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys_fork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+
+	decq	%rdx
+	andq	%rdx, %rax
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysarch.h
@@ -0,0 +1,72 @@
+/* Parameters for the architecture specific system call.  amd64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    I386_GET_LDT = 0,
+#define I386_GET_LDT I386_GET_LDT
+    I386_SET_LDT = 1,
+#define I386_SET_LDT I386_SET_LDT
+    I386_GET_IOPERM = 3,
+#define I386_GET_IOPERM I386_GET_IOPERM
+    I386_SET_IOPERM = 4,
+#define I386_SET_IOPERM I386_SET_IOPERM
+    I386_GET_FSBASE = 7,
+#define I386_GET_FSBASE I386_GET_FSBASE
+    I386_SET_FSBASE = 8,
+#define I386_SET_FSBASE I386_SET_FSBASE
+    I386_GET_GSBASE = 9,
+#define I386_GET_GSBASE I386_GET_GSBASE
+    I386_SET_GSBASE = 10,
+#define I386_SET_GSBASE I386_SET_GSBASE
+    AMD64_GET_FSBASE = 128,
+#define	AMD64_GET_FSBASE AMD64_GET_FSBASE
+    AMD64_SET_FSBASE = 129,
+#define	AMD64_SET_FSBASE AMD64_SET_FSBASE
+    AMD64_GET_GSBASE = 130,
+#define	AMD64_GET_GSBASE AMD64_GET_GSBASE
+    AMD64_SET_GSBASE = 131
+#define	AMD64_SET_GSBASE AMD64_SET_GSBASE
+  };
+
+/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
+struct i386_ioperm_args
+  {
+    unsigned int start;
+    unsigned int length;
+    int enable;
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/syscall.S
@@ -0,0 +1,31 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY (__syscall)
+	movq %rcx, %r10
+	movl $SYS_ify (syscall), %eax
+	syscall
+	jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/syscalls-internal.h
@@ -0,0 +1,78 @@
+/* generally used "internal syscalls"
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INTERNAL_SYSCALLS_H
+#define KFREEBSD_INTERNAL_SYSCALLS_H
+
+#include <sys/syscall.h>
+
+/* 
+   for now, we do not care whether syscall succeeded,
+   we do not have defined 
+   INTERNAL_SYSCALL_ERROR_P and INTERNAL_SYSCALL_ERRNO
+   we do not store errno at all
+   to be sure, we return void
+*/
+
+#undef INTERNAL_SYSCALL_DECL
+#undef INTERNAL_SYSCALL_NCS
+#undef INTERNAL_SYSCALL
+#undef INTERNAL_SYSCALL_ERROR_P
+#undef INTERNAL_SYSCALL_ERRNO
+
+#define INTERNAL_SYSCALL_DECL(err)		\
+  do { } while (0)
+
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_##name(name, err, nr, ##args)
+
+
+#define INTERNAL_SYSCALL_close(name, err, nr, fd) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int result;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1)				\
+	: "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_writev(name, err, nr, fd, iov, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (iov);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result),			\
+          "=d" (_trash)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1),				\
+	  "S" (_a2),				\
+	  "d" (_a3)				\
+          /*  beware rdx is not preserved after syscall */ \
+	: "memory", "cc", "cx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+#endif
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.S
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   each own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for Linux is almost identical to the canonical Unix
+   code, except that the error number in %rax is negated.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %rax.  */
+
+	.text
+ENTRY (__syscall_error)
+
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/x86_64/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.h
@@ -0,0 +1,233 @@
+/* Copyright (C) 2001,02,03,04 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KFREEBSD_X86_64_SYSDEP_H
+#define _KFREEBSD_X86_64_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/x86_64/sysdep.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+#include <tls.h>
+
+#ifdef IS_IN_rtld
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#elif RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  leaq rtld_errno(%rip), %rcx;			\
+  movl %eax, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#elif USE___THREAD
+# ifndef NOT_IN_libc
+#  define SYSCALL_ERROR_ERRNO __libc_errno
+# else
+#  define SYSCALL_ERROR_ERRNO errno
+# endif
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  movl %eax, %fs:(%rcx);			\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#elif defined _LIBC_REENTRANT
+/* Store (%eax) into errno through the GOT.
+   Note that errno occupies only 4 bytes.  */
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  pushq %rax;					\
+  cfi_adjust_cfa_offset(8);			\
+  PUSH_ERRNO_LOCATION_RETURN;			\
+  call BP_SYM (__errno_location)@PLT;		\
+  POP_ERRNO_LOCATION_RETURN;			\
+  popq %rdx;					\
+  cfi_adjust_cfa_offset(-8);			\
+  movl %edx, (%rax);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+#else /* Not _LIBC_REENTRANT.  */
+# define SYSCALL_ERROR_HANDLER			\
+0:movq errno@GOTPCREL(%RIP), %rcx;		\
+  movl %eax, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#endif	/* PIC */
+
+/* The FreeBSD/amd64 kernel expects the system call parameters in
+   registers according to the following table:
+
+    syscall number	rax
+    arg 1		rdi
+    arg 2		rsi
+    arg 3		rdx
+    arg 4		r10
+    arg 5		r8
+    arg 6		r9
+
+    The FreeBSD kernel internal syscall usage of registers:
+
+    preserved:
+	stack pointer			rsp
+	C preserved			rbx, rbp, r12-r15
+	some input params		rdi, rsi
+
+    destroyed:
+	return value(s)			rax, rdx, eflags
+	return address from syscall	rcx
+	eflags from syscall		r11
+	used internally			r8-r10
+
+    Normal function call, including calls to the system call stub
+    functions in the libc, get the first six parameters passed in
+    registers and the seventh parameter and later on the stack.  The
+    register use is as follows:
+
+     system call number	in the DO_CALL macro
+     arg 1		rdi
+     arg 2		rsi
+     arg 3		rdx
+     arg 4		rcx
+     arg 5		r8
+     arg 6		r9
+
+    We have to take care that the stack is aligned to 16 bytes.  When
+    called the stack is not aligned since the return address has just
+    been pushed.
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)		\
+    DOARGS_##args				\
+    movl $SYS_ify (syscall_name), %eax;		\
+    syscall;
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 movq %rcx, %r10;
+#define DOARGS_5 DOARGS_4
+#define DOARGS_6 DOARGS_5
+#define DOARGS_7 DOARGS_6
+#define DOARGS_8 DOARGS_7
+
+#else   /* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if defined NOT_IN_libc && defined IS_IN_rtld
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  */
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq __pointer_chk_guard_local(%rip), reg;    \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq __pointer_chk_guard_local(%rip), reg
+# else
+#  define PTR_MANGLE(reg)	asm ("xorq __pointer_chk_guard_local(%%rip), %0\n" \
+				     "rolq $17, %0"			      \
+				     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	asm ("rorq $17, %0\n"			      \
+				     "xorq __pointer_chk_guard_local(%%rip), %0" \
+				     : "=r" (reg) : "0" (reg))
+# endif
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq %fs:POINTER_GUARD, reg;		      \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq %fs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorq %%fs:%c2, %0\n"		      \
+				     "rolq $17, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorq $17, %0\n"			      \
+				     "xorq %%fs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _KFREEBSD_X86_64_SYSDEP_H  */
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets  needed in the makecontext() function implementation.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure. */
+
+#define oRDI		24
+#define oRSI		32
+#define oRDX		40
+#define oRCX		48
+#define oR8		56
+#define oR9		64
+
+#define oRAX		72
+#define oRBX		80
+#define oRBP		88
+
+#define oRIP		176
+#define oRSP		200
+
+#define oLINK		816
+#define oSS_SP		824
+#define oSS_SIZE	832
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/vfork.S
@@ -0,0 +1,58 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into ESI.  */
+	popq	%rsi
+	cfi_adjust_cfa_offset(-8)
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %rdx == 0, %rax == child pid.  */
+	/* In the child process, %rdx == 1, %rax == parent pid.  */
+
+	/* Change %rax to be 0 in the child process.  */
+	decq	%rdx
+	andq	%rdx, %rax
+
+	/* Jump to the return PC.  */
+	jmp	*%rsi
+
+L(error):
+	/* Push back the return PC.  */
+	pushq	%rsi
+	cfi_adjust_cfa_offset(8)
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c
@@ -0,0 +1,48 @@
+/* xmknod call using old-style Unix mknod and mkfifo system calls.
+   Copyright (C) 1991, 1993, 1995-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+extern int __syscall_mknod (const char *, mode_t, dev_t);
+extern int __mkfifo (const char *, mode_t);
+
+/* Create a device file named PATH, with permission and special bits MODE
+   and device number DEV (which can be constructed from major and minor
+   device numbers with the `makedev' macro above).  */
+int
+__xmknod (int vers, const char *path, mode_t mode, dev_t *dev)
+{
+  if (vers != _MKNOD_VER)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
+     must use the mkfifo() system call for this purpose.  */
+  if (S_ISFIFO (mode))
+    return __mkfifo (path, mode & ~S_IFMT);
+
+  return __syscall_mknod (path, mode, *dev);
+}
+libc_hidden_def (__xmknod)
+
+weak_alias (__xmknod, _xmknod)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknodat.c
@@ -0,0 +1,145 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_mknodat (int fd, const char *path,
+			      mode_t mode, dev_t dev);
+libc_hidden_proto (__syscall_mknodat)
+
+extern int __syscall_mkfifoat (int fd, const char *path,
+			       mode_t mode);
+libc_hidden_proto (__syscall_mkfifoat)
+
+/* Create a device file named PATH relative to FD, with permission and
+   special bits MODE and device number DEV (which can be constructed
+   from major and minor device numbers with the `makedev' macro above).  */
+int
+__xmknodat (int vers, int fd, const char *file, mode_t mode, dev_t * dev)
+{
+  if (vers != _MKNOD_VER)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+# ifndef __ASSUME_ATFCTS
+  if (__have_atfcts >= 0)
+# endif
+    {
+      int result;
+
+      /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
+         must use the mkfifo() system call for this purpose.  */
+      if (S_ISFIFO (mode))
+	result = INLINE_SYSCALL (mkfifoat, 3, fd, file, mode);
+      else
+	result = INLINE_SYSCALL (mknodat, 4, fd, file, mode, *dev);
+
+# ifndef __ASSUME_ATFCTS
+      if (result == -1 && errno == ENOSYS)
+	__have_atfcts = -1;
+      else
+# endif
+	return result;
+    }
+
+#ifndef __ASSUME_ATFCTS
+  if (fd != AT_FDCWD && file[0] != '/')
+    {
+      int mib[4];
+      size_t kf_len = 0;
+      char *kf_buf, *kf_bufp;
+      size_t filelen;
+
+      if (fd < 0)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+
+      filelen = strlen (file);
+      if (__builtin_expect (filelen == 0, 0))
+	{
+	  __set_errno (ENOENT);
+	  return -1;
+	}
+
+      mib[0] = CTL_KERN;
+      mib[1] = KERN_PROC;
+      mib[2] = KERN_PROC_FILEDESC;
+      mib[3] = __getpid ();
+
+      if (__sysctl (mib, 4, NULL, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_buf = alloca (kf_len + filelen);
+      if (__sysctl (mib, 4, kf_buf, &kf_len, NULL, 0) != 0)
+	{
+	  __set_errno (ENOSYS);
+	  return -1;
+	}
+
+      kf_bufp = kf_buf;
+      while (kf_bufp < kf_buf + kf_len)
+	{
+	  struct kinfo_file *kf = (struct kinfo_file *) (uintptr_t) kf_bufp;
+
+	  if (kf->kf_fd == fd)
+	    {
+	      if (kf->kf_type != KF_TYPE_VNODE ||
+		  kf->kf_vnode_type != KF_VTYPE_VDIR)
+		{
+		  __set_errno (ENOTDIR);
+		  return -1;
+		}
+
+	      strcat (kf->kf_path, "/");
+	      strcat (kf->kf_path, file);
+	      file = kf->kf_path;
+	      break;
+	    }
+	  kf_bufp += kf->kf_structsize;
+	}
+
+      if (kf_bufp >= kf_buf + kf_len)
+	{
+	  __set_errno (EBADF);
+	  return -1;
+	}
+    }
+
+  return __xmknod (vers, file, mode, dev);
+#endif
+}
+
+libc_hidden_def (__xmknodat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c
@@ -0,0 +1,49 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__xstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_stat (CHECK_STRING (file),
+			   CHECK_1 ((struct stat16 *) buf));
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat)
+
+weak_alias (__xstat, _xstat)
--- /dev/null
+++ b/ports/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c
@@ -0,0 +1,44 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <bp-checks.h>
+
+#include "stat16conv.c"
+
+int
+__xstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (CHECK_STRING (file), __ptrvalue (&buf16));
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat64)
