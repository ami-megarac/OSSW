diff --exclude=CVS -upNr ports/ChangeLog.m32r ports/ChangeLog.m32r
--- ports/ChangeLog.m32r	1970-01-01 09:00:00.000000000 +0900
+++ ports/ChangeLog.m32r	2006-05-09 10:23:08.000000000 +0900
@@ -0,0 +1,297 @@
+2006-06-07  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* sysdeps/unix/sysv/linux/m32r/configure: Removed
+	  libc_cv_gcc_unwind_find=yes, because we provide _Unwind_Find_FDE 
+	  from libgcc.
+	* sysdeps/unix/sysv/linux/m32r/configure: Ditto.
+
+2006-04-24  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* sysdeps/m32r/setjmp.h : Avoid stdlib/isomac.out Error.
+
+2006-04-06  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h :
+	Changed for IS_IN_librt case. Gather a common SYSCALL_ERROR_HANDLER
+	code.
+
+2006-03-24  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h :
+        Recoverd the code before 2006-03-02.
+
+2006-03-22  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* Rebuild by gcc-3.4.3-13.0.3.
+	* sysdeps/m32r/strlen.S (strlen): Disable pre-read codes. 
+	* sysdeps/unix/sysv/linux/m32r/mmap.S (strlen): Set an Error Code
+	when using an illegal offset value.
+
+2006-03-02  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+	* sysdeps/unix/sysv/linux/m32r/clone.S (__clone): Changes for 
+	the new system call calling convention of the kernel.
+	Marged calling SYSCALL_ERROR_HANDLER.
+	* sysdeps/unix/sysv/linux/m32r/sysdep.h : Use @GOT, @PLT, @GOTOFF.
+	Add "|| nop" after trap. Marged calling SYSCALL_ERROR_HANDLER.
+	* sysdeps/unix/sysv/linux/m32r/brk.c (__brk): Ditto.
+	* sysdeps/unix/sysv/linux/m32r/flushcache.S (__brk): Ditto.
+	* sysdeps/unix/sysv/linux/m32r/sigaction.c : Ditto.
+	* sysdeps/unix/m32r/sysdep.S : Ditto.
+	* sysdeps/m32r/bsd-_setjmp.S (_setjmp): Ditto.
+	* sysdeps/m32r/bsd-setjmp.S (setjmp): Ditto.
+	* sysdeps/m32r/setjmp.S (__sigsetjmp): Ditto.
+	* sysdeps/m32r/dl-machine.h : Ditto.
+	* sysdeps/m32r/m32r-mcount.S (_mcount): Ditto.
+	* sysdeps/m32r/sysdep.h : Ditto.
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h :
+	Use @GOT, @PLT, @GOTOFF. Fixed typo. Changed for IS_IN_librt case.
+	Removed UNDOCARGS2_*. Removed UNDOCARGS_5 DOCARGS_5 verbose saving.
+	sigaction.cv
+
+2006-03-01  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/bits/fcntl.h
+	[__USE_GNU] (F_SETLEASE. F_GETLEASE, F_NOTIFY): New macros.
+	[__USE_GNU] (LOCK_MAND, LOCK_READ, LOCK_WRITE, LOCK_RW): New macros.
+	[__USE_GNU] (DN_ACCESS, DN_MODIFY, DN_CREATE, DN_DELETE, DN_RENAME,
+	DN_ATTRIB, DN_MULTISHOT): New macros.
+
+2006-01-26  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/brk.c (__brk): Fixed conflist r0 on
+	asm().
+
+2006-01-18  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/m32r/sysdep.S: Changed to avoid redefined 
+	error of symbol `__syscall_error_1'.
+
+2005-11-22  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/dl-machine.h (elf_machine_rela): Support 
+	R_M32R_10_PCREL_RELA.
+	Remove a code to use relocation field at R_M32R_26_PCREL_RELA
+	and R_M32R_18_PCREL_RELA. The field must be 0 with RELA.
+
+2005-11-18  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/bits/setjmp.h (_JMPBUF_UNWINDS): Remove unnecessary &.
+	Make sure only setjmp.h or pthread.h are allow to include
+	bits/setjmp.h.
+
+2005-10-21  Hirokazu Takata <takata@linux-m32r.org>
+
+	* sysdeps/m32r/memset.S: Update for m32r2.
+
+2005-10-20  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/elf/start.S: Support Update PIE.
+
+2005-10-19  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/socket.S: Remove weak_alias
+	to create listen if NO_WEAK_ALIAS is defined.
+
+2005-10-14  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/gccframe.h: New file for dwarf2-unwind.
+	* sysdeps/unix/sysv/linux/m32r/configure: Support dwarf2-unwind.
+
+2005-07-15
+
+	* sysdeps/m32r/dl-machine.h: Support R_M32R_REL32.
+	It's important to change with elf/elf.h.
+
+2005-03-03  Hirokazu Takata <takata@linux-m32r.org>
+
+	* sysdeps/unix/sysv/linux/m32r/kernel-features.h: Removed
+	__ASSUME_VFORK_SYSCALL.
+
+2005-02-22  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S: Changed for
+	__ASSUME_VFORK_SYSCALL.
+	* sysdeps/unix/sysv/linux/m32r/vfork.S: Ditto.
+
+2005-02-15  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/socket.S: Added .fillinsn.
+
+2005-02-10  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S: Changed to
+	reference pthread_create.
+
+2005-02-04  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h:
+	Support thread cancel.
+	* sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/clone.S: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/socket.S: Ditto.
+
+2005-01-31  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/socket.S: Removed # in macro body.
+	* sysdeps/unix/sysv/linux/Makefile: Removed gnulib, gnulib-static.
+	* sysdeps/unix/sysv/linux/sigaction.c: Changed <kernel-features.h>
+	to "kernel-features.h"
+
+2004-12-20  NIIBE Yutaka <gniibe@fsij.org>
+
+	* sysdeps/unix/sysv/linux/m32r/kernel-features.h: Port for
+	kernel-2.6.9.
+	* sysdeps/unix/sysv/linux/m32r/getgid.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/sigaction.c: Ditto.
+	* glibc-20041101/sysdeps/unix/sysv/linux/i386/fcntl.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/chown.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/getresgid.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/getresuid.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/getrlimit.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/getrlimit64.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/lchown.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/msgctl.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/semctl.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/setfsgid.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/setfsuid.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/setrlimit.c: Ditto.
+	* sysdeps/unix/sysv/linux/m32r/shmctl.c: Ditto.
+	* 
+
+2004-10-26  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* ChangeLog.m32r: Fix typo in comment.
+	* sysdeps/m32r/preconfigure: Removed.
+	* sysdeps/m32r/configure.in: New file.
+	* sysdeps/m32r/configure: New generated file.
+	* sysdeps/m32r/linuxthreads/pspinlock.c (__pthread_spin_lock):
+	Changed INLINE_SYSCALL to INTERNAL_SYSCALL.
+	(__pthread_spin_trylock): Ditto.
+	* sysdeps/unix/sysv/linux/m32r/Versions: Removed GLIBC_2.2
+	versioning, Added GLIBC_2.3 versioning.
+
+2004-10-25  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	Moved from separate m32r-linuxthreads into m32r/linuxthreads
+	subdirs:
+	2004-09-09  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>
+	* sysdeps/m32r/pspinlock.c: New file.
+	* sysdeps/m32r/pt-machine.h: New file
+	* sysdeps/m32r/preconfigure: Renamed from configure.
+	* sysdeps/m32r/shlib-versions: Moved from top level..
+	* sysdeps/unix/sysv/linux/m32r/Makefile: Add static-gnulilb
+	environment value difinition.
+
+2004-10-19  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* m32r/configure: Changed into the simple rule.
+
+2004-10-08  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/unix/sysv/linux/m32r/mmap.S (__mmap): Use sys_mmap2.
+
+2004-10-05  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/dl-machine.h (elf_machine_rela_relative): Replace
+	static inline by auto inline, add always_inline attribute.
+	(elf_machine_rela): Likewise.
+	(elf_machine_lazy_rel): Likewise.
+	(elf_machine_runtime_setup): add always_inline attribute.
+	* sysdeps/unix/sysv/linux/m32r/bits/mman.h: Define PROT_GROWSDOWN
+	and PROT_GROWSUP.
+	* sysdeps/unix/sysv/linux/m32r/sysdep.h (SYSCALL_ERROR_HANDLER):
+	Define RTLD_PRIVATE_ERRNO variant.  include <dl-sysdep.h>.
+
+2004-09-14  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* configure: check for assembler line separator
+
+2004-09-09  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* configure, Makefile: Do nothing
+	* shlib-versions: New file.
+	* sysdeps/unix/m32r/sysdep.h: Use relative pathnames.
+	* sysdeps/unix/sysv/linux/m32r/sysdep.h: Use relative
+	pathnames.
+	* sysdeps/unix/sysv/linux/m32r/sysdep.S: Use relative
+	pathnames.
+	* sysdeps/m32r/init-first.c: Remove file
+
+2004-09-09  Kazuhiro Inaoka <inaoka.kazuhiro@renesas.com>
+
+	* sysdeps/m32r/Implies: New file
+	* sysdeps/m32r/Makefile: New file
+	* sysdeps/m32r/__longjmp.S: New file
+	* sysdeps/m32r/bits/endian.h: New file
+	* sysdeps/m32r/bits/huge_val.h: New file
+	* sysdeps/m32r/bits/setjmp.h: New file
+	* sysdeps/m32r/bsd-_setjmp.S: New file
+	* sysdeps/m32r/bsd-setjmp.S: New file
+	* sysdeps/m32r/dl-machine.h: New file
+	* sysdeps/m32r/elf/start.S: New file
+	* sysdeps/m32r/gmp-mparam.h: New file
+	* sysdeps/m32r/init-first.c: New file
+	* sysdeps/m32r/m32r-mcount.S: New file
+	* sysdeps/m32r/machine-gmon.h: New file
+	* sysdeps/m32r/memcpy.S: New file
+	* sysdeps/m32r/memset.S: New file
+	* sysdeps/m32r/memusage.h: New file
+	* sysdeps/m32r/setjmp.S: New file
+	* sysdeps/m32r/stackinfo.h: New file
+	* sysdeps/m32r/strlen.S: New file
+	* sysdeps/m32r/sys/ucontext.h: New file
+	* sysdeps/m32r/sysdep.h: New file
+	* sysdeps/unix/m32r/Makefile: New file
+	* sysdeps/unix/m32r/sysdep.S: New file
+	* sysdeps/unix/m32r/sysdep.h: New file
+	* sysdeps/unix/sysv/linux/m32r/Dist: New file
+	* sysdeps/unix/sysv/linux/m32r/Makefile: New file
+	* sysdeps/unix/sysv/linux/m32r/Versions: New file
+	* sysdeps/unix/sysv/linux/m32r/bits/fcntl.h: New file
+	* sysdeps/unix/sysv/linux/m32r/bits/mman.h: New file
+	* sysdeps/unix/sysv/linux/m32r/bits/resource.h: New file
+	* sysdeps/unix/sysv/linux/m32r/brk.c: New file
+	* sysdeps/unix/sysv/linux/m32r/chown.c: New file
+	* sysdeps/unix/sysv/linux/m32r/clone.S: New file
+	* sysdeps/unix/sysv/linux/m32r/fchown.c: New file
+	* sysdeps/unix/sysv/linux/m32r/fcntl.c: New file
+	* sysdeps/unix/sysv/linux/m32r/flushcache.S: New file
+	* sysdeps/unix/sysv/linux/m32r/fxstat.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getegid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/geteuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getgroups.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getresgid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getresuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getrlimit.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getrlimit64.c: New file
+	* sysdeps/unix/sysv/linux/m32r/getuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/lchown.c: New file
+	* sysdeps/unix/sysv/linux/m32r/lockf64.c: New file
+	* sysdeps/unix/sysv/linux/m32r/lxstat.c: New file
+	* sysdeps/unix/sysv/linux/m32r/m32r-stub.c: New file
+	* sysdeps/unix/sysv/linux/m32r/mmap.S: New file
+	* sysdeps/unix/sysv/linux/m32r/msgctl.c: New file
+	* sysdeps/unix/sysv/linux/m32r/pipe.S: New file
+	* sysdeps/unix/sysv/linux/m32r/profil-counter.h: New file
+	* sysdeps/unix/sysv/linux/m32r/semctl.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setegid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/seteuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setfsgid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setfsuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setgid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setgroups.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setregid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setresgid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setresuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setreuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setrlimit.c: New file
+	* sysdeps/unix/sysv/linux/m32r/setuid.c: New file
+	* sysdeps/unix/sysv/linux/m32r/shmctl.c: New file
+	* sysdeps/unix/sysv/linux/m32r/sigcontextinfo.h: New file
+	* sysdeps/unix/sysv/linux/m32r/socket.S: New file
+	* sysdeps/unix/sysv/linux/m32r/sys/cachectl.h: New file
+	* sysdeps/unix/sysv/linux/m32r/sys/io.h: New file
+	* sysdeps/unix/sysv/linux/m32r/sys/tas.h: New file
+	* sysdeps/unix/sysv/linux/m32r/sys/ucontext.h: New file
+	* sysdeps/unix/sysv/linux/m32r/sys/user.h: New file
+	* sysdeps/unix/sysv/linux/m32r/syscall.S: New file
+	* sysdeps/unix/sysv/linux/m32r/syscalls.list: New file
+	* sysdeps/unix/sysv/linux/m32r/sysdep.S: New file
+	* sysdeps/unix/sysv/linux/m32r/sysdep.h: New file
+	* sysdeps/unix/sysv/linux/m32r/vfork.S: New file
+	* sysdeps/unix/sysv/linux/m32r/xstat.c: New file
diff --exclude=CVS -upNr ports/sysdeps/m32r/Implies ports/sysdeps/m32r/Implies
--- ports/sysdeps/m32r/Implies	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/Implies	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,3 @@
+wordsize-32
+ieee754/flt-32
+ieee754/dbl-64
diff --exclude=CVS -upNr ports/sysdeps/m32r/Makefile ports/sysdeps/m32r/Makefile
--- ports/sysdeps/m32r/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/Makefile	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,7 @@
+# m32r/ELF specific definitions.
+
+# The assembler on m32r needs the -fPIC flag even when it's assembler code.
+#ASFLAGS-.os = -fPIC
+ifeq ($(subdir),gmon)
+sysdep_routines += m32r-mcount
+endif
diff --exclude=CVS -upNr ports/sysdeps/m32r/__longjmp.S ports/sysdeps/m32r/__longjmp.S
--- ports/sysdeps/m32r/__longjmp.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/__longjmp.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,43 @@
+/* longjmp for M32R.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+/* __longjmp(jmpbuf, val) */
+
+ENTRY (__longjmp)
+	ld	r8, @r0+
+	ld	r9, @r0+
+	ld	r10, @r0+
+	ld	r11, @r0+
+	ld	r12, @r0+
+	ld	r13, @r0+
+	ld	r2, @r0+	/* lr */
+	ld	r15, @r0	/* sp */
+
+	mv	r0,r1
+	bnez	r0, 1f		/* get the return value in place */
+	ldi	r0, #1		/* can't let setjmp() return zero! */
+	.fillinsn
+1:
+	jmp	r2
+END (__longjmp)
diff --exclude=CVS -upNr ports/sysdeps/m32r/bits/endian.h ports/sysdeps/m32r/bits/endian.h
--- ports/sysdeps/m32r/bits/endian.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/bits/endian.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,13 @@
+/* M32R is bi-endian. */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __LITTLE_ENDIAN__
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __FLOAT_WORD_ORDER __LITTLE_ENDIAN
+#else
+#define __BYTE_ORDER __BIG_ENDIAN
+#define __FLOAT_WORD_ORDER __BIG_ENDIAN
+#endif
diff --exclude=CVS -upNr ports/sysdeps/m32r/bits/huge_val.h ports/sysdeps/m32r/bits/huge_val.h
--- ports/sysdeps/m32r/bits/huge_val.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/bits/huge_val.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,56 @@
+/* `HUGE_VAL' constants for IEEE 754 machines (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   M32R version.
+   Copyright (C) 1992, 95, 96, 97, 98, 99, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_val.h> directly; include <math.h> instead."
+#endif
+
+/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VAL	(__builtin_huge_val())
+#elif __GNUC_PREREQ(2,96)
+# define HUGE_VAL	(__extension__ 0x1.0p2047)
+#elif defined __GNUC__
+
+#  define HUGE_VAL \
+  (__extension__							      \
+   ((union { unsigned __l __attribute__((__mode__(__DI__))); double __d; })   \
+    { __l: 0x000000007ff00000ULL }).__d)
+
+#else /* not GCC */
+
+# include <endian.h>
+
+typedef union { unsigned char __c[8]; double __d; } __huge_val_t;
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __HUGE_VAL_bytes	{ 0, 0, 0, 0, 0x7f, 0xf0, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __HUGE_VAL_bytes	{ 0, 0, 0xf0, 0x7f, 0, 0, 0, 0 }
+# endif
+
+static __huge_val_t __huge_val = { __HUGE_VAL_bytes };
+# define HUGE_VAL	(__huge_val.__d)
+
+#endif	/* GCC.  */
diff --exclude=CVS -upNr ports/sysdeps/m32r/bits/setjmp.h ports/sysdeps/m32r/bits/setjmp.h
--- ports/sysdeps/m32r/bits/setjmp.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/bits/setjmp.h	2006-05-09 10:22:45.000000000 +0900
@@ -0,0 +1,57 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Define the machine-dependent type `jmp_buf'.  M32R version. */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+typedef struct
+  {
+    /* Callee-saved registers r8 through r15.  */
+    int __regs[8];
+
+    /* Program counter.  */
+    void * __pc;
+  } __jmp_buf[1];
+#endif
+
+#if defined __USE_MISC || defined _ASM
+#define JB_R8  0
+#define JB_R9  1
+#define JB_R10 2
+#define JB_R11 3
+#define JB_R12 4
+#define JB_FP  5
+#define JB_LR  6
+#define JB_SP  7
+#define JB_PC  8
+
+#define JB_SIZE		(4 * 9)
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (jmpbuf)[0].__regs[JB_SP])
+
+#endif  /* bits/setjmp.h */
diff --exclude=CVS -upNr ports/sysdeps/m32r/bsd-_setjmp.S ports/sysdeps/m32r/bsd-_setjmp.S
--- ports/sysdeps/m32r/bsd-_setjmp.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/bsd-_setjmp.S	2006-03-02 11:15:18.000000000 +0900
@@ -0,0 +1,43 @@
+/* BSD `_setjmp' entry point to `sigsetjmp (..., 0)'.  M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This just does a tail-call to `__sigsetjmp (ARG, 0)'.
+   We cannot do it in C because it must be a tail-call, so frame-unwinding
+   in setjmp doesn't clobber the state restored by longjmp.  */
+
+#include <sysdep.h>
+
+ENTRY (_setjmp)
+#ifdef SHARED
+	mv	r2,lr
+	bl.s	.+4
+	ld24	r1,#_GLOBAL_OFFSET_TABLE_
+	add	r1,lr
+	mv	lr,r2
+
+	ld24	r2,C_SYMBOL_NAME(__sigsetjmp@GOT)
+	add	r2,r1
+	ld	r2,@r2
+#else
+	LDIMM   (r2, C_SYMBOL_NAME(__sigsetjmp))
+#endif
+	ldi     r1, #0		/* Pass a second argument of zero.  */
+	jmp     r2
+END (_setjmp)
+libc_hidden_def(_setjmp)
diff --exclude=CVS -upNr ports/sysdeps/m32r/bsd-setjmp.S ports/sysdeps/m32r/bsd-setjmp.S
--- ports/sysdeps/m32r/bsd-setjmp.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/bsd-setjmp.S	2006-03-02 11:15:35.000000000 +0900
@@ -0,0 +1,42 @@
+/* BSD `setjmp' entry point to `sigsetjmp (..., 1)'.  M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This just does a tail-call to `__sigsetjmp (ARG, 1)'.
+   We cannot do it in C because it must be a tail-call, so frame-unwinding
+   in setjmp doesn't clobber the state restored by longjmp.  */
+
+#include <sysdep.h>
+
+ENTRY (setjmp)
+#ifdef SHARED
+	mv	r2,lr
+	bl.s	.+4
+	ld24	r1,#_GLOBAL_OFFSET_TABLE_
+	add	r1,lr
+	mv	lr,r2
+
+	ld24	r2,C_SYMBOL_NAME(__sigsetjmp@GOT)
+	add	r2,r1
+	ld	r2,@r2
+#else
+	LDIMM	(r2, C_SYMBOL_NAME(__sigsetjmp))
+#endif
+	ldi	r1, #1		/* Pass a second argument of one.  */
+	jmp	r2
+END (setjmp)
diff --exclude=CVS -upNr ports/sysdeps/m32r/configure ports/sysdeps/m32r/configure
--- ports/sysdeps/m32r/configure	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/configure	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,7 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+
+libc_cv_asm_line_sep='!'
+cat >>confdefs.h <<_ACEOF
+#define ASM_LINE_SEP $libc_cv_asm_line_sep
+_ACEOF
+
diff --exclude=CVS -upNr ports/sysdeps/m32r/configure.in ports/sysdeps/m32r/configure.in
--- ports/sysdeps/m32r/configure.in	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/configure.in	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,5 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+
+dnl M32R uses `;' to start comments and `!' for line separator.
+libc_cv_asm_line_sep='!'
+AC_DEFINE_UNQUOTED(ASM_LINE_SEP, $libc_cv_asm_line_sep)
diff --exclude=CVS -upNr ports/sysdeps/m32r/dl-machine.h ports/sysdeps/m32r/dl-machine.h
--- ports/sysdeps/m32r/dl-machine.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/dl-machine.h	2006-03-02 11:28:06.000000000 +0900
@@ -0,0 +1,814 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.	*/
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+/* Only dummy. This doesn't work. */
+
+#define ELF_MACHINE_NAME "M32R"
+
+#include <sys/param.h>
+
+#include <assert.h>
+
+/* Define the M32R_OLD_ABI, if you want to keep compatibility with
+  an old Renesas relocs */
+#ifdef M32R_OLD_ABI
+#define R_M32R_16_SAMPLE                1
+#define R_M32R_32_SAMPLE                2
+#define R_M32R_24_SAMPLE                3
+#define R_M32R_10_PCREL_SAMPLE          4
+#define R_M32R_18_PCREL_SAMPLE          5
+#define R_M32R_26_PCREL_SAMPLE          6
+#define R_M32R_HI16_ULO_SAMPLE          7
+#define R_M32R_HI16_SLO_SAMPLE          8
+#define R_M32R_LO16_SAMPLE              9
+#define R_M32R_SDA16_SAMPLE             10
+
+#define R_M32R_GOT24_SAMPLE             11 /* conflict */
+#define R_M32R_26_PLTREL_SAMPLE         12 /* conflict */
+#define R_M32R_GOT16_HI_ULO_SAMPLE      13
+#define R_M32R_GOT16_HI_SLO_SAMPLE      14
+#define R_M32R_GOT16_LO_SAMPLE          15
+#define R_M32R_GOTPC24_SAMPLE           16
+#define R_M32R_COPY_SAMPLE              17
+#define R_M32R_GLOB_DAT_SAMPLE          18
+#define R_M32R_JMP_SLOT_SAMPLE          19
+#define R_M32R_RELATIVE_SAMPLE          20
+#define R_M32R_GNU_VTINHERIT_SAMPLE     21
+#define R_M32R_GNU_VTENTRY_SAMPLE       22
+#endif /* M32R_OLD_ABI */
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute__ ((unused))
+elf_machine_matches_host (const Elf32_Ehdr *ehdr)
+{
+  return (ehdr->e_machine == EM_M32R);
+}
+
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline Elf32_Addr __attribute__ ((unused))
+elf_machine_dynamic (void)
+{
+  register Elf32_Addr *got;
+  asm ("   bl.s .+4\n"
+       "   ld24 %0,#_GLOBAL_OFFSET_TABLE_\n"
+       "   add %0,lr" :"=r" (got) : : "lr" );
+  return *got;
+}
+
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr __attribute__ ((unused))
+elf_machine_load_address (void)
+{
+  Elf32_Addr addr;
+  asm ("	ld24 r0,#here\n\t"
+       "	add r0,r12\n\t"
+       "	ld r0,@r0\n\t"
+       "here: \n\t"
+       "	ld24 r1,#_GLOBAL_OFFSET_TABLE_\n\t"
+       "	mv r2,r12\n\t"
+       "	sub r2,r1\n\t"
+       "	sub r2,r0\n\t"
+       "	mv %0,r2"
+       : "=r" (addr) : : "r0", "r1", "r2" );
+  return addr;
+}
+
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int __attribute__ ((unused, always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  Elf32_Addr *got;
+  extern void _dl_runtime_resolve (Elf32_Word);
+  extern void _dl_runtime_profile (Elf32_Word);
+
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      /* The GOT entries for functions in the PLT have not yet been filled
+	 in.  Their initial contents will arrange when called to load an
+	 offset into the .rela.plt section and _GLOBAL_OFFSET_TABLE_[1],
+	 and then jump to _GLOBAL_OFFSET_TABLE[2].  */
+      got = (Elf32_Addr *) D_PTR (l, l_info[DT_PLTGOT]);
+      got[1] = (Elf32_Addr) l;	/* Identify this shared object.	 */
+
+      /* The got[2] entry contains the address of a function which gets
+	 called to get the address of a so far unresolved function and
+	 jump to it.  The profiling extension of the dynamic linker allows
+	 to intercept the calls to collect information.	 In this case we
+	 don't store the address in the GOT so that all future calls also
+	 end in this function.	*/
+      if (profile)
+	{
+	  got[2] = (Elf32_Addr) &_dl_runtime_profile;
+	  /* Say that we really want profiling and the timers are started.  */
+	  GL(dl_profile_map) = l;
+	}
+      else
+	/* This function will get called to fix up the GOT entry indicated by
+	   the offset on the stack, and then jump to the resolved address.  */
+	got[2] = (Elf32_Addr) &_dl_runtime_resolve;
+    }
+  return lazy;
+}
+
+/* This code is used in dl-runtime.c to call the `fixup' function
+   and then redirect to the address it returns.	 */
+
+#define ELF_MACHINE_RUNTIME_FIXUP_ARGS int plt_type
+
+#ifdef SHARED
+#define FUN_ADDR( func )	"\n\
+	bl.s .+4                           \n\
+	ld24 r12,#_GLOBAL_OFFSET_TABLE_    \n\
+	add r12,lr                         \n\
+	ld24 r4,#" #func "@GOT             \n\
+	add r4,r12                         \n\
+	ld r4,@r4"
+#else
+#define FUN_ADDR( func )	"\
+	seth r4,#high( " #func " ) \n\
+	or3 r4,r4,#low( " #func " )"
+#endif
+
+#define FGR_SAVE	""
+#define FGR_LOAD	""
+
+#ifdef M32R_OLD_NEWABI
+#define LOAD_ARGS_FROM_STACK( name ) "\n\
+	mv r7,lr                                \n\
+	; OLD_PLT to keep compatible mode only  \n\
+        bl.s .+4                                \n\
+        .fillinsn                               \n\
+	addi lr,# " #name " -.                  \n\
+	beq r6,lr,1f                            \n\
+	; OLT_PLT ABI                           \n\
+	pop r4     ; link map address           \n\
+	pop r5     ; reloc offset               \n\
+	.fillinsn                               \n\
+1:                                              \n\
+	mv lr,r7"
+#else
+#define LOAD_ARGS_FROM_STACK( name ) "\n\
+	; DELETE FOR NEW ABI pop r4 ; link map address \n\
+	; DELETE FOR NEW ABI pop r5 ; reloc offset\n"
+#endif
+
+#ifndef PROF
+# define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\
+	.text                                 \n\
+	.globl _dl_runtime_resolve            \n\
+	.type _dl_runtime_resolve, @function  \n\
+                                              \n\
+	.balign 4                             \n\
+_dl_runtime_resolve:                          \n\
+        " LOAD_ARGS_FROM_STACK( _dl_runtime_resolve ) "      \n\
+	push r0                               \n\
+	push r1                               \n\
+	push r2                               \n\
+	push r3                               \n\
+	push r12                              \n\
+	" FGR_SAVE "                          \n\
+	push lr                               \n\
+                                              \n\
+	; fixup( ELF_MACHINE_RUNTIME_TRAMPOLINE, link_map, reloc_offset ) \n\
+	;mv r0,***   ; plt_type (dummy)       \n\
+                                              \n\
+	mv r1,r4     ; link map address       \n\
+	mv r2,r5     ; reloc offset           \n\
+                                              \n\
+	" FUN_ADDR( fixup ) "                 \n\
+                                              \n\
+	jl r4			; Call resolver. \n\
+	mv r4,r0 ; value                      \n\
+                                              \n\
+	pop lr			; Get register content back. \n\
+	" FGR_LOAD "                          \n\
+	pop r12                               \n\
+	pop r3                                \n\
+	pop r2                                \n\
+	pop r1                                \n\
+	pop r0                                \n\
+                                              \n\
+	jmp r4			; Jump to function address. \n\
+                                              \n\
+	.balign 4                             \n\
+	.size _dl_runtime_resolve, .-_dl_runtime_resolve  \n\
+                                              \n\
+	.globl _dl_runtime_profile            \n\
+	.type _dl_runtime_profile, @function  \n\
+                                              \n\
+	.balign 4                             \n\
+_dl_runtime_profile:                          \n\
+        " LOAD_ARGS_FROM_STACK( _dl_runtime_profile ) "      \n\
+	push r0                               \n\
+	push r1                               \n\
+	push r2                               \n\
+	push r3                               \n\
+	push r12                              \n\
+	" FGR_SAVE "                          \n\
+	push lr                               \n\
+                                              \n\
+	; profile_fixup( ELF_MACHINE_RUNTIME_TRAMPOLINE, link_map, reloc_offset ) \n\
+	;mv r0,***   ; plt_type (dummy)       \n\
+	mv r1,r4     ; link map address       \n\
+	mv r2,r5     ; reloc offset           \n\
+                                              \n\
+	" FUN_ADDR( profile_fixup ) "         \n\
+                                              \n\
+	jl r4			; Call resolver. \n\
+	mv r4,r0 ; value                      \n\
+                                              \n\
+	pop lr			; Get register content back. \n\
+	" FGR_LOAD "                          \n\
+	pop r12                               \n\
+	pop r3                                \n\
+	pop r2                                \n\
+	pop r1                                \n\
+	pop r0                                \n\
+                                              \n\
+	jmp r4			; Jump to function address. \n\
+                                              \n\
+	.balign 4                             \n\
+	.size _dl_runtime_profile, .-_dl_runtime_profile \n\
+	.previous                             \n\
+");
+#else
+# define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\
+	.text                                 \n\
+	.globl _dl_runtime_resolve            \n\
+	.globl _dl_runtime_profile            \n\
+	.type _dl_runtime_resolve, @function  \n\
+	.type _dl_runtime_profile, @function  \n\
+                                              \n\
+	.balign 4                             \n\
+_dl_runtime_resolve:                          \n\
+_dl_runtime_profile:                          \n\
+        " LOAD_ARGS_FROM_STACK( _dl_runtime_resolve ) "      \n\
+	push r0                               \n\
+	push r1                               \n\
+	push r2                               \n\
+	push r3                               \n\
+	push r12                              \n\
+	" FGR_SAVE "                          \n\
+	push lr                               \n\
+                                              \n\
+	; fixup( ELF_MACHINE_RUNTIME_TRAMPOLINE, link_map, reloc_offset ) \n\
+	;mv r0,***   ; plt_type (dummy)       \n\
+	mv r1,r4     ; link map address       \n\
+	mv r2,r5     ; reloc offset           \n\
+                                              \n\
+	" FUN_ADDR( fixup ) "                 \n\
+                                              \n\
+	jl r4			; Call resolver. \n\
+	mv r4,r0 ; value                      \n\
+                                              \n\
+	pop lr			; Get register content back. \n\
+	" FGR_LOAD "                          \n\
+	pop r12                               \n\
+	pop r3                                \n\
+	pop r2                                \n\
+	pop r1                                \n\
+	pop r0                                \n\
+                                              \n\
+	jmp r4			; Jump to function address. \n\
+                                              \n\
+	.balign 4                             \n\
+	.size _dl_runtime_resolve, .-_dl_runtime_resolve \n\
+	.size _dl_runtime_profile, .-_dl_runtime_profile \n\
+	.previous                             \n\
+");
+#endif
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK	0x80000000UL
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.	*/
+
+#define RTLD_START asm ("\
+.text\n\
+.globl _start\n\
+.globl _dl_start_user\n\
+_start:\n\
+	mv r0,r15\n\
+	bl _dl_start\n\
+_dl_start_user:\n\
+	; Save the user entry point address in r8.\n\
+	mv r8,r0\n\
+	; Point r12 at the GOT.\n\
+	bl.s .+4\n\
+	ld24 r12,#_GLOBAL_OFFSET_TABLE_\n\
+	add r12,lr\n\
+	; Store the highest stack address\n\
+	ld24 r0,#__libc_stack_end@GOT		; __libc_stack_end@GOT \n\
+	add r0,r12\n\
+	ld r0,@r0\n\
+	st r15,@r0\n\
+	; See if we were run as a command with the executable file\n\
+	; name as an extra leading argument.\n\
+	ld24 r0,#_dl_skip_args@GOT			; _dl_skip_args@GOT \n\
+	add r0,r12\n\
+	ld r0,@r0\n\
+	ld r0,@r0\n\
+	; Get the original argument count.\n\
+	ld r1,@r15\n\
+	; Subtract _dl_skip_args from it.\n\
+	sub r1,r0\n\
+	; Adjust the stack pointer to skip _dl_skip_args words.\n\
+	slli r0,#2\n\
+	add r15,r0\n\
+	; Store back the modified argument count.\n\
+	st r1,@r15\n\
+	; Compute argv address and envp.\n\
+	mv r2,r15\n\
+	addi r2,#4\n\
+	mv r3,r1\n\
+	addi r3,#1\n\
+	slli r3,#2\n\
+	add r3,r2\n\
+	ld24 r0,#_rtld_local@GOT\n\
+	add r0,r12\n\
+	ld r0,@r0\n\
+	ld r0,@r0\n\
+	; Call _dl_init.\n\
+	bl _dl_init@PLT				; _dl_init@PLT \n\
+	.fillinsn\n\
+1:	; Pass our finalizer function to the user in r4, as per ELF ABI.\n\
+	ld24 r0,#_dl_fini@GOT			; _dl_fini@GOT \n\
+	add r0,r12\n\
+	ld r0,@r0\n\
+	; Jump to the user's entry point.\n\
+	jmp r8\n\
+.previous\n\
+");
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry, so
+   PLT entries should not be allowed to define the value.
+   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc.  */
+#ifdef M32R_OLD_ABI
+/* for oldtype relocation compatibility */
+#define elf_machine_type_class(type) \
+  ((((type) == R_M32R_JMP_SLOT || (type) == R_M32R_JMP_SLOT_SAMPLE) * ELF_RTYPE_CLASS_PLT)   \
+   | (((type) == R_M32R_COPY || (type) == R_M32R_COPY_SAMPLE) * ELF_RTYPE_CLASS_COPY))
+#else
+#define elf_machine_type_class(type) \
+  ((((type) == R_M32R_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)   \
+   | (((type) == R_M32R_COPY) * ELF_RTYPE_CLASS_COPY))
+#endif
+	
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#ifdef M32R_OLD_ABI
+/* for oldtype relocation compatibility */
+#define ELF_MACHINE_JMP_SLOT	\
+	R_M32R_JMP_SLOT || ELFW(R_TYPE)(reloc->r_info) == R_M32R_JMP_SLOT_SAMPLE
+#else
+#define ELF_MACHINE_JMP_SLOT	R_M32R_JMP_SLOT
+#endif
+
+/* M32R never uses Elf32_Rel relocations.	 */
+#define ELF_MACHINE_NO_REL 1
+
+/* We define an initialization functions.  This is called very early in
+   _dl_sysdep_start.  */
+#define DL_PLATFORM_INIT dl_platform_init ()
+
+static inline void __attribute__ ((unused))
+dl_platform_init (void)
+{
+  if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
+    /* Avoid an empty string which would disturb us.  */
+    GLRO(dl_platform) = NULL;
+}
+
+static inline Elf32_Addr
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+		       const Elf32_Rela *reloc,
+		       Elf32_Addr *reloc_addr, Elf32_Addr value)
+{
+  return *reloc_addr = value;
+}
+
+/* Return the final value of a plt relocation.	*/
+static inline Elf32_Addr
+elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
+		       Elf32_Addr value)
+{
+  return value + reloc->r_addend;
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE
+
+extern char **_dl_argv;
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute ((always_inline))
+elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
+		 const Elf32_Sym *sym, const struct r_found_version *version,
+		 void *const reloc_addr_arg)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
+  Elf32_Addr value;
+
+#define COPY_UNALIGNED_WORD(swp, twp, align) \
+  { \
+    void *__s = (swp), *__t = (twp); \
+    unsigned char *__s1 = __s, *__t1 = __t; \
+    unsigned short *__s2 = __s, *__t2 = __t; \
+    unsigned long *__s4 = __s, *__t4 = __t; \
+    switch ((align)) \
+    { \
+    case 0: \
+      *__t4 = *__s4; \
+      break; \
+    case 2: \
+      *__t2++ = *__s2++; \
+      *__t2 = *__s2; \
+      break; \
+    default: \
+      *__t1++ = *__s1++; \
+      *__t1++ = *__s1++; \
+      *__t1++ = *__s1++; \
+      *__t1 = *__s1; \
+      break; \
+    } \
+  }
+#define COPY_UNALIGNED_HWORD(swp, twp, align) \
+  { \
+    void *__s = (swp), *__t = (twp); \
+    unsigned char *__s1 = __s, *__t1 = __t; \
+    unsigned short *__s2 = __s, *__t2 = __t; \
+    switch ((align)) \
+    { \
+    case 0: \
+      *__t2 = *__s2; \
+      break; \
+    default: \
+      *__t1++ = *__s1++; \
+      *__t1 = *__s1; \
+      break; \
+    } \
+  }
+
+#ifdef M32R_OLD_ABI
+/* for oldtype relocation compatibility */
+  if (__builtin_expect (r_type == R_M32R_RELATIVE || r_type == R_M32R_RELATIVE_SAMPLE, 0))
+#else
+  if (__builtin_expect (r_type == R_M32R_RELATIVE, 0))
+#endif
+    {
+#ifndef RTLD_BOOTSTRAP
+      if (map != &GL(dl_rtld_map)) /* Already done in rtld itself.	 */
+#endif
+	{
+	  if (reloc->r_addend)
+	    value = map->l_addr + reloc->r_addend;
+	  else
+	    {
+	      COPY_UNALIGNED_WORD (reloc_addr_arg, &value,
+                                   (int) reloc_addr_arg & 3);
+	      value += map->l_addr;
+	    }
+	  COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                               (int) reloc_addr_arg & 3);
+	}
+    }
+#ifndef RTLD_BOOTSTRAP
+  else if (__builtin_expect (r_type == R_M32R_NONE, 0))
+    return;
+#endif
+  else
+    {
+      const Elf32_Sym *const refsym = sym;
+#ifndef RTLD_BOOTSTRAP
+      Elf32_Addr tmp_value;
+#endif
+      value = RESOLVE (&sym, version, r_type);
+      if (sym)
+	value += sym->st_value;
+      value += reloc->r_addend;
+
+      switch (r_type)
+	{
+#ifdef M32R_OLD_ABI
+	case R_M32R_COPY_SAMPLE:
+#endif
+	case R_M32R_COPY:
+	  if (sym == NULL)
+	    /* This can happen in trace mode if an object could not be
+	       found.  */
+	    break;
+          if (sym->st_size > refsym->st_size
+	      || (sym->st_size < refsym->st_size && GLRO(dl_verbose)))
+	    {
+	      const char *strtab;
+
+	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
+	      _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				_dl_argv[0] ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	    }
+	  memcpy (reloc_addr, (void *) value, MIN (sym->st_size,
+						   refsym->st_size));
+	  break;
+#ifdef M32R_OLD_ABI
+	case R_M32R_GLOB_DAT_SAMPLE:
+#endif
+	case R_M32R_GLOB_DAT:
+#if 0 /* 20021129 1 -> 0 */
+	case R_M32R_32:
+	  *reloc_addr = value;
+	  break;
+#endif /* 20021129 1 -> 0 */
+#ifdef M32R_OLD_ABI
+	case R_M32R_JMP_SLOT_SAMPLE:
+#endif
+	case R_M32R_JMP_SLOT:
+	  elf_machine_fixup_plt(map, 0, reloc, reloc_addr, value);
+	  break;
+#if 1 /* 20021129 0 -> 1 */
+#ifdef M32R_OLD_ABI
+	case R_M32R_32_SAMPLE:
+#endif
+	case R_M32R_32_RELA:
+#ifndef RTLD_BOOTSTRAP
+#ifdef M32R_OLD_ABI
+	case R_M32R_24_SAMPLE:
+	case R_M32R_16_SAMPLE:
+	case R_M32R_HI16_ULO_SAMPLE:
+	case R_M32R_HI16_SLO_SAMPLE:
+	case R_M32R_LO16_SAMPLE:
+	case R_M32R_SDA16_SAMPLE:
+#endif
+	case R_M32R_24_RELA:
+	case R_M32R_16_RELA:
+	case R_M32R_HI16_ULO_RELA:
+	case R_M32R_HI16_SLO_RELA:
+	case R_M32R_LO16_RELA:
+	case R_M32R_SDA16_RELA:
+#endif
+	case R_M32R_REL32:
+	  {
+#ifndef RTLD_BOOTSTRAP
+	   /* This is defined in rtld.c, but nowhere in the static
+	      libc.a; make the reference weak so static programs can
+	      still link.  This declaration cannot be done when
+	      compiling rtld.c (i.e. #ifdef RTLD_BOOTSTRAP) because
+	      rtld.c contains the common defn for _dl_rtld_map, which
+	      is incompatible with a weak decl in the same file.  */
+# ifndef SHARED
+	    weak_extern (GL(dl_rtld_map));
+# endif
+	    if (map == &GL(dl_rtld_map))
+	      /* Undo the relocation done here during bootstrapping.
+		 Now we will relocate it anew, possibly using a
+		 binding found in the user program or a loaded library
+		 rather than the dynamic linker's built-in definitions
+		 used while loading those libraries.  */
+	      value -= map->l_addr + refsym->st_value + reloc->r_addend;
+#endif
+#ifdef M32R_OLD_ABI
+	    if (r_type == R_M32R_32_SAMPLE
+	        || r_type == R_M32R_32_RELA)
+#else
+	    if (r_type == R_M32R_32_RELA)
+#endif
+	      {
+	         COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                                      (int) reloc_addr_arg & 3);
+	      }
+#ifndef RTLD_BOOTSTRAP
+#ifdef M32R_OLD_ABI
+	    else if (r_type == R_M32R_16_SAMPLE
+	             || r_type == R_M32R_16_RELA)
+#else
+	    else if (r_type == R_M32R_16_RELA)
+#endif
+	      {
+	         COPY_UNALIGNED_HWORD (&value, reloc_addr_arg,
+                                       (int) reloc_addr_arg & 3);
+	      }
+	    else if (r_type == R_M32R_REL32)
+	      {
+                 value = (value - (Elf32_Addr) reloc_addr);
+	         COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                                       (int) reloc_addr_arg & 3);
+	      }
+	    else 
+	      {
+	         COPY_UNALIGNED_WORD (reloc_addr_arg, &tmp_value,
+                                      (int) reloc_addr_arg & 3);
+	         switch (r_type)
+	           {
+#ifdef M32R_OLD_ABI
+	           case R_M32R_24_SAMPLE:
+	             if (value & 0xff000000)
+	               {
+	                  _dl_signal_error (0, map->l_name, NULL,
+	                                    "R_M32R_24 relocation overflow");
+	               }
+	             value = (tmp_value & ~0xffffff) | (value & 0xffffff);
+	             break;
+#endif
+	           case R_M32R_24_RELA:
+	             if (value & 0xff000000)
+	               {
+	                  _dl_signal_error (0, map->l_name, NULL,
+	                                    "R_M32R_24_RELA relocation overflow");
+	               }
+	             value = (tmp_value & ~0xffffff) | (value & 0xffffff);
+	             break;
+#ifdef M32R_OLD_ABI
+	           case R_M32R_HI16_ULO_SAMPLE:
+#endif
+	           case R_M32R_HI16_ULO_RELA:
+	             value = (tmp_value & ~0xffff) | ((value >>16) & 0xffff);
+	             break;
+#ifdef M32R_OLD_ABI
+	           case R_M32R_HI16_SLO_SAMPLE:
+#endif
+	           case R_M32R_HI16_SLO_RELA:
+	             if (value & 0x8000)
+	               value += 0x10000;
+	             value = (tmp_value & ~0xffff) | ((value >>16) & 0xffff);
+	             break;
+#ifdef M32R_OLD_ABI
+	           case R_M32R_LO16_SAMPLE:
+	           case R_M32R_SDA16_SAMPLE:
+#endif
+	           case R_M32R_LO16_RELA:
+	           case R_M32R_SDA16_RELA:
+	             value = (tmp_value & ~0xffff) | (value & 0xffff);
+	             break;
+	           }
+	         COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                                      (int) reloc_addr_arg & 3);
+	      }
+#endif
+	    break;
+	  }
+#ifndef RTLD_BOOTSTRAP
+#ifdef M32R_OLD_ABI
+	case R_M32R_26_PCREL_SAMPLE:
+	  COPY_UNALIGNED_WORD (reloc_addr_arg, &tmp_value,
+                               (int) reloc_addr_arg & 3);
+	  value += (signed long)(((tmp_value & 0xffffff) ^ 0x800000) - 0x800000) << 2;
+	  value = value - (Elf32_Addr) reloc_addr;
+	  if ((signed long)value < -0x2000000 || 0x1fffffc < (signed long)value)
+	    {
+	      _dl_signal_error (0, map->l_name, NULL,
+	                        "R_M32R_26_PCREL relocation overflow");
+	    }
+	  value = (tmp_value & ~0xffffff) | ((value >> 2) & 0xffffff);
+	  COPY_UNALIGNED_WORD (&value, reloc_addr_arg,                                                         (int) reloc_addr_arg & 3);
+	  break;
+#endif
+	case R_M32R_26_PCREL_RELA:
+	  COPY_UNALIGNED_WORD (reloc_addr_arg, &tmp_value,
+                               (int) reloc_addr_arg & 3);
+	  value = value - (Elf32_Addr) reloc_addr;
+	  if ((signed long)value < -0x2000000 || 0x1fffffc < (signed long)value)
+	    {
+	      _dl_signal_error (0, map->l_name, NULL,
+	                        "R_M32R_26_PCREL_RELA relocation overflow");
+	    }
+	  value = (tmp_value & ~0xffffff) | ((value >> 2) & 0xffffff);
+	  COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                               (int) reloc_addr_arg & 3);
+	  break;
+#ifdef M32R_OLD_ABI
+	case R_M32R_18_PCREL_SAMPLE:
+	  COPY_UNALIGNED_WORD (reloc_addr_arg, &tmp_value,
+                               (int) reloc_addr_arg & 3);
+	  value += (signed long)((tmp_value & 0xffff) ^ 0x8000) - 0x8000) << 2;
+	  value = value - (Elf32_Addr) reloc_addr;
+	  if ((signed long)value < -0x20000 || 0x1fffc < (signed long)value)
+	    {
+	      _dl_signal_error (0, map->l_name, NULL,
+	                        "R_M32R_18_PCREL relocation overflow");
+	    }
+	  value = (tmp_value & ~0xffff) | ((value >> 2) & 0xffff);
+	  COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                               (int) reloc_addr_arg & 3);
+	  break;
+#endif
+	case R_M32R_18_PCREL_RELA:
+	  COPY_UNALIGNED_WORD (reloc_addr_arg, &tmp_value,
+                               (int) reloc_addr_arg & 3);
+	  value = value - (Elf32_Addr) reloc_addr;
+	  if ((signed long)value < -0x20000 || 0x1fffc < (signed long)value)
+	    {
+	      _dl_signal_error (0, map->l_name, NULL,
+	                        "R_M32R_18_PCREL_RELA relocation overflow");
+	    }
+	  value = (tmp_value & ~0xffff) | ((value >> 2) & 0xffff);
+	  COPY_UNALIGNED_WORD (&value, reloc_addr_arg,
+                               (int) reloc_addr_arg & 3);
+	  break;
+#endif
+#ifdef M32R_OLD_ABI
+	case R_M32R_10_PCREL_SAMPLE:
+#else
+	case R_M32R_10_PCREL_RELA:
+#endif
+	  {
+            unsigned short tmp_hvalue;
+	    COPY_UNALIGNED_HWORD (reloc_addr_arg, &tmp_hvalue,
+                                  (int) reloc_addr_arg & 3);
+	    value = value - (Elf32_Addr) reloc_addr;
+	    if ((signed long)value < -0x200 || 0x1fc < (signed long)value)
+	      {
+#ifdef M32R_OLD_ABI
+	        _dl_signal_error (0, map->l_name, NULL,
+	                          "R_M32R_10_PCREL relocation overflow");
+#else
+	        _dl_signal_error (0, map->l_name, NULL,
+	                          "R_M32R_10_PCREL_RELA relocation overflow");
+#endif
+	      }
+	    tmp_hvalue = (tmp_hvalue & ~0xff) | ((value >> 2) & 0xff);
+	    COPY_UNALIGNED_HWORD (&tmp_hvalue, reloc_addr_arg,
+                                  (int) reloc_addr_arg & 3);
+	    break;
+	  }
+#endif /* 20021129 0 -> 1 */
+	default:
+	  _dl_reloc_bad_type (map, r_type, 0);
+	  break;
+	}
+    }
+}
+
+auto inline void
+__attribute ((always_inline))
+elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
+                           void *const reloc_addr_arg)
+{
+  Elf32_Addr value;
+
+  if (reloc->r_addend)
+    value = l_addr + reloc->r_addend;
+  else
+    {
+      COPY_UNALIGNED_WORD (reloc_addr_arg, &value, (int) reloc_addr_arg & 3);
+      value += l_addr;
+    }
+  COPY_UNALIGNED_WORD (&value, reloc_addr_arg, (int) reloc_addr_arg & 3);
+
+#undef COPY_UNALIGNED_WORD
+#undef COPY_UNALIGNED_HWORD
+}
+
+auto inline void
+__attribute ((always_inline))
+elf_machine_lazy_rel (struct link_map *map,
+		      Elf32_Addr l_addr, const Elf32_Rela *reloc)
+{
+  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  /* Check for unexpected PLT reloc type.  */
+#ifdef M32R_OLD_ABI
+  if (ELF32_R_TYPE (reloc->r_info) == R_M32R_JMP_SLOT
+      || ELF32_R_TYPE (reloc->r_info) == R_M32R_JMP_SLOT_SAMPLE)
+#else
+  if (ELF32_R_TYPE (reloc->r_info) == R_M32R_JMP_SLOT)
+#endif
+      *reloc_addr += l_addr;
+  else 
+      _dl_reloc_bad_type (map, ELF32_R_TYPE (reloc->r_info), 1);
+}
+
+#endif /* RESOLVE */
diff --exclude=CVS -upNr ports/sysdeps/m32r/elf/start.S ports/sysdeps/m32r/elf/start.S
--- ports/sysdeps/m32r/elf/start.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/elf/start.S	2006-03-02 11:31:52.000000000 +0900
@@ -0,0 +1,109 @@
+/* Startup code for M32R & ELF.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.
+
+	Note that the code in the .init section has already been run.
+	This includes _init and _libc_init
+
+
+	At this entry point, most registers' values are unspecified, except:
+
+   r0		Contains a function pointer to be registered with `atexit'.
+   		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp		The stack contains the arguments and environment:
+   		@(0,sp)			argc
+		@(4,sp)			argv[0]
+		...
+		@((4*argc),sp)		NULL
+		@((4*(argc+1)),sp)	envp[0]
+		...
+					NULL
+*/
+
+#include "sysdep.h"
+#include "bp-sym.h"
+
+	.text
+	.globl _start
+_start:
+	/* Clear the frame pointer since this is the outermost frame.  */
+	ldi	r13, #0
+#ifdef SHARED
+	bl.s	.+4
+	ld24    r12, #_GLOBAL_OFFSET_TABLE_
+	add     r12, lr
+#endif
+
+	/* Pop argc off the stack and save a pointer to argv */
+	pop	r1
+	mv	r2, sp
+
+	/* Push the last arguments to main() onto the stack */
+	push	r0
+#ifdef SHARED
+	ld24	r0, #__libc_csu_fini@GOT
+	add	r0,r12
+	ld	r0,@r0
+#else
+	LDIMM	(r0, __libc_csu_fini)
+#endif
+	push	r0
+
+	/* Set up the other arguments for main() that go in registers */
+#ifdef SHARED
+	ld24	r0,#BP_SYM (main@GOT)
+	add	r0,r12
+	ld	r0,@r0
+	ld24	r3, #__libc_csu_init@GOT
+	add	r3,r12
+	ld	r3,@r3
+#else
+	LDIMM	(r0, BP_SYM (main))
+	LDIMM	(r3, __libc_csu_init)
+#endif
+
+	/* __libc_start_main (main, argc, argv, init, fini, rtld_fini) */
+
+	/* Let the libc call main and exit with its return code.  */
+#ifdef SHARED
+	bl	BP_SYM (__libc_start_main@PLT)
+#else
+	LDIMM	(r4, BP_SYM (__libc_start_main))
+	jl	r4
+#endif
+	/* should never get here....*/
+#ifdef SHARED
+	bl	abort@PLT
+#else
+	LDIMM	(r4, abort)
+	jl	r4
+#endif
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
diff --exclude=CVS -upNr ports/sysdeps/m32r/gccframe.h ports/sysdeps/m32r/gccframe.h
--- ports/sysdeps/m32r/gccframe.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/gccframe.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  m32r version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define DWARF_FRAME_REGISTERS 20
+
+#include <sysdeps/generic/gccframe.h>
diff --exclude=CVS -upNr ports/sysdeps/m32r/gmp-mparam.h ports/sysdeps/m32r/gmp-mparam.h
--- ports/sysdeps/m32r/gmp-mparam.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/gmp-mparam.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,30 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Library General Public License as published by
+the Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
+License for more details.
+
+You should have received a copy of the GNU Library General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+MA 02111-1307, USA. */
+
+#define BITS_PER_MP_LIMB 32
+#define BYTES_PER_MP_LIMB 4
+#define BITS_PER_LONGINT 32
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
+
+#define IEEE_DOUBLE_BIG_ENDIAN 0
+#define IEEE_DOUBLE_MIXED_ENDIAN 1
diff --exclude=CVS -upNr ports/sysdeps/m32r/linuxthreads/pspinlock.c ports/sysdeps/m32r/linuxthreads/pspinlock.c
--- ports/sysdeps/m32r/linuxthreads/pspinlock.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/linuxthreads/pspinlock.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,70 @@
+/* POSIX spinlock implementation.  M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include "internals.h"
+
+int
+__pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  while (INTERNAL_SYSCALL (tas, , 1, lock));
+  return 0;
+}
+weak_alias (__pthread_spin_lock, pthread_spin_lock)
+
+
+int
+__pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  unsigned int val;
+
+  if ((val = *lock) == 0)
+    val = INTERNAL_SYSCALL (tas, , 1, lock);
+  return (val > 0 ? EBUSY : 0);
+}
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
+
+
+int
+__pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  return *lock = 0;
+}
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
+
+
+int
+__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
+     all processes which can access the memory location `lock' points
+     to can use the spinlock.  */
+  return *lock = 0;
+}
+weak_alias (__pthread_spin_init, pthread_spin_init)
+
+
+int
+__pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+  /* Nothing to do.  */
+  return 0;
+}
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --exclude=CVS -upNr ports/sysdeps/m32r/linuxthreads/pt-machine.h ports/sysdeps/m32r/linuxthreads/pt-machine.h
--- ports/sysdeps/m32r/linuxthreads/pt-machine.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/linuxthreads/pt-machine.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,55 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+                                                                                
+#include <errno.h>
+#include <sysdep.h>
+
+#ifndef __ASSEMBLER__
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  int ret;
+
+  ret = INLINE_SYSCALL (tas, 1, spinlock);
+  return ret;
+}
+
+#define lock_held(p) *(p)
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("r15");
+
+#endif /* __ASSEMBLER__ */
+                                                                                
+#endif /* pt-machine.h */
+
diff --exclude=CVS -upNr ports/sysdeps/m32r/m32r-mcount.S ports/sysdeps/m32r/m32r-mcount.S
--- ports/sysdeps/m32r/m32r-mcount.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/m32r-mcount.S	2006-03-02 11:17:40.000000000 +0900
@@ -0,0 +1,67 @@
+/* m32r-specific implemetation of profiling support.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+	ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(_mcount)
+	ASM_TYPE_DIRECTIVE(C_SYMBOL_NAME(_mcount), function)
+	.balign 4
+C_LABEL(_mcount)
+	/* Save the caller-clobbered registers.  */
+	push r0
+	push r1
+	push r2
+	push r3
+	push r4
+	push r5
+	push r6
+	push r7
+	push lr
+	ld r0,@(36,sp)
+	mv r1,lr
+
+#ifdef __PIC__
+	push r12
+	bl.s .+4
+	ld24 r12,#_GLOBAL_OFFSET_TABLE_
+	add r12,lr
+	ld24 lr,#__mcount_internal@GOT
+	add lr,r12
+	ld lr,@(lr)
+	jl lr
+	pop r12
+#else
+	bl __mcount_internal
+#endif
+	/* Pop the saved registers.  Please note that `mcount' has no
+	   return value.  */
+	pop lr
+	pop r7
+	pop r6
+	pop r5
+	pop r4
+	pop r3
+	pop r2
+	pop r1
+	pop r0
+	ret
+	ASM_SIZE_DIRECTIVE(C_SYMBOL_NAME(_mcount))
+
+#undef mcount
+weak_alias(_mcount, mcount)
diff --exclude=CVS -upNr ports/sysdeps/m32r/machine-gmon.h ports/sysdeps/m32r/machine-gmon.h
--- ports/sysdeps/m32r/machine-gmon.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/machine-gmon.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,34 @@
+/* Machine-dependent definitions for profiling support.  M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* NOTYET  */
+
+/* We must not pollute the global namespace.  */
+#define mcount_internal __mcount_internal
+
+void mcount_internal (u_long frompc, u_long selfpc);
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+void mcount_internal (u_long frompc, u_long selfpc)
+
+
+/* Define MCOUNT as empty since we have the implementation in another
+   file.  */
+#define MCOUNT
+
diff --exclude=CVS -upNr ports/sysdeps/m32r/memcpy.S ports/sysdeps/m32r/memcpy.S
--- ports/sysdeps/m32r/memcpy.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/memcpy.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,62 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#include <endian.h>
+
+/*
+ * void *memcpy(void *dst, const void *src, size_t n);
+ * No overlap between the memory of DST and of SRC are assumed.
+ *
+ *        dst: r0
+ *        src: r1
+ *        n  : r2
+ */
+
+ENTRY(memcpy)
+	mv	r4, r0
+	mv	r7, r0
+	or	r7, r1
+	beq	r0, r1, end_memcopy
+	beqz	r2, end_memcopy
+
+	and3	r7, r7, #3
+	bnez	r7, byte_copy
+	srl3	r3, r2, #2
+	and3	r2, r2, #3
+	beqz	r3, byte_copy
+	addi	r4, #-4
+word_copy:
+	ld	r7, @r1+
+	addi	r3, #-1
+	st	r7, @+r4
+	bnez	r3, word_copy
+	beqz	r2, end_memcopy
+	addi	r4, #4
+byte_copy:
+	ldb	r7, @r1
+	addi	r1, #1
+	addi	r2, #-1
+	stb	r7, @r4
+	addi	r4, #1
+	bnez	r2, byte_copy
+end_memcopy:
+	jmp	r14
+	nop
+END(memcpy)
+libc_hidden_builtin_def (memcpy)
diff --exclude=CVS -upNr ports/sysdeps/m32r/memset.S ports/sysdeps/m32r/memset.S
--- ports/sysdeps/m32r/memset.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/memset.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,184 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+/*  void *memset(void *dst, int val, int len);
+ *
+ *	dst: r0
+ *	val: r1
+ *	len: r2
+ *	ret: r0
+ */
+
+	.text
+
+#if defined(__m32r2__)
+
+ENTRY(memset)
+	mv      r4, r0		    ||	cmpz	r2
+	jc	r14		    	; return if r2=0
+	cmpui	r2, #16
+	bnc	qword_align_check
+	cmpui	r2, #4
+	bc	byte_set
+; case  len >= 4
+word_align_check:
+	and3	r3, r4, #3
+	beqz	r3, word_set
+; case  no word-align
+	addi	r3, #-4
+	neg	r3, r3			; r3 = -(r3 - 4)
+align_word:
+	stb	r1, @r4		    ||	addi	r4, #1
+	addi	r2, #-1		    ||	addi	r3, #-1
+	bnez	r3, align_word
+	cmpui	r2, #4
+	bc	byte_set
+word_set:
+	and3	r1, r1, #0x00ff		; r1: abababab <-- ??????ab
+	sll3	r3, r1, #8
+	or	r1, r3		    ||	addi	r4, #-4
+	sll3	r3, r1, #16
+	or	r1, r3		    ||	addi	r2, #-4
+word_set_loop:
+	st	r1, @+r4	    ||	addi	r2, #-4
+	bgtz	r2, word_set_loop
+	bnez	r2, byte_set_wrap
+	st	r1, @+r4
+	jmp	r14
+
+qword_align_check:
+	and3	r3, r4, #15
+	bnez	r3, word_align_check
+qword_set:
+	and3	r1, r1, #0x00ff		; r1: abababab <-- ??????ab
+	sll3	r3, r1, #8
+	or	r1, r3		    ||	addi	r4, #-4
+	sll3	r3, r1, #16
+	or	r1, r3		    ||	ldi	r5, #16
+qword_set_loop:
+	ld	r3, @(4,r4)		; cache line allocate
+	st	r1, @+r4	    ||	addi	r2, #-16
+	st	r1, @+r4	    ||	cmpu	r2, r5
+	st	r1, @+r4
+	st	r1, @+r4
+	bnc	qword_set_loop	    ||  cmpz	r2
+	jc	r14
+set_remainder:
+	cmpui	r2, #4
+	bc	byte_set_wrap1
+	addi	r2, #-4
+	bra	word_set_loop
+
+byte_set_wrap:
+	addi	r2, #4
+	cmpz	r2	
+	jc	r14			; return if r2=0
+byte_set_wrap1:
+	addi	r4, #4
+byte_set:
+	addi	r2, #-1		    ||	stb	r1, @r4+
+	bnez	r2, byte_set
+end_memset:
+	jmp	r14
+END(memset)
+
+#else
+
+ENTRY(memset)
+	mv      r4, r0
+	beqz	r2, end_memset
+	cmpui	r2, #16
+	bnc	qword_align_check
+	cmpui	r2, #4
+	bc	byte_set
+; case  len >= 4
+word_align_check:
+	and3	r3, r4, #3
+	beqz	r3, word_set
+; case  no word-align
+	addi	r3, #-4
+	neg	r3, r3			; r3 = -(r3 - 4)
+align_word:
+	stb	r1, @r4
+	addi	r4, #1
+	addi	r2, #-1
+	addi	r3, #-1
+	bnez	r3, align_word
+	cmpui	r2, #4
+	bc	byte_set
+word_set:
+	and3	r1, r1, #0x00ff		; r1: abababab <-- ??????ab
+	sll3	r3, r1, #8
+	or	r1, r3
+	sll3	r3, r1, #16
+	or	r1, r3
+	addi	r2, #-4
+	addi	r4, #-4
+word_set_loop:
+	st	r1, @+r4
+	addi	r2, #-4
+	bgtz    r2, word_set_loop
+	bnez	r2, byte_set_wrap
+	st	r1, @+r4
+	jmp	r14
+
+qword_align_check:
+	and3	r3, r4, #15
+	bnez	r3, word_align_check
+qword_set:
+	and3	r1, r1, #0x00ff		; r1: abababab <-- ??????ab
+	sll3	r3, r1, #8
+	or	r1, r3
+	sll3	r3, r1, #16
+	or	r1, r3
+	addi	r4, #-4
+qword_set_loop:
+	ld	r3, @(4,r4)		; cache line allocate
+	addi	r2, #-16
+	st	r1, @+r4
+	st	r1, @+r4
+	cmpui	r2, #16
+	st	r1, @+r4
+	st	r1, @+r4
+	bnc	qword_set_loop
+	bnez	r2, set_remainder
+	jmp	r14
+set_remainder:
+	cmpui	r2, #4
+	bc	byte_set_wrap1
+	addi	r2, #-4
+	bra	word_set_loop
+
+byte_set_wrap:
+	addi	r2, #4
+	beqz	r2, end_memset
+byte_set_wrap1:
+	addi	r4, #4
+byte_set:
+	addi	r2, #-1
+	stb	r1, @r4
+	addi	r4, #1
+	bnez	r2, byte_set
+end_memset:
+	jmp	r14
+END(memset)
+
+#endif
+libc_hidden_builtin_def (memset)
diff --exclude=CVS -upNr ports/sysdeps/m32r/memusage.h ports/sysdeps/m32r/memusage.h
--- ports/sysdeps/m32r/memusage.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/memusage.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,21 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("r15"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
diff --exclude=CVS -upNr ports/sysdeps/m32r/setjmp.S ports/sysdeps/m32r/setjmp.S
--- ports/sysdeps/m32r/setjmp.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/setjmp.S	2006-03-02 11:18:51.000000000 +0900
@@ -0,0 +1,53 @@
+/* setjmp for M32R.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+ENTRY (__sigsetjmp)
+	mv 	r2, r0
+	/* Save registers */
+	st	r8, @r0	
+	st	r9, @+r0
+	st	r10, @+r0
+	st	r11, @+r0
+	st	r12, @+r0
+	st	r13, @+r0
+	st	r14, @+r0		/* lr */
+	st	r15, @+r0		/* sp */
+	mv 	r0, r2
+
+	/* Make a tail call to __sigjmp_save; it takes the same args.  */
+#ifdef SHARED
+	mv	r2,lr
+	bl.s	.+4
+	ld24	r3,#_GLOBAL_OFFSET_TABLE_
+	add	r3,lr
+	mv	lr,r2
+
+	ld24	r2,C_SYMBOL_NAME(__sigjmp_save@GOT)
+	add	r2,r3
+	ld	r2,@r2
+#else
+	LDIMM	(r2, C_SYMBOL_NAME(__sigjmp_save))
+#endif
+	jmp	r2
+END (__sigsetjmp)
diff --exclude=CVS -upNr ports/sysdeps/m32r/shlib-versions ports/sysdeps/m32r/shlib-versions
--- ports/sysdeps/m32r/shlib-versions	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/shlib-versions	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,2 @@
+m32r.*-.*-linux.*	DEFAULT			GLIBC_2.3
+m32r.*-.*-linux.*	ld=ld-linux.so.2
diff --exclude=CVS -upNr ports/sysdeps/m32r/stackinfo.h ports/sysdeps/m32r/stackinfo.h
--- ports/sysdeps/m32r/stackinfo.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/stackinfo.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,28 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On SH the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --exclude=CVS -upNr ports/sysdeps/m32r/strlen.S ports/sysdeps/m32r/strlen.S
--- ports/sysdeps/m32r/strlen.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/strlen.S	2006-04-20 09:44:29.000000000 +0900
@@ -0,0 +1,77 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#include <endian.h>
+
+/* size_t strlen (const char *s)  */
+
+ENTRY(strlen)
+	mv	r6, r0
+	ldi	r2, #0
+	and3	r0, r0, #3
+	bnez	r0, strlen_byte
+;
+strlen_word:
+	ld	r0, @r6+
+;
+	seth	r5, #high(0x01010101)
+	or3	r5, r5, #low(0x01010101)
+	sll3	r7, r5, #7
+strlen_word_loop:
+	not	r4, r0		; NOTE: If a null char. exists, return 0.
+	sub	r0, r5		; if ((x - 0x01010101) & ~x & 0x80808080)
+	and	r4, r7		;     return 0;
+	and	r4, r0
+	bnez	r4, strlen_last_bytes
+	ld	r1, @r6+
+	addi	r2, #4
+;
+	not	r4, r1		; NOTE: If a null char. exists, return 0.
+	sub	r1, r5		; if ((x - 0x01010101) & ~x & 0x80808080)
+	and	r4, r7		;     return 0;
+	and	r4, r1
+	bnez	r4, strlen_last_bytes
+	ld	r0, @r6+
+	addi	r2, #4
+	bra	strlen_word_loop
+;
+strlen_byte:
+	ldb	r1, @r6
+	addi	r6, #1
+	beqz	r1, strlen_exit
+	addi	r2, #1
+	bra	strlen_byte
+;
+strlen_last_bytes:
+	ldi	r0, #4
+	addi	r6, #-4
+;
+strlen_byte_loop:
+	ldb	r1, @r6
+	addi	r6, #1
+	addi	r0, #-1
+	beqz	r1, strlen_exit
+	addi	r2, #1
+	bnez	r0, strlen_byte_loop
+;
+strlen_exit:
+	mv	r0, r2
+	jmp	r14
+END(strlen)
+libc_hidden_builtin_def (strlen)
diff --exclude=CVS -upNr ports/sysdeps/m32r/sys/ucontext.h ports/sysdeps/m32r/sys/ucontext.h
--- ports/sysdeps/m32r/sys/ucontext.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/sys/ucontext.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,102 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	16
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15,
+#define R15	R15
+};
+
+#if 0
+/* FIXME */
+typedef int freg_t;
+
+/* Number of FPU registers.  */
+#define NFREG	16
+
+/* Structure to describe FPU registers.  */
+typedef freg_t fpregset_t[NFREG];
+#endif
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+#if 0
+    fpregset_t fpregs;
+    fpregset_t xfpregs;
+#endif
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    __sigset_t uc_sigmask;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    long int uc_filler[5];
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --exclude=CVS -upNr ports/sysdeps/m32r/sysdep.h ports/sysdeps/m32r/sysdep.h
--- ports/sysdeps/m32r/sysdep.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/m32r/sysdep.h	2006-03-06 15:12:42.000000000 +0900
@@ -0,0 +1,92 @@
+/* Assembler macros for M32R.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdeps/generic/sysdep.h>
+
+#ifdef	__ASSEMBLER__
+
+/* Syntactic details of assembler.  */
+
+#ifdef HAVE_ELF
+
+#define ALIGNARG(log2) log2
+/* For ELF we need the `.type' directive to make shared libs work right.  */
+#define ASM_TYPE_DIRECTIVE(name,typearg) .type name,@##typearg
+#define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+#define PLTJMP(_x)	_x
+#define GOT(_x)	_x
+
+#else
+
+#define ALIGNARG(log2) log2
+#define ASM_TYPE_DIRECTIVE(name,type)	/* Nothing is specified.  */
+#define ASM_SIZE_DIRECTIVE(name)	/* Nothing is specified.  */
+
+#define PLTJMP(_x)	_x
+#define GOT(_x)	_x
+
+#endif
+
+/* If compiled for profiling, call `mcount' at the start of each function.  */
+#ifdef	PROF
+#ifdef	__PIC__
+#define CALL_MCOUNT \
+	push r14 ! \
+	ld24 r14,#mcount@GOT ! \
+	add r14,r12 ! \
+	ld r14,@r14 ! \
+	jl r14 ! \
+	pop r14
+#else
+#define CALL_MCOUNT \
+	push r14 ! \
+	seth r14,#high(mcount) ! \
+	or3 r14,r14,#low(mcount) ! \
+	jl r14 ! \
+	pop r14
+#endif
+#else
+#define CALL_MCOUNT		/* Do nothing.  */
+#endif
+
+#undef CALL_MCOUNT		/* Do nothing.  */
+#define CALL_MCOUNT		/* Do nothing.  */
+
+/* Define an entry point visible from C.  */
+#define	ENTRY(name)							      \
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name)				!     \
+  ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),function)			!     \
+  .balign 4								!     \
+  C_LABEL(name)								!     \
+  CALL_MCOUNT
+
+#undef	END
+#define END(name)							      \
+  ASM_SIZE_DIRECTIVE(C_SYMBOL_NAME(name))
+
+#ifdef	NO_UNDERSCORES
+/* Since C identifiers are not normally prefixed with an underscore
+   on this system, the asm identifier `syscall_error' intrudes on the
+   C name space.  Make sure we use an innocuous name.  */
+#define	syscall_error	__syscall_error
+#define mcount		_mcount
+#endif
+
+#endif	/* __ASSEMBLER__ */
diff --exclude=CVS -upNr ports/sysdeps/unix/m32r/Makefile ports/sysdeps/unix/m32r/Makefile
--- ports/sysdeps/unix/m32r/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/m32r/Makefile	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,4 @@
+# m32r/ELF specific definitions.
+
+# The assembler on m32r needs the -fPIC flag even when it's assembler code.
+ASFLAGS-.os = -fPIC
diff --exclude=CVS -upNr ports/sysdeps/unix/m32r/sysdep.S ports/sysdeps/unix/m32r/sysdep.S
--- ports/sysdeps/unix/m32r/sysdep.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/m32r/sysdep.S	2006-03-02 11:39:48.000000000 +0900
@@ -0,0 +1,84 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H
+#include <bits/errno.h>
+
+.globl C_SYMBOL_NAME(errno)
+.globl syscall_error
+
+#undef syscall_error
+#ifdef NO_UNDERSCORES
+__syscall_error:
+#else
+syscall_error:
+#endif
+#if defined (EWOULDBLOCK_sys) && EWOULDBLOCK_sys != EAGAIN
+	/* We translate the system's EWOULDBLOCK error into EAGAIN.
+	   The GNU C library always defines EWOULDBLOCK==EAGAIN.
+	   EWOULDBLOCK_sys is the original number.  */
+	ldi	r1, #EWOULDBLOCK_sys
+	bne	r1, r0, skip
+	ldi	r0, #EAGAIN
+skip:
+#endif
+	/* Store it in errno... */
+#ifndef SHARED
+#ifndef _LIBC_REENTRANT
+	LDIMM	(r1, C_SYMBOL_NAME(errno))
+	st	r0, @r1
+#else
+	push	r0
+	push	lr
+	LDIMM	(r1, C_SYMBOL_NAME(__errno_location))
+	jl	r1
+	pop	lr
+	pop	r1
+	st	r1, @r0
+#endif
+#else
+	push	r12
+	push	lr
+	bl.s	.+4
+	ld24	r12,#_GLOBAL_OFFSET_TABLE_
+	add	r12, lr
+#ifndef _LIBC_REENTRANT
+	mv	r2, r0
+	LDIMM	(r1, C_SYMBOL_NAME(errno@GOT))
+	add	r1, r12
+	ld	r1, @r1
+	st	r2, @r1
+#else
+	push	r0
+	LDIMM	(r1, C_SYMBOL_NAME(__errno_location@GOT))
+	add	r1, r12
+	ld	r1, @r1
+	jl	r1
+	pop	r1
+	st	r1, @r0
+#endif
+	pop	lr
+	pop	r12
+#endif
+	/* And just kick back a -1.  */
+	ldi	r0, #-1
+	ret
+
+#undef  __syscall_error
+END(__syscall_error)
diff --exclude=CVS -upNr ports/sysdeps/unix/m32r/sysdep.h ports/sysdeps/unix/m32r/sysdep.h
--- ports/sysdeps/unix/m32r/sysdep.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/m32r/sysdep.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,33 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdeps/unix/sysdep.h>
+#include "../../m32r/sysdep.h"
+
+#ifdef __ASSEMBLER__
+
+#define ret	jmp r14
+
+/* The m32r move insn is d, s.  */
+#define MOVE(x,y)	mv y,x
+
+#define LDIMM(reg,x) \
+	seth	reg, #high(x)       ! \
+	or3	reg, reg, #low(x)
+
+#endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/Dist ports/sysdeps/unix/sysv/linux/m32r/Dist
--- ports/sysdeps/unix/sysv/linux/m32r/Dist	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/Dist	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,9 @@
+clone.S
+pipe.S
+flushcache.S
+setresuid.c
+setresgid.c
+setfsuid.c
+setfsgid.c
+sys/io.h
+sys/user.h
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/Makefile ports/sysdeps/unix/sysv/linux/m32r/Makefile
--- ports/sysdeps/unix/sysv/linux/m32r/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/Makefile	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,16 @@
+# m32r/ELF specific definitions.
+#gnulib := -lgcc
+#static-gnulib := -lgcc
+
+# The assembler on m32r needs the -fPIC flag even when it's assembler code.
+ASFLAGS-.os = -fPIC
+
+ifeq ($(subdir),io)
+sysdep_routines += pipe
+endif
+
+ifeq ($(subdir),misc)
+sysdep_routines += m32r-stub tas \
+		   cachectl flushcache
+sysdep_headers += sys/io.h sys/tas.h sys/cachectl.h
+endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/Versions ports/sysdeps/unix/sysv/linux/m32r/Versions
--- ports/sysdeps/unix/sysv/linux/m32r/Versions	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/Versions	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,12 @@
+libc {
+  GLIBC_2.3 {
+    # Needed by gcc
+    _flush_cache;
+
+    # c*
+    cachectl; cacheflush;
+
+    # t*
+    tas;
+  }
+}
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/bits/fcntl.h ports/sysdeps/unix/sysv/linux/m32r/bits/fcntl.h
--- ports/sysdeps/unix/sysv/linux/m32r/bits/fcntl.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/bits/fcntl.h	2006-03-01 17:17:36.000000000 +0900
@@ -0,0 +1,179 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2003, 2004, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECT	 040000	/* Direct disk access.  */
+# define O_DIRECTORY	0200000	/* Must be a directory.  */
+# define O_NOFOLLOW	0400000	/* Do not follow links.  */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.  */
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.  */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0100000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).  */
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.  */
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).  */
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.  */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.  */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.  */
+#define F_UNLCK		2	/* Remove lock.  */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.  */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:   */
+# define LOCK_READ	64	/* ... which allows concurrent read operations.  */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.  */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/bits/mman.h ports/sysdeps/unix/sysv/linux/m32r/bits/mman.h
--- ports/sysdeps/unix/sysv/linux/m32r/bits/mman.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/bits/mman.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,98 @@
+/* Definitions for POSIX memory map interface.  Linux/M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN  0x01000000      /* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP    0x02000000      /* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/bits/resource.h ports/sysdeps/unix/sysv/linux/m32r/bits/resource.h
--- ports/sysdeps/unix/sysv/linux/m32r/bits/resource.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/bits/resource.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,209 @@
+/* Bit values & structures for resource limits.  Linux/M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  RLIMIT_RSS = 5,
+#define	RLIMIT_RSS RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 7,
+  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE RLIMIT_OFILE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS RLIMIT_LOCKS
+
+  RLIMIT_NLIMITS = 11,
+  RLIM_NLIMITS = RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS RLIMIT_NLIMITS
+#define RLIM_NLIMITS RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((unsigned long int)(~0UL))
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1,
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+  /* Both.  */
+  RUSAGE_BOTH = -2
+#define RUSAGE_BOTH RUSAGE_BOTH
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/brk.c ports/sysdeps/unix/sysv/linux/m32r/brk.c
--- ports/sysdeps/unix/sysv/linux/m32r/brk.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/brk.c	2006-03-02 12:30:59.000000000 +0900
@@ -0,0 +1,50 @@
+/* brk system call for Linux/M32R.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* This must be initialized data because commons can't have aliases.  */
+void *__curbrk = 0;
+
+int
+__brk (void *addr)
+{
+  void *newbrk;
+  register long r7 asm ("r7") = SYS_ify (brk);
+  register long r0 asm ("r0") = (long)addr;
+
+  asm volatile ("trap #0x2 || nop\n\t"
+		"mv %0,r0\n"
+		: "=r"(newbrk), "+r" (r0) 
+		: "r" (r7), "r" (r0)
+		);
+
+  __curbrk = newbrk;
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+weak_alias (__brk, brk)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/chown.c ports/sysdeps/unix/sysv/linux/m32r/chown.c
--- ports/sysdeps/unix/sysv/linux/m32r/chown.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/chown.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+int
+__chown (const char *file, uid_t owner, gid_t group)
+{
+  return INLINE_SYSCALL (chown32, 3, CHECK_STRING (file), owner, group);
+}
+libc_hidden_def (__chown)
+weak_alias (__chown, chown)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/clone.S ports/sysdeps/unix/sysv/linux/m32r/clone.S
--- ports/sysdeps/unix/sysv/linux/m32r/clone.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/clone.S	2006-03-02 17:39:21.000000000 +0900
@@ -0,0 +1,89 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     pid_t *ptid, void *tls, pid_t *ctid); */
+
+        .text
+ENTRY(__clone)
+	/* sanity check arguments.  */
+	beqz	r0, 1f
+	bnez	r1, 2f
+
+	.fillinsn
+1:
+	ldi	r0, #-EINVAL
+	bra	.Lsyscall_error
+	.fillinsn
+2:
+	/* insert the args onto the new stack */
+	st	r3, @-r1
+	/* save the function pointer as the 0th element */
+	st	r0, @-r1
+
+	/* do the system call */
+	mv	r0, r2
+	ld	r2, @r15
+	ld	r3, @(8,r15)
+	;ld	RX, @(4,r15) /* FIXME: *tls */
+	ldi	r7, #SYS_ify(clone)
+	SYSCALL_INST
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 3f			// i.e. error in linux
+
+	.fillinsn
+.Lsyscall_error:
+	SYSCALL_ERROR_HANDLER
+	.fillinsn
+3:
+	beqz	r0, 4f
+	ret
+	.fillinsn
+4:
+	/* thread starts */
+	ld	r1, @r15
+	ld	r0, @(4,r15)
+	jl	r1
+
+	/* we are done, passing the return value through r0  */
+#ifdef SHARED
+        push    r12
+	push    lr
+	bl.s    .+4
+	ld24    r12, #_GLOBAL_OFFSET_TABLE_
+	add     r12, lr
+	bl      C_SYMBOL_NAME(_exit@PLT)
+	pop     lr
+	pop     r12
+	ret
+#else
+	LDIMM   (r1, C_SYMBOL_NAME(_exit))
+	jmp     r1
+#endif
+
+PSEUDO_END (__clone)
+
+weak_alias (__clone, clone)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/configure ports/sysdeps/unix/sysv/linux/m32r/configure
--- ports/sysdeps/unix/sysv/linux/m32r/configure	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/configure	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,5 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for m32r/sysdeps/unix/sysv/linux/m32r
+
+arch_minimum_kernel=2.4.19
+
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/configure.in ports/sysdeps/unix/sysv/linux/m32r/configure.in
--- ports/sysdeps/unix/sysv/linux/m32r/configure.in	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/configure.in	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,4 @@
+# Local configure fragment for m32r/sysdeps/unix/sysv/linux/m32r
+
+arch_minimum_kernel=2.4.19
+
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/fchown.c ports/sysdeps/unix/sysv/linux/m32r/fchown.c
--- ports/sysdeps/unix/sysv/linux/m32r/fchown.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/fchown.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fchown.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/fcntl.c ports/sysdeps/unix/sysv/linux/m32r/fcntl.c
--- ports/sysdeps/unix/sysv/linux/m32r/fcntl.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/fcntl.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/flushcache.S ports/sysdeps/unix/sysv/linux/m32r/flushcache.S
--- ports/sysdeps/unix/sysv/linux/m32r/flushcache.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/flushcache.S	2006-03-02 11:42:26.000000000 +0900
@@ -0,0 +1,29 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free 
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 
+   02111-1307, USA.  */
+
+#include <sysdep.h>
+
+/* int _flush_cache(char *addr, int nbytes, int cache); */
+
+        .text
+ENTRY(__flush_cache)
+	trap	#12 || nop
+	ret
+PSEUDO_END (__flush_cache)
+
+weak_alias (__flush_cache, _flush_cache)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/fxstat.c ports/sysdeps/unix/sysv/linux/m32r/fxstat.c
--- ports/sysdeps/unix/sysv/linux/m32r/fxstat.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/fxstat.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstat.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getegid.c ports/sysdeps/unix/sysv/linux/m32r/getegid.c
--- ports/sysdeps/unix/sysv/linux/m32r/getegid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getegid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getegid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/geteuid.c ports/sysdeps/unix/sysv/linux/m32r/geteuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/geteuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/geteuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/geteuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getgid.c ports/sysdeps/unix/sysv/linux/m32r/getgid.c
--- ports/sysdeps/unix/sysv/linux/m32r/getgid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getgid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getgid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getgroups.c ports/sysdeps/unix/sysv/linux/m32r/getgroups.c
--- ports/sysdeps/unix/sysv/linux/m32r/getgroups.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getgroups.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,2 @@
+/* We also have to rewrite the kernel gid_t to the user land type.  */
+#include <sysdeps/unix/sysv/linux/i386/getgroups.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getresgid.c ports/sysdeps/unix/sysv/linux/m32r/getresgid.c
--- ports/sysdeps/unix/sysv/linux/m32r/getresgid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getresgid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,38 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <linux/posix_types.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+int
+__getresgid (gid_t *rgid, gid_t *egid, gid_t *sgid)
+{
+  return INLINE_SYSCALL (getresgid32, 3, CHECK_1 (rgid),
+			 CHECK_1 (egid), CHECK_1 (sgid));
+}
+libc_hidden_def (__getresgid)
+weak_alias (__getresgid, getresgid)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getresuid.c ports/sysdeps/unix/sysv/linux/m32r/getresuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/getresuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getresuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,38 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <linux/posix_types.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+int
+__getresuid (uid_t *ruid, uid_t *euid, uid_t *suid)
+{
+  return INLINE_SYSCALL (getresuid32, 3, CHECK_1 (ruid),
+			 CHECK_1 (euid), CHECK_1 (suid));
+}
+libc_hidden_def (__getresuid)
+weak_alias (__getresuid, getresuid)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getrlimit.c ports/sysdeps/unix/sysv/linux/m32r/getrlimit.c
--- ports/sysdeps/unix/sysv/linux/m32r/getrlimit.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getrlimit.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,36 @@
+/* Copyright (C) 1999, 2000, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/resource.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <shlib-compat.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+int
+__new_getrlimit (enum __rlimit_resource resource, struct rlimit *rlimits)
+{
+  return INLINE_SYSCALL (ugetrlimit, 2, resource, CHECK_1 (rlimits));
+}
+
+weak_alias (__new_getrlimit, __getrlimit);
+versioned_symbol (libc, __new_getrlimit, getrlimit, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getrlimit64.c ports/sysdeps/unix/sysv/linux/m32r/getrlimit64.c
--- ports/sysdeps/unix/sysv/linux/m32r/getrlimit64.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getrlimit64.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,25 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define getrlimit64 __new_getrlimit64
+
+#include <sysdeps/generic/getrlimit64.c>
+
+#undef getrlimit64
+#include <shlib-compat.h>
+versioned_symbol (libc, __new_getrlimit64, getrlimit64, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/getuid.c ports/sysdeps/unix/sysv/linux/m32r/getuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/getuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/getuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/kernel-features.h ports/sysdeps/unix/sysv/linux/m32r/kernel-features.h
--- ports/sysdeps/unix/sysv/linux/m32r/kernel-features.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/kernel-features.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,17 @@
+#define __ASSUME_32BITUIDS		1
+#define __ASSUME_CLONE_THREAD_FLAGS	1
+#define __ASSUME_FADVISE64_64_SYSCALL	1
+#define __ASSUME_FCNTL64		1
+#define __ASSUME_GETDENTS64_SYSCALL	1
+#define __ASSUME_IPC64			1
+#define __ASSUME_MMAP2_SYSCALL		1
+#define __ASSUME_NEW_GETRLIMIT_SYSCALL	1
+#define __ASSUME_SETRESGID_SYSCALL	1
+#define __ASSUME_SETRESUID_SYSCALL	1
+#define __ASSUME_STAT64_SYSCALL		1
+#define __ASSUME_ST_INO_64_BIT		1
+#define __ASSUME_TGKILL			1
+#define __ASSUME_TRUNCATE64_SYSCALL	1
+#define __ASSUME_UTIMES			1
+
+#include_next "kernel-features.h"
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/lchown.c ports/sysdeps/unix/sysv/linux/m32r/lchown.c
--- ports/sysdeps/unix/sysv/linux/m32r/lchown.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/lchown.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+int
+__lchown (const char *file, uid_t owner, gid_t group)
+{
+  return INLINE_SYSCALL (lchown32, 3, CHECK_STRING (file), owner, group);
+}
+
+weak_alias (__lchown, lchown)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h
--- ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/sysdep-cancel.h	2006-04-20 09:44:47.000000000 +0900
@@ -0,0 +1,186 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+	.text!								      \
+  ENTRY(name)!        					 		      \
+    SINGLE_THREAD_P_INT !						      \
+    bnez r6, .Lpseudo_cancel !						      \
+    DO_CALL (syscall_name, args) !					      \
+    not r5,r0 !								      \
+    srai r5,12 !							      \
+    bnez r5,.Lpseudo_end !						      \
+    bra .Lsyscall_error !						      \
+    .fillinsn !								      \
+  .Lpseudo_cancel: !							      \
+    SAVE_REGS !								      \
+    /* save syscall args around CENABLE. */				      \
+    DOCARGS_##args !							      \
+    CENABLE !								      \
+    mv r8,r0 ! /* put mask back */					      \
+    /* restore syscall args */						      \
+    UNDOCARGS_##args !							      \
+    ldi r7, SYS_ify(syscall_name) ! /* do the call */			      \
+    SYSCALL_INST_##args !						      \
+    /* save syscall return value */					      \
+    push r0 !								      \
+    mv r0,r8 ! /* get mask back */					      \
+    CDISABLE !								      \
+    pop r0 ! /* retrive return value. */				      \
+    UNDOC2ARGS_##args !							      \
+    RESTORE_REGS !							      \
+    /* fix register damege. */						      \
+    not r5,r0 !								      \
+    srai r5,12 !							      \
+    bnez r5, .Lpseudo_end !						      \
+    .fillinsn !								      \
+  .Lsyscall_error: !							      \
+    SYSCALL_ERROR_HANDLER !						      \
+    .fillinsn !								      \
+  .Lpseudo_end: !							      \
+
+# define DOCARGS_0
+# define UNDOCARGS_0
+# define UNDOC2ARGS_0
+
+# define DOCARGS_1	push r0
+# define UNDOCARGS_1	pop r0
+# define UNDOC2ARGS_1
+
+# define DOCARGS_2	push r1 ! push r0
+# define UNDOCARGS_2	pop r0 ! pop r1
+# define UNDOC2ARGS_2
+
+# define DOCARGS_3	push r2 ! push r1 ! push r0
+# define UNDOCARGS_3	pop r0 ! pop r1 ! pop r2
+# define UNDOC2ARGS_3
+
+# define DOCARGS_4	push r3 ! push r2 ! push r1 ! push r0
+# define UNDOCARGS_4	pop r0 ! pop r1 ! pop r2 ! pop r3
+# define UNDOC2ARGS_4
+
+# define DOCARGS_5	push r3 ! push r2 ! push r1 ! push r0
+# if !defined PIC
+#  define UNDOCARGS_5	pop r0 ! pop r1 ! pop r2 ! pop r3 ! ld r4, @(8,sp) ! push r4
+#  define UNDOC2ARGS_5  addi sp,#4
+# else
+#  define UNDOCARGS_5	pop r0 ! pop r1 ! pop r2 ! pop r3 ! ld r4, @(12,sp) ! push r4
+#  define UNDOC2ARGS_5	addi sp,#4
+# endif
+
+
+# ifdef IS_IN_libpthread
+#  ifdef PIC
+#   define CENABLE	bl __pthread_enable_asynccancel@PLT
+#   define CDISABLE	bl __pthread_disable_asynccancel@PLT
+#  else
+#   define CENABLE	bl __pthread_enable_asynccancel
+#   define CDISABLE	bl __pthread_disable_asynccancel
+#  endif
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  ifdef PIC
+#   define CENABLE	bl __libc_enable_asynccancel@PLT
+#   define CDISABLE	bl __libc_disable_asynccancel@PLT
+#  else
+#   define CENABLE	bl __libc_enable_asynccancel
+#   define CDISABLE	bl __libc_disable_asynccancel
+#  endif
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  ifdef PIC
+#   define CENABLE     bl __librt_enable_asynccancel@PLT
+#   define CDISABLE    bl __librt_disable_asynccancel@PLT
+#  else
+#   define CENABLE     bl __librt_enable_asynccancel
+#   define CDISABLE    bl __librt_disable_asynccancel
+#  endif
+#  define __local_multiple_threads __librt_multiple_threads
+# endif
+
+# ifndef __ASSEMBLER__
+extern int __local_multiple_threads attribute_hidden;
+#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+# else
+#  if !defined PIC
+#   define SINGLE_THREAD_P_INT \
+      seth r6,#shigh(__local_multiple_threads) ! \
+      ld r6,@(low(__local_multiple_threads), r6)
+
+#   define SINGLE_THREAD_P SINGLE_THREAD_P_INT
+
+#   define SAVE_REGS \
+	push lr ! push r8
+
+#   define RESTORE_REGS \
+	pop r8 ! pop lr
+
+#  else
+#   if !defined NOT_IN_libc || defined IS_IN_libpthread
+#   define SINGLE_THREAD_P_INT \
+       mv r4,lr ! \
+       bl.s .+4 ! \
+        ld24 r5,#_GLOBAL_OFFSET_TABLE_ ! \
+       seth r6,#high(__local_multiple_threads@GOTOFF) !\
+       or3 r6,r6,#low(__local_multiple_threads@GOTOFF) !\
+       add r5,lr ! \
+       mv lr,r4 ! \
+       add r6,r5 ! \
+       ld r6,@r6
+
+#   else
+#   define SINGLE_THREAD_P_INT \
+	mv r4,lr ! \
+	bl.s .+4 ! \
+        ld24 r5,#_GLOBAL_OFFSET_TABLE_ ! \
+	ld24 r6,#__local_multiple_threads@GOT !\
+	add r5,lr ! \
+	mv lr,r4 ! \
+	add r6,r5 ! \
+	ld r6,@r6 ! \
+	ld r6,@r6 
+
+#   endif
+
+#   define SINGLE_THREAD_P \
+	SINGLE_THREAD_P_INT
+
+#   define SAVE_REGS \
+	push lr ! push r8 ! push r12 ! mv r12, r5
+
+#   define RESTORE_REGS \
+	pop r12 ! pop r8 ! pop lr
+
+#  endif
+# endif
+
+
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+
+#endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S
--- ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/linuxthreads/vfork.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,75 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep-cancel.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include "kernel-features.h"
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+#ifdef __NR_vfork
+
+#ifdef SHARED
+	mv	r4, lr
+	bl.s	.+4
+	ld24    r5, #_GLOBAL_OFFSET_TABLE_
+	add	r5, lr
+	mv	lr, r4
+
+	seth	r6, #high(__libc_pthread_functions@GOTOFF)
+	or3	r6, r6, #low(__libc_pthread_functions@GOTOFF)
+	add	r6, r5
+	ld	r0, @r6
+
+	seth	r6, #high(HIDDEN_JUMPTARGET(__fork)@GOTOFF)
+	or3	r6, r6, #low(HIDDEN_JUMPTARGET(__fork)@GOTOFF)
+	add	r6, r5
+	beqz	r0, 5f
+	jmp	r6
+	.fillinsn
+5:
+#else
+	.weak	pthread_create
+	seth	r0, #shigh(pthread_create)
+	or3	r0, r0, #low(pthread_create)
+	bnez	r0, HIDDEN_JUMPTARGET(__fork)
+#endif
+
+	ldi	r7, #__NR_vfork
+	SYSCALL_INST
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+#endif
+
+	SYSCALL_ERROR_HANDLER
+
+	.fillinsn
+1:
+	ret
+
+
+PSEUDO_END (__vfork)
+libc_hidden_def(__vfork) 
+
+weak_alias (__vfork, vfork)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/lockf64.c ports/sysdeps/unix/sysv/linux/m32r/lockf64.c
--- ports/sysdeps/unix/sysv/linux/m32r/lockf64.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/lockf64.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/lxstat.c ports/sysdeps/unix/sysv/linux/m32r/lxstat.c
--- ports/sysdeps/unix/sysv/linux/m32r/lxstat.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/lxstat.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,2 @@
+#include <sysdeps/unix/sysv/linux/i386/lxstat.c>
+
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/m32r-stub.c ports/sysdeps/unix/sysv/linux/m32r/m32r-stub.c
--- ports/sysdeps/unix/sysv/linux/m32r/m32r-stub.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/m32r-stub.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,11 @@
+#include <elf/link.h>
+
+struct link_map _dl_rtld_map;
+
+#ifndef __PIC__
+void __pthread_initialize_minimal(void)
+{
+}
+#endif
+
+
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/mmap.S ports/sysdeps/unix/sysv/linux/m32r/mmap.S
--- ports/sysdeps/unix/sysv/linux/m32r/mmap.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/mmap.S	2006-04-20 09:44:30.000000000 +0900
@@ -0,0 +1,59 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+#define EINVAL  22
+
+/* 
+__ptr_t
+__mmap (__ptr_t addr, size_t len, int prot, int flags, int fd, off_t offset);
+*/
+
+ENTRY (__mmap)
+	/* Push args and pass the address of 1st arg.
+	 * The 5th and 6th args are already passed in the stack.
+	 */
+	ld	r4, @sp			// fd
+	ld	r5, @(4,sp)		// offset
+	and3	r6, r5, #0x00000fff
+	beqz	r6, 2f
+	ldi	r0, #-EINVAL 
+	bra	0f
+	.fillinsn
+2:
+	srli	r5, #12
+
+	ldi	r7, #__NR_mmap2
+	SYSCALL_INST
+	
+	.fillinsn
+0:
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+	SYSCALL_ERROR_HANDLER
+
+	.fillinsn
+1:
+	ret
+
+PSEUDO_END (__mmap)
+
+weak_alias (__mmap, mmap)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/msgctl.c ports/sysdeps/unix/sysv/linux/m32r/msgctl.c
--- ports/sysdeps/unix/sysv/linux/m32r/msgctl.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/msgctl.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,39 @@
+/* Copyright (C) 1995, 1997, 1998, 2000, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+#include <shlib-compat.h>
+
+int
+__new_msgctl (int msqid, int cmd, struct msqid_ds *buf)
+{
+  return INLINE_SYSCALL (ipc, 5, IPCOP_msgctl,
+			 msqid, cmd | __IPC_64, 0, CHECK_1 (buf));
+}
+
+versioned_symbol (libc, __new_msgctl, msgctl, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/pipe.S ports/sysdeps/unix/sysv/linux/m32r/pipe.S
--- ports/sysdeps/unix/sysv/linux/m32r/pipe.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/pipe.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,37 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+ENTRY (__libc_pipe)
+	ldi	r7, #__NR_pipe
+	SYSCALL_INST
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+	SYSCALL_ERROR_HANDLER
+	.fillinsn
+1:
+	ldi	r0, #0
+	ret
+PSEUDO_END (__libc_pipe)
+
+weak_alias (__libc_pipe, __pipe)
+libc_hidden_def (__pipe)
+weak_alias (__libc_pipe, pipe)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/profil-counter.h ports/sysdeps/unix/sysv/linux/m32r/profil-counter.h
--- ports/sysdeps/unix/sysv/linux/m32r/profil-counter.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/profil-counter.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,29 @@
+/* Low-level statistical profiling support function.  Linux/M32R version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <signal.h>
+#include <sigcontextinfo.h>
+
+static void
+profil_counter (int signo, SIGCONTEXT sc)
+{
+  void *pc;
+  pc = GET_PC(sc);
+  profil_count (pc);
+}
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/semctl.c ports/sysdeps/unix/sysv/linux/m32r/semctl.c
--- ports/sysdeps/unix/sysv/linux/m32r/semctl.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/semctl.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,62 @@
+/* Copyright (C) 1995,1997,1998,2000,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/sem.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+
+#include "kernel-features.h"
+#include <shlib-compat.h>
+
+/* Define a `union semun' suitable for Linux here.  */
+union semun
+{
+  int val;			/* value for SETVAL */
+  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  unsigned short int *array;	/* array for GETALL & SETALL */
+  struct seminfo *__buf;	/* buffer for IPC_INFO */
+  struct __old_semid_ds *__old_buf;
+};
+
+#include <bp-checks.h>
+#include <bp-semctl.h>		/* definition of CHECK_SEMCTL needs union semum */
+
+int
+__new_semctl (int semid, int semnum, int cmd, ...)
+{
+  union semun arg;
+  va_list ap;
+
+  va_start (ap, cmd);
+
+  /* Get the argument.  */
+  arg = va_arg (ap, union semun);
+
+  va_end (ap);
+
+  return INLINE_SYSCALL (ipc, 5, IPCOP_semctl, semid, semnum, cmd | __IPC_64,
+			 CHECK_SEMCTL (&arg, semid, cmd | __IPC_64));
+}
+
+versioned_symbol (libc, __new_semctl, semctl, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setegid.c ports/sysdeps/unix/sysv/linux/m32r/setegid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setegid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setegid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setegid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/seteuid.c ports/sysdeps/unix/sysv/linux/m32r/seteuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/seteuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/seteuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/seteuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setfsgid.c ports/sysdeps/unix/sysv/linux/m32r/setfsgid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setfsgid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setfsgid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,34 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/fsuid.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+int
+setfsgid (gid_t gid)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsgid32, err, 1, gid);
+}
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setfsuid.c ports/sysdeps/unix/sysv/linux/m32r/setfsuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setfsuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setfsuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/fsuid.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+int
+setfsuid (uid_t uid)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  /* No error checking. */
+  return INTERNAL_SYSCALL (setfsuid32, err, 1, uid);
+}
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setgid.c ports/sysdeps/unix/sysv/linux/m32r/setgid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setgid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setgid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setgid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setgroups.c ports/sysdeps/unix/sysv/linux/m32r/setgroups.c
--- ports/sysdeps/unix/sysv/linux/m32r/setgroups.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setgroups.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,2 @@
+/* We also have to rewrite the kernel gid_t to the user land type.  */
+#include <sysdeps/unix/sysv/linux/i386/setgroups.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setregid.c ports/sysdeps/unix/sysv/linux/m32r/setregid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setregid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setregid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setregid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setresgid.c ports/sysdeps/unix/sysv/linux/m32r/setresgid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setresgid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setresgid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresgid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setresuid.c ports/sysdeps/unix/sysv/linux/m32r/setresuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setresuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setresuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setresuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setreuid.c ports/sysdeps/unix/sysv/linux/m32r/setreuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setreuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setreuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setreuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setrlimit.c ports/sysdeps/unix/sysv/linux/m32r/setrlimit.c
--- ports/sysdeps/unix/sysv/linux/m32r/setrlimit.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setrlimit.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,37 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/param.h>
+#include <sys/resource.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <shlib-compat.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+int
+__new_setrlimit (enum __rlimit_resource resource, const struct rlimit *rlimits)
+{
+  return INLINE_SYSCALL (setrlimit, 2, resource, CHECK_1 (rlimits));
+}
+
+weak_alias (__new_setrlimit, __setrlimit);
+versioned_symbol (libc, __new_setrlimit, setrlimit, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/setuid.c ports/sysdeps/unix/sysv/linux/m32r/setuid.c
--- ports/sysdeps/unix/sysv/linux/m32r/setuid.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/setuid.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/setuid.c>
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/shmctl.c ports/sysdeps/unix/sysv/linux/m32r/shmctl.c
--- ports/sysdeps/unix/sysv/linux/m32r/shmctl.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/shmctl.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,40 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/wordsize.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+#include <shlib-compat.h>
+
+int
+__new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
+{
+  return INLINE_SYSCALL (ipc, 5, IPCOP_shmctl,
+			 shmid, cmd | __IPC_64, 0, CHECK_1 (buf));
+}
+
+versioned_symbol (libc, __new_shmctl, shmctl, GLIBC_2_3);
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sigaction.c ports/sysdeps/unix/sysv/linux/m32r/sigaction.c
--- ports/sysdeps/unix/sysv/linux/m32r/sigaction.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sigaction.c	2006-03-02 12:32:45.000000000 +0900
@@ -0,0 +1,105 @@
+/* POSIX.1 `sigaction' call for Linux/M32R.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+#include <stddef.h>
+#include <signal.h>
+#include <string.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include "kernel-features.h"
+
+/* The difference here is that the sigaction structure used in the
+   kernel is not the same as we use in the libc.  Therefore we must
+   translate it here.  */
+#include <kernel_sigaction.h>
+
+/* We do not globally define the SA_RESTORER flag so do it here.  */
+#define SA_RESTORER 0x04000000
+
+/* Using the hidden attribute here does not change the code but it
+   helps to avoid warnings.  */
+#if defined HAVE_HIDDEN && defined HAVE_VISIBILITY_ATTRIBUTE \
+    && !defined HAVE_BROKEN_VISIBILITY_ATTRIBUTE
+extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
+#else
+static void restore_rt (void) asm ("__restore_rt");
+#endif
+
+
+/* If ACT is not NULL, change the action for SIG to *ACT.
+   If OACT is not NULL, put the old action for SIG in *OACT.  */
+int
+__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+  int result;
+  struct kernel_sigaction kact, koact;
+
+  if (act)
+    {
+      kact.k_sa_handler = act->sa_handler;
+      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));
+      kact.sa_flags = act->sa_flags | SA_RESTORER;
+
+      kact.sa_restorer = &restore_rt;
+    }
+
+  /* XXX The size argument hopefully will have to be changed to the
+     real size of the user-level sigset_t.  */
+  result = INLINE_SYSCALL (rt_sigaction, 4,
+			   sig, act ? __ptrvalue (&kact) : NULL,
+			   oact ? __ptrvalue (&koact) : NULL, _NSIG / 8);
+  if (oact && result >= 0)
+    {
+      oact->sa_handler = koact.k_sa_handler;
+      memcpy (&oact->sa_mask, &koact.sa_mask, sizeof (sigset_t));
+      oact->sa_flags = koact.sa_flags;
+      oact->sa_restorer = koact.sa_restorer;
+    }
+  return result;
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
+
+/* NOTE: Please think twice before making any changes to the bits of
+   code below.  GDB needs some intimate knowledge about it to
+   recognize them as signal trampolines, and make backtraces through
+   signal handlers work right.  Important are both the names
+   (__restore_rt) and the exact instruction sequence.
+   If you ever feel the need to make any changes, please notify the
+   appropriate GDB maintainer.  */
+
+#define RESTORE(name, syscall) RESTORE2 (name, syscall)
+# define RESTORE2(name, syscall) \
+asm						\
+  (						\
+   "__" #name ":\n"				\
+   "	ldi r7,#" #syscall "\n"		\
+   "	trap #2 || nop\n"				\
+   );
+/* The return code for realtime-signals.  */
+RESTORE (restore_rt, __NR_rt_sigreturn)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sigcontextinfo.h ports/sysdeps/unix/sysv/linux/m32r/sigcontextinfo.h
--- ports/sysdeps/unix/sysv/linux/m32r/sigcontextinfo.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sigcontextinfo.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,26 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Philip Blundell <philb@gnu.org>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define SIGCONTEXT struct sigcontext * 
+#define SIGCONTEXT_EXTRA_ARGS
+#define GET_PC(ctx)	((void *)((ctx)->sc_bpc))
+#define GET_FRAME(ctx)	((void *)((ctx)->sc_fp))
+#define GET_STACK(ctx)	((void *)((ctx)->sc_spi))
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/socket.S ports/sysdeps/unix/sysv/linux/m32r/socket.S
--- ports/sysdeps/unix/sysv/linux/m32r/socket.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/socket.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,155 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep-cancel.h>
+#include <socketcall.h>
+
+#define P(a, b) P2(a, b)
+#define P2(a, b) a##b
+
+	.text
+/* The socket-oriented system calls are handled unusally in Linux.
+   They are all gated through the single `socketcall' system call number.
+   `socketcall' takes two arguments: the first is the subcode, specifying
+   which socket function is being called; and the second is a pointer to
+   the arguments to the specific function.
+
+   The .S files for the other calls just #define socket and #include this.  */
+
+#ifndef __socket
+#ifndef NO_WEAK_ALIAS
+#define __socket P(__,socket)
+#else
+#define __socket socket
+#endif
+#endif
+
+#define PUSHARGS(x)	PUSHARGS x
+	.macro PUSHARGS nargs
+	push r0
+ 	.aif \nargs ge 2
+ 	  push r1
+ 	  .aif \nargs ge 3
+ 	    push r2
+ 	    .aif \nargs ge 4
+ 	      push r3
+ 	      /* If nargs is 5, caller has already pushed arg 5.  */
+ 	      /* If nargs is 6, caller has already pushed arg 5, 6.  */
+ 	    .aendi
+ 	  .aendi
+ 	.aendi
+	.endm
+
+#define PUSHARGS(x)	PUSHARGS x
+
+#define POPARGS_1	addi r15,#4
+#define POPARGS_2	addi r15,#8
+#define POPARGS_3	addi r15,#12
+#define POPARGS_4	addi r15,#16
+#define POPARGS_5	addi r15,#16
+#define POPARGS_6	addi r15,#16
+
+#ifndef NARGS
+#define NARGS 3			/* If we were called with no wrapper, this is really socket() */
+#endif
+
+.globl __socket
+ENTRY (__socket)
+	/* This will not work in the case of a socket call being interrupted
+	   by a signal.  If the signal handler uses any stack the arguments
+	   to socket will be trashed.  The results of a restart of any
+	   socket call are then unpredictable. */
+
+	/* Push args onto the stack.  */
+	/* PUSHARGS(NARGS) */
+#if (NARGS >= 4)
+	push	r3
+ 	/* If nargs is 6, caller has already pushed arg 5, 6.  */
+ 	/* If nargs is 5, caller has already pushed arg 5.  */
+#endif
+#if (NARGS >= 3)
+	push	r2
+#endif
+#if (NARGS >= 2)
+	push	r1
+#endif
+	push	r0
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	SINGLE_THREAD_P
+	bnez	r6, 2f
+#endif
+
+        /* Do the system call trap.  */
+	ldi	r0, #P(SOCKOP_,socket)
+	mv	r1, r15
+	ldi	r7, #SYS_ify(socketcall)
+	SYSCALL_INST
+
+	/* Pop args off the stack */
+	P(POPARGS_,NARGS)
+
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+	SYSCALL_ERROR_HANDLER
+	.fillinsn
+1:
+	/* Successful; return the syscall's value.  */
+	ret
+
+#if defined NEED_CANCELLATION && defined CENABLE
+	.fillinsn
+2:
+	SAVE_REGS
+	CENABLE
+	mv	r8, r0
+
+	ldi	r0, #P(SOCKOP_,socket)
+#if !defined PIC
+	add3	r1, r15, #8
+#else
+	add3	r1, r15, #12
+#endif
+	ldi	r7, #SYS_ify(socketcall)
+	SYSCALL_INST
+
+	push	r0
+	mv	r0, r8
+	CDISABLE
+	pop	r0
+	RESTORE_REGS
+
+	P(POPARGS_,NARGS)
+
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 3f			// i.e. error in linux
+
+	SYSCALL_ERROR_HANDLER
+	.fillinsn
+3:
+	ret
+#endif
+
+PSEUDO_END (__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sys/cachectl.h ports/sysdeps/unix/sysv/linux/m32r/sys/cachectl.h
--- ports/sysdeps/unix/sysv/linux/m32r/sys/cachectl.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sys/cachectl.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,38 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_CACHECTL_H
+#define _SYS_CACHECTL_H 1
+
+#include <features.h>
+
+/*
+ * Get the kernel definition for the op bits.
+ */
+#include <asm/cachectl.h>
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+extern int cacheflush (void *addr, __const int nbytes, __const int op) __THROW;
+#endif
+extern int _flush_cache (char *addr, __const int nbytes, __const int op) __THROW;
+
+__END_DECLS
+
+#endif /* sys/cachectl.h */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sys/io.h ports/sysdeps/unix/sysv/linux/m32r/sys/io.h
--- ports/sysdeps/unix/sysv/linux/m32r/sys/io.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sys/io.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,48 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef	_SYS_IO_H
+
+#define	_SYS_IO_H	1
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL is nonzero,
+   permission to access any I/O port is granted.  This call requires
+   root privileges. */
+extern int iopl (int __level) __THROW;
+
+/* The functions that actually perform reads and writes.  */
+extern unsigned char inb (unsigned long int port) __THROW;
+extern unsigned short int inw (unsigned long int port) __THROW;
+extern unsigned long int inl (unsigned long int port) __THROW;
+
+extern void outb (unsigned char value, unsigned long int port) __THROW;
+extern void outw (unsigned short value, unsigned long int port) __THROW;
+extern void outl (unsigned long value, unsigned long int port) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_IO_H */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sys/tas.h ports/sysdeps/unix/sysv/linux/m32r/sys/tas.h
--- ports/sysdeps/unix/sysv/linux/m32r/sys/tas.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sys/tas.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,13 @@
+#ifndef	_SYS_TAS_H
+
+#define	_SYS_TAS_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+extern int tas(int *) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_TAS_H */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sys/ucontext.h ports/sysdeps/unix/sysv/linux/m32r/sys/ucontext.h
--- ports/sysdeps/unix/sysv/linux/m32r/sys/ucontext.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sys/ucontext.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,111 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Where is System V/SH ABI?  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NFPREG	16
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NFPREG];
+
+#if 0
+#ifdef __USE_GNU
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15,
+#define R15	R15
+};
+#endif
+#endif /* 0 */
+
+typedef int freg_t;
+
+/* Number of FPU registers.  */
+#define NFPREG	16
+
+/* Structure to describe FPU registers.  */
+typedef freg_t fpregset_t[NFPREG];
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    fpregset_t fpregs;
+    fpregset_t xfpregs;
+    unsigned int fpscr;
+    unsigned int fpul;
+    unsigned int macl;
+    unsigned int mach;
+  } mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sys/user.h ports/sysdeps/unix/sysv/linux/m32r/sys/user.h
--- ports/sysdeps/unix/sysv/linux/m32r/sys/user.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sys/user.h	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,26 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SYS_USER_H
+#define _SYS_USER_H	1
+
+#include <features.h>
+
+#include <asm/user.h>
+
+#endif  /* sys/user.h */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/syscall.S ports/sysdeps/unix/sysv/linux/m32r/syscall.S
--- ports/sysdeps/unix/sysv/linux/m32r/syscall.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/syscall.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,41 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+ENTRY (__syscall)
+	mv	r7, r0			// syscall number
+	mv	r0, r1			// p1
+	mv	r1, r2			// p2
+	mv	r2, r3			// p3
+	ld	r3, @(sp)		// p4
+	ld	r4, @(4,sp)		// p5
+	ld	r5, @(8,sp)		// p6
+	ld	r6, @(12,sp)		// p7
+	SYSCALL_INST
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+	SYSCALL_ERROR_HANDLER
+	.fillinsn
+1:
+	ret
+PSEUDO_END (__syscall)
+
+weak_alias (__syscall, syscall)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/syscalls.list ports/sysdeps/unix/sysv/linux/m32r/syscalls.list
--- ports/sysdeps/unix/sysv/linux/m32r/syscalls.list	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/syscalls.list	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,4 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+tas		-	tas		i:p	__tas		tas
+cachectl	-	cachectl	i:pii	__cachectl	cachectl
+cacheflush	-	cacheflush	i:pii	__cacheflush	cacheflush
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sysdep.S ports/sysdeps/unix/sysv/linux/m32r/sysdep.S
--- ports/sysdeps/unix/sysv/linux/m32r/sysdep.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sysdep.S	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1,32 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+
+/* The syscall stubs jump here when they detect an error.
+   The code for Linux is almost identical to the canonical Unix
+   code, except that the error number in R0 is negated.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers R0.  */
+
+ENTRY (__syscall_error)
+	neg r0, r0
+
+#define __syscall_error __syscall_error_1
+#include "../../../m32r/sysdep.S"
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/sysdep.h ports/sysdeps/unix/sysv/linux/m32r/sysdep.h
--- ports/sysdeps/unix/sysv/linux/m32r/sysdep.h	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/sysdep.h	2006-03-02 12:29:40.000000000 +0900
@@ -0,0 +1,294 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation,
+   Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _LINUX_M32R_SYSDEP_H
+#define _LINUX_M32R_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include "../../../m32r/sysdep.h"
+
+/* Defines RTLD_PRIVATE_ERRNO.  */
+#include <dl-sysdep.h>
+
+/* For Linux we can use the system call table in the header file
+	/usr/include/asm/unistd.h
+   of the kernel.  But these symbols do not follow the SYS_* syntax
+   so we have to redefine the `SYS_ify' macro here.  */
+#undef SYS_ify
+#define SYS_ify(syscall_name)	__NR_##syscall_name
+
+#ifdef __ASSEMBLER__
+
+/* Linux uses a negative return value to indicate syscall errors,
+   unlike most Unices, which use the condition codes' carry flag.
+
+   Since version 2.1 the return value of a system call might be
+   negative even if the call succeeded.  E.g., the `lseek' system call
+   might return a large offset.  Therefore we must not anymore test
+   for < 0, but test for a real error by making sure the value in R0
+   is a real error number.  Linus said he will make sure the no syscall
+   returns a value in -1 .. -4095 as a valid result so we can savely
+   test with -4095.  */
+
+#define SYSCALL_INST    trap #2 || nop
+#define SYSCALL_INST_0	trap #2 || nop
+#define SYSCALL_INST_1	trap #2 || nop
+#define SYSCALL_INST_2	trap #2 || nop
+#define SYSCALL_INST_3	trap #2 || nop
+#define SYSCALL_INST_4	trap #2 || nop
+#define SYSCALL_INST_5	\
+  ld r4,@sp                    ! \
+  trap #2 || nop
+#define SYSCALL_INST_STR_6 \
+  ld r4,@sp                    ! \
+  ld r5,@(4,sp)                ! \
+  trap #2 || nop
+#define SYSCALL_INST_STR_7 \
+  ld r4,@sp                    ! \
+  ld r5,@(4,sp)                ! \
+  ld r6,@(8,sp)                ! \
+  trap #2 || nop
+
+#define DO_CALL( syscall_name, args )	\
+  ldi r7,SYS_ify(syscall_name)       ! \
+  SYSCALL_INST_##args
+
+#undef PSEUDO
+#define	PSEUDO(name, syscall_name, args) \
+  .text                                 !\
+ENTRY (name)                            !\
+  DO_CALL (syscall_name, args)          !\
+  not r1,r0                             !\
+  srai r1,12                            !\
+  bnez r1,.Lpseudo_end                  !\
+  SYSCALL_ERROR_HANDLER                 !\
+  .fillinsn                             !\
+ .Lpseudo_end:
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name) \
+  END (name)
+
+#undef  PSEUDO_NOERRNO
+#define PSEUDO_NOERRNO(name, syscall_name, args) \
+ .text !\
+ ENTRY (name) !\
+ DO_CALL (syscall_name, args)
+                                                                                
+#undef  PSEUDO_END_NOERRNO
+#define PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args) \
+ .text !\
+ ENTRY (name) !\
+ DO_CALL (syscall_name, args)
+                                                                                
+#undef  PSEUDO_END_ERRVAL
+#define PSEUDO_END_ERRVAL(name) \
+  END (name)
+                                                                                
+#define ret_ERRVAL ret
+
+#ifndef __PIC__
+#   define SYSCALL_ERROR_HANDLER \
+  LDIMM (r1, C_SYMBOL_NAME(__syscall_error)) !\
+  jmp r1                                !\
+
+#else
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER \
+  neg r1,r0                             !\
+  mv r3,lr                              !\
+  bl.s .+4                              !\
+  ld24 r2,#_GLOBAL_OFFSET_TABLE_        !\
+  add r2,lr                             !\
+  mv lr,r3                              !\
+  ld24 r0,#C_SYMBOL_NAME(rtld_errno@GOT)      !\
+  add r2,r0                             !\
+  ld r2,@r2                             !\
+  st r1,@r2                             !\
+  ldi r0,#-1                            !\
+  ret
+
+# elif defined _LIBC_REENTRANT
+
+#  if USE___THREAD
+#   ifndef NOT_IN_libc
+#    define SYSCALL_ERROR_ERRNO __libc_errno@GOT
+#   else
+#    define SYSCALL_ERROR_ERRNO errno@GOT
+#   endif
+#   define SYSCALL_ERROR_HANDLER \
+  neg r1,r0                             !\
+  mv r3,lr                              !\
+  bl.s .+4                              !\
+  ld24 r2,#_GLOBAL_OFFSET_TABLE_        !\
+  add r2,lr                             !\
+  mv lr,r3                              !\
+  ld24 r0,#C_SYMBOL_NAME(SYSCALL_ERROR_ERRNO)      !\
+  add r2,r0                             !\
+  ld r2,@r2                             !\
+  st r1,@r2                             !\
+  ldi r0,#-1                            !\
+  ret
+
+#  else
+#   define SYSCALL_ERROR_HANDLER \
+  neg r1,r0                             !\
+  push r12                              !\
+  push lr                               !\
+  push r1                               !\
+  bl.s .+4                              !\
+  ld24 r12,#_GLOBAL_OFFSET_TABLE_       !\
+  add r12,lr                            !\
+  ld24 r1,#C_SYMBOL_NAME(__errno_location@GOT) !\
+  add r1,r12                            !\
+  ld r1,@r1                             !\
+  jl r1                                 !\
+  pop r1                                !\
+  st r1,@r0                             !\
+  pop lr                                !\
+  pop r12                               !\
+  ldi r0,#-1                            !\
+  ret                                   !\
+
+#  endif
+
+# else
+/* Store (-r0) into errno through the GOT.  */
+#   define SYSCALL_ERROR_HANDLER \
+  neg r1,r0                             !\
+  mv r3,lr                              !\
+  bl.s .+4                              !\
+  ld24 r2,#_GLOBAL_OFFSET_TABLE_        !\
+  add r2,lr                             !\
+  mv lr,r3                              !\
+  ld24 r0,#C_SYMBOL_NAME(errno@GOT)     !\
+  add r2,r0                             !\
+  ld r2,@r2                             !\
+  st r1,@r2                             !\
+  ldi r0,#-1                            !\
+  ret
+
+# endif /* _LIBC_REENTRANT */
+#endif /* __PIC__ */
+
+#define ret_ERRVAL ret
+
+#else /* not __ASSEMBLER__ */
+
+#undef	DO_CALL
+
+#define SYSCALL_INST_STR   "trap #2 || nop\n\t"
+
+#define ASMFMT_0 \
+	, "0" (r0)
+#define ASMFMT_1 \
+	, "0" (r0)
+#define ASMFMT_2 \
+	, "0" (r0), "r" (r1)
+#define ASMFMT_3 \
+	, "0" (r0), "r" (r1), "r" (r2)
+#define ASMFMT_4 \
+	, "0" (r0), "r" (r1), "r" (r2), "r" (r3)
+#define ASMFMT_5 \
+	, "0" (r0), "r" (r1), "r" (r2), "r" (r3), "r" (r4)
+#define ASMFMT_6 \
+	, "0" (r0), "r" (r1), "r" (r2), "r" (r3), "r" (r4), "r" (r5)
+#define ASMFMT_7 \
+	, "0" (r0), "r" (r1), "r" (r2), "r" (r3), "r" (r4), "r" (r5), "r" (r6)
+
+#define SUBSTITUTE_ARGS_0() \
+	register long r0 asm ("r0") = 0
+#define SUBSTITUTE_ARGS_1(arg1)					\
+	register long r0 asm ("r0") = (long)(arg1)
+#define SUBSTITUTE_ARGS_2(arg1, arg2)				\
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2)
+#define SUBSTITUTE_ARGS_3(arg1, arg2, arg3)			\
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2);		\
+	register long r2 asm ("r2") = (long)(arg3)
+#define SUBSTITUTE_ARGS_4(arg1, arg2, arg3, arg4)		\
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2);		\
+	register long r2 asm ("r2") = (long)(arg3);		\
+	register long r3 asm ("r3") = (long)(arg4)
+#define SUBSTITUTE_ARGS_5(arg1, arg2, arg3, arg4, arg5) 	\
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2);		\
+	register long r2 asm ("r2") = (long)(arg3);		\
+	register long r3 asm ("r3") = (long)(arg4);		\
+	register long r4 asm ("r4") = (long)(arg5)
+#define SUBSTITUTE_ARGS_6(arg1, arg2, arg3, arg4, arg5, arg6)	\
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2);		\
+	register long r2 asm ("r2") = (long)(arg3);		\
+	register long r3 asm ("r3") = (long)(arg4);		\
+	register long r4 asm ("r4") = (long)(arg5);		\
+	register long r5 asm ("r5") = (long)(arg6)
+#define SUBSTITUTE_ARGS_7(arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
+	register long r0 asm ("r0") = (long)(arg1);		\
+	register long r1 asm ("r1") = (long)(arg2);		\
+	register long r2 asm ("r2") = (long)(arg3);		\
+	register long r3 asm ("r3") = (long)(arg4);		\
+	register long r4 asm ("r4") = (long)(arg5);		\
+	register long r5 asm ("r5") = (long)(arg6);		\
+	register long r6 asm ("r6") = (long)(arg7)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...) \
+  ({                                                                          \
+    unsigned int resultvar = INTERNAL_SYSCALL (name, , nr, args);             \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))         \
+      {                                                                       \
+        __set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));                   \
+        resultvar = 0xffffffff;                                               \
+      }                                                                       \
+    (int) resultvar; })
+                                                                                
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  ({                                                            \
+    register long r7 asm ("r7") = SYS_ify (name);               \
+    SUBSTITUTE_ARGS_##nr(args);                                 \
+                                                                \
+    asm volatile (SYSCALL_INST_STR     "\n\t"                   \
+                  : "=r" (r0)                                   \
+                  : "r" (r7) ASMFMT_##nr                        \
+                  : "memory");                                  \
+                                                                \
+    (int) r0; })
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned int) (val) >= 0xfffff001u)
+                                                                                
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)        (-(val))
+
+#endif	/* __ASSEMBLER__ */
+
+#endif /* linux/m32r/sysdep.h */
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/vfork.S ports/sysdeps/unix/sysv/linux/m32r/vfork.S
--- ports/sysdeps/unix/sysv/linux/m32r/vfork.S	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/vfork.S	2006-03-02 11:43:35.000000000 +0900
@@ -0,0 +1,48 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+#ifdef __NR_vfork
+	ldi	r7, #__NR_vfork
+	SYSCALL_INST
+	not	r1, r0
+	srai	r1, #12			// r1=0 means r0 = -1 to -4095
+	bnez	r1, 1f			// i.e. error in linux
+
+#endif
+
+	SYSCALL_ERROR_HANDLER
+
+	.fillinsn
+1:
+	ret
+
+PSEUDO_END (__vfork)
+libc_hidden_def(__vfork) 
+
+weak_alias (__vfork, vfork)
diff --exclude=CVS -upNr ports/sysdeps/unix/sysv/linux/m32r/xstat.c ports/sysdeps/unix/sysv/linux/m32r/xstat.c
--- ports/sysdeps/unix/sysv/linux/m32r/xstat.c	1970-01-01 09:00:00.000000000 +0900
+++ ports/sysdeps/unix/sysv/linux/m32r/xstat.c	2005-10-31 17:17:34.000000000 +0900
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/xstat.c>
