--- a/fs/udf/symlink.c	2019-09-02 16:06:58.158578983 +0800
+++ b/fs/udf/symlink.c	2019-09-02 16:34:06.746822295 +0800
@@ -30,7 +30,7 @@
 #include <linux/buffer_head.h>
 #include "udf_i.h"
 
-static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
+static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 			   int fromlen, unsigned char *to)
 {
 	struct pathComponent *pc;
@@ -39,14 +39,17 @@
 
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
+		elen += sizeof(struct pathComponent);
 		switch (pc->componentType) {
 		case 1:
 			/*
 			 * Symlink points to some place which should be agreed
  			 * upon between originator and receiver of the media. Ignore.
 			 */
-			if (pc->lengthComponentIdent > 0)
+			if (pc->lengthComponentIdent > 0) {
+				elen += pc->lengthComponentIdent;
 				break;
+			}
 			/* Fall through */
 		case 2:
 			p = to;
@@ -62,17 +65,20 @@
 			/* that would be . - just ignore */
 			break;
 		case 5:
+			elen += pc->lengthComponentIdent;
+			if (elen > fromlen)
+				return -EIO;
 			p += udf_get_filename(sb, pc->componentIdent, p,
 					      pc->lengthComponentIdent);
 			*p++ = '/';
 			break;
 		}
-		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
 	}
 	if (p > to + 1)
 		p[-1] = '\0';
 	else
 		p[0] = '\0';
+	return 0;
 }
 
 static int udf_symlink_filler(struct file *file, struct page *page)
