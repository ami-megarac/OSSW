diff -Naur linux_org/include/linux/filter.h linux/include/linux/filter.h
--- linux_org/include/linux/filter.h	2019-03-27 14:30:04.978917538 +0800
+++ linux/include/linux/filter.h	2019-03-27 14:30:56.163238168 +0800
@@ -41,7 +41,12 @@
 		   offsetof(struct sk_filter, insns[proglen]));
 }
 
-extern int sk_filter(struct sock *sk, struct sk_buff *skb);
+int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap);
+static inline int sk_filter(struct sock *sk, struct sk_buff *skb)
+{
+	return sk_filter_trim_cap(sk, skb, 1);
+}
+
 extern unsigned int sk_run_filter(const struct sk_buff *skb,
 				  const struct sock_filter *filter);
 extern int sk_unattached_filter_create(struct sk_filter **pfp,
diff -Naur linux_org/include/net/tcp.h linux/include/net/tcp.h
--- linux_org/include/net/tcp.h	2019-03-27 14:09:52.547897292 +0800
+++ linux/include/net/tcp.h	2019-03-27 14:33:35.828589786 +0800
@@ -1033,6 +1033,7 @@
 }
 
 bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
+int tcp_filter(struct sock *sk, struct sk_buff *skb);
 
 #undef STATE_TRACE
 
diff -Naur linux_org/net/core/filter.c linux/net/core/filter.c
--- linux_org/net/core/filter.c	2019-03-27 14:30:11.694653215 +0800
+++ linux/net/core/filter.c	2019-03-27 14:31:34.357159868 +0800
@@ -67,9 +67,10 @@
 }
 
 /**
- *	sk_filter - run a packet through a socket filter
+ *	sk_filter_trim_cap - run a packet through a socket filter
  *	@sk: sock associated with &sk_buff
  *	@skb: buffer to filter
+ *	@cap: limit on how short the eBPF program may trim the packet 
  *
  * Run the filter code and then cut skb->data to correct size returned by
  * sk_run_filter. If pkt_len is 0 we toss packet. If skb->len is smaller
@@ -78,7 +79,7 @@
  * be accepted or -EPERM if the packet should be tossed.
  *
  */
-int sk_filter(struct sock *sk, struct sk_buff *skb)
+int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap)
 {
 	int err;
 	struct sk_filter *filter;
diff -Naur linux_org/net/ipv4/tcp_ipv4.c linux/net/ipv4/tcp_ipv4.c
--- linux_org/net/ipv4/tcp_ipv4.c	2019-03-27 14:09:52.479898081 +0800
+++ linux/net/ipv4/tcp_ipv4.c	2019-03-27 14:34:20.525596375 +0800
@@ -1614,6 +1614,19 @@
 }
 EXPORT_SYMBOL(tcp_v4_conn_request);
 
+int tcp_filter(struct sock *sk, struct sk_buff *skb)
+{
+	struct tcphdr *th = (struct tcphdr *)skb->data;
+	unsigned int eaten = skb->len;
+	int err;
+	err = sk_filter_trim_cap(sk, skb, th->doff * 4);
+	if (!err) {
+		eaten -= skb->len;
+		TCP_SKB_CB(skb)->end_seq -= eaten;
+	}
+	return err;
+}
+EXPORT_SYMBOL(tcp_filter);
 
 /*
  * The three way handshake has completed - we got a valid synack -
@@ -1990,8 +2003,10 @@
 		goto discard_and_relse;
 	nf_reset(skb);
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
+	th = (const struct tcphdr *)skb->data;
+	iph = ip_hdr(skb);
 
 	sk_mark_napi_id(sk, skb);
 	skb->dev = NULL;
diff -Naur linux_org/net/ipv6/tcp_ipv6.c linux/net/ipv6/tcp_ipv6.c
--- linux_org/net/ipv6/tcp_ipv6.c	2019-03-27 14:09:52.483898034 +0800
+++ linux/net/ipv6/tcp_ipv6.c	2019-03-27 14:35:09.161836469 +0800
@@ -1347,7 +1347,7 @@
 		goto discard;
 #endif
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard;
 
 	/*
@@ -1519,9 +1519,11 @@
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_and_relse;
 
-	if (sk_filter(sk, skb))
+	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
-
+	th = (const struct tcphdr *)skb->data;
+	hdr = ipv6_hdr(skb);
+	
 	sk_mark_napi_id(sk, skb);
 	skb->dev = NULL;
 
