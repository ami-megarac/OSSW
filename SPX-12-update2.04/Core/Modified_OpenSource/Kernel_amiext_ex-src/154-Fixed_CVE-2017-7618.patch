diff -Naur linux_org/crypto/ahash.c linux/crypto/ahash.c
--- linux_org/crypto/ahash.c	2019-03-25 14:56:54.904364743 +0800
+++ linux/crypto/ahash.c	2019-03-25 14:58:22.451489813 +0800
@@ -30,6 +30,7 @@
 	crypto_completion_t complete;
 	void *data;
 	u8 *result;
+	u32 flags;	
 	void *ubuf[] CRYPTO_MINALIGN_ATTR;
 };
 
@@ -190,18 +191,33 @@
 	return len + (mask & ~(crypto_tfm_ctx_alignment() - 1));
 }
 
-static void ahash_op_unaligned_finish(struct ahash_request *req, int err)
-{
-	struct ahash_request_priv *priv = req->priv;
-
-	if (err == -EINPROGRESS)
-		return;
-
+static void ahash_restore_req(struct ahash_request *req, int err)
+ {
+ 	struct ahash_request_priv *priv = req->priv;
+ 
 	if (!err)
 		memcpy(priv->result, req->result,
 		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));
 
-	kzfree(priv);
+ 	/* Restore the original crypto request. */
+ 	req->result = priv->result;
+
+	ahash_request_set_callback(req, priv->flags,
+				   priv->complete, priv->data);
+ 	req->priv = NULL;
+ 
+ 	/* Free the req->priv.priv from the ADJUSTED request. */
+ 	kzfree(priv);
+ }
+
+static void ahash_notify_einprogress(struct ahash_request *req)
+{
+	struct ahash_request_priv *priv = req->priv;
+	struct crypto_async_request oreq;
+	
+	oreq.data = priv->data;
+
+	priv->complete(&oreq, -EINPROGRESS);	
 }
 
 static void ahash_op_unaligned_done(struct crypto_async_request *req, int err)
@@ -211,7 +227,12 @@
 	crypto_completion_t complete = priv->complete;
 	void *data = priv->data;
 
-	ahash_op_unaligned_finish(areq, err);
+	if (err == -EINPROGRESS) {
+		ahash_notify_einprogress(areq);
+		return;
+	}	
+	
+	ahash_restore_req(areq, err);
 
 	areq->base.complete = complete;
 	areq->base.data = data;
@@ -237,14 +258,20 @@
 	priv->result = req->result;
 	priv->complete = req->base.complete;
 	priv->data = req->base.data;
-
+	priv->flags = req->base.flags;
+	
 	req->result = PTR_ALIGN((u8 *)priv->ubuf, alignmask + 1);
 	req->base.complete = ahash_op_unaligned_done;
 	req->base.data = req;
 	req->priv = priv;
 
 	err = op(req);
-	ahash_op_unaligned_finish(req, err);
+	if (err == -EINPROGRESS ||
+	    (err == -EBUSY && (ahash_request_flags(req) &
+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))
+		return err;
+
+	ahash_restore_req(req, err);
 
 	return err;
 }
@@ -279,29 +306,18 @@
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_digest);
 
-static void ahash_def_finup_finish2(struct ahash_request *req, int err)
-{
-	struct ahash_request_priv *priv = req->priv;
-
-	if (err == -EINPROGRESS)
-		return;
-
-	if (!err)
-		memcpy(priv->result, req->result,
-		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));
-
-	kzfree(priv);
-}
-
 static void ahash_def_finup_done2(struct crypto_async_request *req, int err)
 {
-	struct ahash_request *areq = req->data;
+	struct ahash_request *areq = req->data;	
 	struct ahash_request_priv *priv = areq->priv;
 	crypto_completion_t complete = priv->complete;
 	void *data = priv->data;
+	
+	if (err == -EINPROGRESS)
+		return;
 
-	ahash_def_finup_finish2(areq, err);
-
+	ahash_restore_req(areq, err);
+	
 	complete(data, err);
 }
 
@@ -311,11 +327,15 @@
 		goto out;
 
 	req->base.complete = ahash_def_finup_done2;
-	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
+	
 	err = crypto_ahash_reqtfm(req)->final(req);
+	if (err == -EINPROGRESS ||
+	    (err == -EBUSY && (ahash_request_flags(req) &
+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))
+		return err;
 
 out:
-	ahash_def_finup_finish2(req, err);
+	ahash_restore_req(req, err);
 	return err;
 }
 
@@ -326,8 +346,18 @@
 	crypto_completion_t complete = priv->complete;
 	void *data = priv->data;
 
+	if (err == -EINPROGRESS) {
+		ahash_notify_einprogress(areq);
+		return;
+	}
+
+	areq->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;	
+	
 	err = ahash_def_finup_finish1(areq, err);
 
+	if (areq->priv)
+		return;	
+	
 	complete(data, err);
 }
 
@@ -337,7 +367,8 @@
 	unsigned long alignmask = crypto_ahash_alignmask(tfm);
 	unsigned int ds = crypto_ahash_digestsize(tfm);
 	struct ahash_request_priv *priv;
-
+	int err;
+	
 	priv = kmalloc(sizeof(*priv) + ahash_align_buffer_size(ds, alignmask),
 		       (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?
 		       GFP_KERNEL : GFP_ATOMIC);
@@ -347,13 +378,20 @@
 	priv->result = req->result;
 	priv->complete = req->base.complete;
 	priv->data = req->base.data;
-
+	priv->flags = req->base.flags;
+	
 	req->result = PTR_ALIGN((u8 *)priv->ubuf, alignmask + 1);
 	req->base.complete = ahash_def_finup_done1;
 	req->base.data = req;
 	req->priv = priv;
 
-	return ahash_def_finup_finish1(req, tfm->update(req));
+	err = tfm->update(req);
+	if (err == -EINPROGRESS ||
+	    (err == -EBUSY && (ahash_request_flags(req) &
+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))
+		return err;	
+	
+	return ahash_def_finup_finish1(req, err);
 }
 
 static int ahash_no_export(struct ahash_request *req, void *out)
diff -Naur linux_org/include/crypto/internal/hash.h linux/include/crypto/internal/hash.h
--- linux_org/include/crypto/internal/hash.h	2019-03-25 13:56:36.360710136 +0800
+++ linux/include/crypto/internal/hash.h	2019-03-25 15:03:25.222589644 +0800
@@ -151,6 +151,16 @@
 	return crypto_alloc_instance2(name, alg, ahash_instance_headroom());
 }
 
+static inline void ahash_request_complete(struct ahash_request *req, int err)
+{
+	req->base.complete(&req->base, err);
+}
+
+static inline u32 ahash_request_flags(struct ahash_request *req)
+{
+	return req->base.flags;
+}
+
 static inline struct crypto_ahash *crypto_spawn_ahash(
 	struct crypto_ahash_spawn *spawn)
 {
