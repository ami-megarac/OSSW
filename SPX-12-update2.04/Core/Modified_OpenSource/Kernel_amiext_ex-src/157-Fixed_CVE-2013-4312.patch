diff -Naur linux_org/include/linux/sched.h linux/include/linux/sched.h
--- linux_org/include/linux/sched.h	2019-03-27 14:09:52.147901937 +0800
+++ linux/include/linux/sched.h	2019-03-27 14:11:05.104421766 +0800
@@ -751,7 +751,8 @@
 	unsigned long mq_bytes;	/* How many bytes can be allocated to mqueue? */
 #endif
 	unsigned long locked_shm; /* How many pages of mlocked shm ? */
-
+	unsigned long unix_inflight;	/* How many files in flight in unix sockets */
+	
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	/* UID specific keyring */
 	struct key *session_keyring;	/* UID's default session keyring */
diff -Naur linux_org/net/unix/af_unix.c linux/net/unix/af_unix.c
--- linux_org/net/unix/af_unix.c	2019-03-27 14:09:52.243900821 +0800
+++ linux/net/unix/af_unix.c	2019-03-27 14:11:41.254337643 +0800
@@ -1369,6 +1369,21 @@
 	sock_wfree(skb);
 }
 
+/*
+ * The "user->unix_inflight" variable is protected by the garbage
+ * collection lock, and we just read it locklessly here. If you go
+ * over the limit, there might be a tiny race in actually noticing
+ * it across threads. Tough.
+ */
+static inline bool too_many_unix_fds(struct task_struct *p)
+{
+	struct user_struct *user = current_user();
+
+	if (unlikely(user->unix_inflight > task_rlimit(p, RLIMIT_NOFILE)))
+		return !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);
+	return false;
+}
+
 #define MAX_RECURSION_LEVEL 4
 
 static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
@@ -1377,6 +1392,9 @@
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
+	if (too_many_unix_fds(current))
+		return -ETOOMANYREFS;	
+	
 	for (i = scm->fp->count - 1; i >= 0; i--) {
 		struct sock *sk = unix_get_socket(scm->fp->fp[i]);
 
diff -Naur linux_org/net/unix/garbage.c linux/net/unix/garbage.c
--- linux_org/net/unix/garbage.c	2019-03-27 14:09:52.155901844 +0800
+++ linux/net/unix/garbage.c	2019-03-27 14:13:18.010855026 +0800
@@ -125,9 +125,11 @@
 void unix_inflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
+	
+	spin_lock(&unix_gc_lock);
+	
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
-		spin_lock(&unix_gc_lock);
 		if (atomic_long_inc_return(&u->inflight) == 1) {
 			BUG_ON(!list_empty(&u->link));
 			list_add_tail(&u->link, &gc_inflight_list);
@@ -135,22 +137,27 @@
 			BUG_ON(list_empty(&u->link));
 		}
 		unix_tot_inflight++;
-		spin_unlock(&unix_gc_lock);
 	}
+	fp->f_cred->user->unix_inflight++;
+	spin_unlock(&unix_gc_lock);
 }
 
 void unix_notinflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
+	
+	spin_lock(&unix_gc_lock);
+	
 	if (s) {
-		struct unix_sock *u = unix_sk(s);
-		spin_lock(&unix_gc_lock);
+		struct unix_sock *u = unix_sk(s);	
 		BUG_ON(list_empty(&u->link));
 		if (atomic_long_dec_and_test(&u->inflight))
 			list_del_init(&u->link);
 		unix_tot_inflight--;
-		spin_unlock(&unix_gc_lock);
+
 	}
+	fp->f_cred->user->unix_inflight--;
+	spin_unlock(&unix_gc_lock);
 }
 
 static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
