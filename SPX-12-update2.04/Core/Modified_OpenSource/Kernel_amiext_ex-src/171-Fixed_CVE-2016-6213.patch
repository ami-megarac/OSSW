diff -Naur linux_org/fs/mount.h linux/fs/mount.h
--- linux_org/fs/mount.h	2019-03-28 11:11:05.048630679 +0800
+++ linux/fs/mount.h	2019-03-28 11:11:35.510952079 +0800
@@ -11,6 +11,8 @@
 	u64			seq;	/* Sequence number to prevent loops */
 	wait_queue_head_t poll;
 	int event;
+	unsigned int		mounts; /* # of mounts in the namespace */
+	unsigned int		pending_mounts;	
 };
 
 struct mnt_pcp {
diff -Naur linux_org/fs/namespace.c linux/fs/namespace.c
--- linux_org/fs/namespace.c	2019-03-28 11:10:54.205177756 +0800
+++ linux/fs/namespace.c	2019-03-28 11:05:56.651365923 +0800
@@ -27,6 +27,9 @@
 #include "pnode.h"
 #include "internal.h"
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -795,6 +798,9 @@
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;	
+	
 	if (shadows)
 		hlist_add_after_rcu(&shadows->mnt_hash, &mnt->mnt_hash);
 	else
@@ -1244,9 +1250,14 @@
 		propagate_umount(&tmp_list);
 
 	hlist_for_each_entry(p, &tmp_list, mnt_hash) {
+		struct mnt_namespace *ns;
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how < 2)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1583,6 +1594,28 @@
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = ACCESS_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1652,10 +1685,18 @@
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;	
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}	
+	
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1692,11 +1733,13 @@
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;		
 		umount_tree(child, 0);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2484,6 +2527,8 @@
 	init_waitqueue_head(&new_ns->poll);
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;	
 	return new_ns;
 }
 
@@ -2533,6 +2578,7 @@
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2571,6 +2617,7 @@
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);
diff -Naur linux_org/fs/pnode.c linux/fs/pnode.c
--- linux_org/fs/pnode.c	2019-03-28 11:10:54.209177555 +0800
+++ linux/fs/pnode.c	2019-03-28 11:06:39.663890100 +0800
@@ -251,7 +251,7 @@
 		read_sequnlock_excl(&mount_lock);
 	}
 	hlist_add_head(&child->mnt_hash, list);
-	return 0;
+	return count_mounts(m->mnt_ns, child);
 }
 
 /*
diff -Naur linux_org/fs/pnode.h linux/fs/pnode.h
--- linux_org/fs/pnode.h	2019-03-28 11:10:54.209177555 +0800
+++ linux/fs/pnode.h	2019-03-28 11:06:58.109553508 +0800
@@ -51,4 +51,5 @@
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);			 
 #endif /* _LINUX_PNODE_H */
diff -Naur linux_org/include/linux/mount.h linux/include/linux/mount.h
--- linux_org/include/linux/mount.h	2019-03-28 11:10:54.209177555 +0800
+++ linux/include/linux/mount.h	2019-03-28 11:07:41.352751809 +0800
@@ -84,4 +84,6 @@
 
 extern dev_t name_to_dev_t(char *name);
 
+extern unsigned int sysctl_mount_max;
+
 #endif /* _LINUX_MOUNT_H */
diff -Naur linux_org/kernel/sysctl.c linux/kernel/sysctl.c
--- linux_org/kernel/sysctl.c	2019-03-28 11:10:54.209177555 +0800
+++ linux/kernel/sysctl.c	2019-03-28 11:09:06.492086453 +0800
@@ -63,6 +63,7 @@
 #include <linux/binfmts.h>
 #include <linux/sched/sysctl.h>
 #include <linux/kexec.h>
+#include <linux/mount.h>
 
 #include <asm/uaccess.h>
 #include <asm/processor.h>
@@ -1682,6 +1683,14 @@
 		.mode		= 0644,
 		.proc_handler	= proc_doulongvec_minmax,
 	},	
+	{
+		.procname	= "mount-max",
+		.data		= &sysctl_mount_max,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &one,
+	},	
 	{ }
 };
 
