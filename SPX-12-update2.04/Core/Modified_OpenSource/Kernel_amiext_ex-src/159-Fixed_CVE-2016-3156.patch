diff -Naur linux_org/net/ipv4/devinet.c linux/net/ipv4/devinet.c
--- linux_org/net/ipv4/devinet.c	2019-03-27 14:09:52.319899939 +0800
+++ linux/net/ipv4/devinet.c	2019-03-27 14:24:37.908498898 +0800
@@ -329,6 +329,9 @@
 
 	ASSERT_RTNL();
 
+	if (in_dev->dead)
+		goto no_promotions;	
+	
 	/* 1. Deleting primary ifaddr forces deletion all secondaries
 	 * unless alias promotion is set
 	 **/
@@ -374,7 +377,8 @@
 		    inet_ifa_match(ifa1->ifa_address, ifa))
 			fib_del_ifaddr(ifa, ifa1);
 	}
-
+	
+no_promotions:
 	/* 2. Unlink it */
 
 	*ifap = ifa1->ifa_next;
diff -Naur linux_org/net/ipv4/fib_frontend.c linux/net/ipv4/fib_frontend.c
--- linux_org/net/ipv4/fib_frontend.c	2019-03-27 14:09:52.323899892 +0800
+++ linux/net/ipv4/fib_frontend.c	2019-03-27 14:25:15.678262302 +0800
@@ -812,6 +812,9 @@
 		subnet = 1;
 	}
 
+	if (in_dev->dead)
+		goto no_promotions;	
+	
 	/* Deletion is more complicated than add.
 	 * We should take care of not to delete too much :-)
 	 *
@@ -887,6 +890,7 @@
 		}
 	}
 
+no_promotions:	
 	if (!(ok & BRD_OK))
 		fib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);
 	if (subnet && ifa->ifa_prefixlen < 31) {
diff -Naur linux_org/net/ipv4/netfilter/ipt_MASQUERADE.c linux/net/ipv4/netfilter/ipt_MASQUERADE.c
--- linux_org/net/ipv4/netfilter/ipt_MASQUERADE.c	2019-03-27 14:09:52.339899707 +0800
+++ linux/net/ipv4/netfilter/ipt_MASQUERADE.c	2019-03-27 14:25:44.768189172 +0800
@@ -128,10 +128,18 @@
 			   unsigned long event,
 			   void *ptr)
 {
-	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
+	struct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;	
 	struct netdev_notifier_info info;
 
-	netdev_notifier_info_init(&info, dev);
+	/* The masq_dev_notifier will catch the case of the device going
+	 * down.  So if the inetdev is dead and being destroyed we have
+	 * no work to do.  Otherwise this is an individual address removal
+	 * and we have to perform the flush.
+	 */
+	if (idev->dead)
+		return NOTIFY_DONE;
+
+	netdev_notifier_info_init(&info, idev->dev);
 	return masq_device_event(this, event, &info);
 }
 
