diff -Naur linux_org/fs/ext4/ext4.h linux/fs/ext4/ext4.h
--- linux_org/fs/ext4/ext4.h	2019-04-10 16:50:22.321804849 +0800
+++ linux/fs/ext4/ext4.h	2019-04-10 16:58:08.772112837 +0800
@@ -2636,9 +2636,6 @@
 extern int ext4_inline_data_fiemap(struct inode *inode,
 				   struct fiemap_extent_info *fieinfo,
 				   int *has_inline);
-extern int ext4_try_to_evict_inline_data(handle_t *handle,
-					 struct inode *inode,
-					 int needed);
 extern void ext4_inline_data_truncate(struct inode *inode, int *has_inline);
 
 extern int ext4_convert_inline_data(struct inode *inode);
diff -Naur linux_org/fs/ext4/inline.c linux/fs/ext4/inline.c
--- linux_org/fs/ext4/inline.c	2019-04-10 16:50:28.069513426 +0800
+++ linux/fs/ext4/inline.c	2019-04-10 16:58:45.382597351 +0800
@@ -872,11 +872,11 @@
 	}
 
 	if (ret == -ENOSPC) {
+		ext4_journal_stop(handle);
 		ret = ext4_da_convert_inline_data_to_extent(mapping,
 							    inode,
 							    flags,
-							    fsdata);
-		ext4_journal_stop(handle);
+							    fsdata);		
 		if (ret == -ENOSPC &&
 		    ext4_should_retry_alloc(inode->i_sb, &retries))
 			goto retry_journal;
@@ -1827,42 +1827,6 @@
 	return (error < 0 ? error : 0);
 }
 
-/*
- * Called during xattr set, and if we can sparse space 'needed',
- * just create the extent tree evict the data to the outer block.
- *
- * We use jbd2 instead of page cache to move data to the 1st block
- * so that the whole transaction can be committed as a whole and
- * the data isn't lost because of the delayed page cache write.
- */
-int ext4_try_to_evict_inline_data(handle_t *handle,
-				  struct inode *inode,
-				  int needed)
-{
-	int error;
-	struct ext4_xattr_entry *entry;
-	struct ext4_inode *raw_inode;
-	struct ext4_iloc iloc;
-
-	error = ext4_get_inode_loc(inode, &iloc);
-	if (error)
-		return error;
-
-	raw_inode = ext4_raw_inode(&iloc);
-	entry = (struct ext4_xattr_entry *)((void *)raw_inode +
-					    EXT4_I(inode)->i_inline_off);
-	if (EXT4_XATTR_LEN(entry->e_name_len) +
-	    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {
-		error = -ENOSPC;
-		goto out;
-	}
-
-	error = ext4_convert_inline_data_nolock(handle, inode, &iloc);
-out:
-	brelse(iloc.bh);
-	return error;
-}
-
 void ext4_inline_data_truncate(struct inode *inode, int *has_inline)
 {
 	handle_t *handle;
diff -Naur linux_org/fs/ext4/xattr.c linux/fs/ext4/xattr.c
--- linux_org/fs/ext4/xattr.c	2019-04-10 16:46:21.621694809 +0800
+++ linux/fs/ext4/xattr.c	2019-04-10 16:59:09.584391841 +0800
@@ -1003,22 +1003,8 @@
 	if (EXT4_I(inode)->i_extra_isize == 0)
 		return -ENOSPC;
 	error = ext4_xattr_set_entry(i, s, inode);
-	if (error) {
-		if (error == -ENOSPC &&
-		    ext4_has_inline_data(inode)) {
-			error = ext4_try_to_evict_inline_data(handle, inode,
-					EXT4_XATTR_LEN(strlen(i->name) +
-					EXT4_XATTR_SIZE(i->value_len)));
-			if (error)
-				return error;
-			error = ext4_xattr_ibody_find(inode, i, is);
-			if (error)
-				return error;
-			error = ext4_xattr_set_entry(i, s, inode);
-		}
-		if (error)
-			return error;
-	}
+	if (error)
+		return error;
 	header = IHDR(inode, ext4_raw_inode(&is->iloc));
 	if (!IS_LAST_ENTRY(s->first)) {
 		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
diff -Naur linux_org/fs/jbd2/transaction.c linux/fs/jbd2/transaction.c
--- linux_org/fs/jbd2/transaction.c	2019-04-10 16:50:15.798135260 +0800
+++ linux/fs/jbd2/transaction.c	2019-04-10 16:57:42.411173404 +0800
@@ -1290,12 +1290,12 @@
 		 * This buffer's got modified and becoming part
 		 * of the transaction. This needs to be done
 		 * once a transaction -bzzz
-		 */
-		jh->b_modified = 1;
+		 */		
 		if (handle->h_buffer_credits <= 0) {
 			ret = -ENOSPC;
 			goto out_unlock_bh;
 		}
+		jh->b_modified = 1;
 		handle->h_buffer_credits--;
 	}
 
